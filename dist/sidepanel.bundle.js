(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all4) => {
    for (var name in all4)
      __defProp(target, name, { get: all4[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/bail/index.js
  function bail(error) {
    if (error) {
      throw error;
    }
  }
  var init_bail = __esm({
    "node_modules/bail/index.js"() {
    }
  });

  // node_modules/extend/index.js
  var require_extend = __commonJS({
    "node_modules/extend/index.js"(exports, module) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;
      var isArray = function isArray2(arr) {
        if (typeof Array.isArray === "function") {
          return Array.isArray(arr);
        }
        return toStr.call(arr) === "[object Array]";
      };
      var isPlainObject2 = function isPlainObject3(obj) {
        if (!obj || toStr.call(obj) !== "[object Object]") {
          return false;
        }
        var hasOwnConstructor = hasOwn.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        var key2;
        for (key2 in obj) {
        }
        return typeof key2 === "undefined" || hasOwn.call(obj, key2);
      };
      var setProperty = function setProperty2(target, options) {
        if (defineProperty && options.name === "__proto__") {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      };
      var getProperty = function getProperty2(obj, name) {
        if (name === "__proto__") {
          if (!hasOwn.call(obj, name)) {
            return void 0;
          } else if (gOPD) {
            return gOPD(obj, name).value;
          }
        }
        return obj[name];
      };
      module.exports = function extend2() {
        var options, name, src, copy, copyIsArray, clone;
        var target = arguments[0];
        var i = 1;
        var length = arguments.length;
        var deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (target == null || typeof target !== "object" && typeof target !== "function") {
          target = {};
        }
        for (; i < length; ++i) {
          options = arguments[i];
          if (options != null) {
            for (name in options) {
              src = getProperty(target, name);
              copy = getProperty(options, name);
              if (target !== copy) {
                if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray(src) ? src : [];
                  } else {
                    clone = src && isPlainObject2(src) ? src : {};
                  }
                  setProperty(target, { name, newValue: extend2(deep, clone, copy) });
                } else if (typeof copy !== "undefined") {
                  setProperty(target, { name, newValue: copy });
                }
              }
            }
          }
        }
        return target;
      };
    }
  });

  // node_modules/devlop/lib/default.js
  function ok() {
  }
  var init_default = __esm({
    "node_modules/devlop/lib/default.js"() {
    }
  });

  // node_modules/is-plain-obj/index.js
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }
  var init_is_plain_obj = __esm({
    "node_modules/is-plain-obj/index.js"() {
    }
  });

  // node_modules/trough/lib/index.js
  function trough() {
    const fns = [];
    const pipeline = { run, use };
    return pipeline;
    function run(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next(null, ...values);
      function next(error, ...output) {
        const fn = fns[++middlewareIndex];
        let index2 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index2 < values.length) {
          if (output[index2] === null || output[index2] === void 0) {
            output[index2] = values[index2];
          }
        }
        values = output;
        if (fn) {
          wrap(fn, next)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }
  var init_lib = __esm({
    "node_modules/trough/lib/index.js"() {
    }
  });

  // node_modules/trough/index.js
  var init_trough = __esm({
    "node_modules/trough/index.js"() {
      init_lib();
    }
  });

  // node_modules/unist-util-stringify-position/lib/index.js
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position(value.position);
    }
    if ("start" in value || "end" in value) {
      return position(value);
    }
    if ("line" in value || "column" in value) {
      return point(value);
    }
    return "";
  }
  function point(point4) {
    return index(point4 && point4.line) + ":" + index(point4 && point4.column);
  }
  function position(pos) {
    return point(pos && pos.start) + "-" + point(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
  var init_lib2 = __esm({
    "node_modules/unist-util-stringify-position/lib/index.js"() {
    }
  });

  // node_modules/unist-util-stringify-position/index.js
  var init_unist_util_stringify_position = __esm({
    "node_modules/unist-util-stringify-position/index.js"() {
      init_lib2();
    }
  });

  // node_modules/vfile-message/lib/index.js
  var VFileMessage;
  var init_lib3 = __esm({
    "node_modules/vfile-message/lib/index.js"() {
      init_unist_util_stringify_position();
      VFileMessage = class extends Error {
        /**
         * Create a message for `reason`.
         *
         * > ðŸª¦ **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {Options | null | undefined} [options]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns
         *   Instance of `VFileMessage`.
         */
        // eslint-disable-next-line complexity
        constructor(causeOrReason, optionsOrParentOrPlace, origin) {
          super();
          if (typeof optionsOrParentOrPlace === "string") {
            origin = optionsOrParentOrPlace;
            optionsOrParentOrPlace = void 0;
          }
          let reason = "";
          let options = {};
          let legacyCause = false;
          if (optionsOrParentOrPlace) {
            if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
              options = { place: optionsOrParentOrPlace };
            } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
              options = { place: optionsOrParentOrPlace };
            } else if ("type" in optionsOrParentOrPlace) {
              options = {
                ancestors: [optionsOrParentOrPlace],
                place: optionsOrParentOrPlace.position
              };
            } else {
              options = { ...optionsOrParentOrPlace };
            }
          }
          if (typeof causeOrReason === "string") {
            reason = causeOrReason;
          } else if (!options.cause && causeOrReason) {
            legacyCause = true;
            reason = causeOrReason.message;
            options.cause = causeOrReason;
          }
          if (!options.ruleId && !options.source && typeof origin === "string") {
            const index2 = origin.indexOf(":");
            if (index2 === -1) {
              options.ruleId = origin;
            } else {
              options.source = origin.slice(0, index2);
              options.ruleId = origin.slice(index2 + 1);
            }
          }
          if (!options.place && options.ancestors && options.ancestors) {
            const parent = options.ancestors[options.ancestors.length - 1];
            if (parent) {
              options.place = parent.position;
            }
          }
          const start = options.place && "start" in options.place ? options.place.start : options.place;
          this.ancestors = options.ancestors || void 0;
          this.cause = options.cause || void 0;
          this.column = start ? start.column : void 0;
          this.fatal = void 0;
          this.file;
          this.message = reason;
          this.line = start ? start.line : void 0;
          this.name = stringifyPosition(options.place) || "1:1";
          this.place = options.place || void 0;
          this.reason = this.message;
          this.ruleId = options.ruleId || void 0;
          this.source = options.source || void 0;
          this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
          this.actual;
          this.expected;
          this.note;
          this.url;
        }
      };
      VFileMessage.prototype.file = "";
      VFileMessage.prototype.name = "";
      VFileMessage.prototype.reason = "";
      VFileMessage.prototype.message = "";
      VFileMessage.prototype.stack = "";
      VFileMessage.prototype.column = void 0;
      VFileMessage.prototype.line = void 0;
      VFileMessage.prototype.ancestors = void 0;
      VFileMessage.prototype.cause = void 0;
      VFileMessage.prototype.fatal = void 0;
      VFileMessage.prototype.place = void 0;
      VFileMessage.prototype.ruleId = void 0;
      VFileMessage.prototype.source = void 0;
    }
  });

  // node_modules/vfile-message/index.js
  var init_vfile_message = __esm({
    "node_modules/vfile-message/index.js"() {
      init_lib3();
    }
  });

  // node_modules/vfile/lib/minpath.browser.js
  function basename(path3, extname2) {
    if (extname2 !== void 0 && typeof extname2 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path3);
    let start = 0;
    let end = -1;
    let index2 = path3.length;
    let seenNonSlash;
    if (extname2 === void 0 || extname2.length === 0 || extname2.length > path3.length) {
      while (index2--) {
        if (path3.codePointAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index2 + 1;
        }
      }
      return end < 0 ? "" : path3.slice(start, end);
    }
    if (extname2 === path3) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname2.length - 1;
    while (index2--) {
      if (path3.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index2 + 1;
        }
        if (extnameIndex > -1) {
          if (path3.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end = index2;
            }
          } else {
            extnameIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path3.length;
    }
    return path3.slice(start, end);
  }
  function dirname(path3) {
    assertPath(path3);
    if (path3.length === 0) {
      return ".";
    }
    let end = -1;
    let index2 = path3.length;
    let unmatchedSlash;
    while (--index2) {
      if (path3.codePointAt(index2) === 47) {
        if (unmatchedSlash) {
          end = index2;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path3.codePointAt(0) === 47 ? "/" : "." : end === 1 && path3.codePointAt(0) === 47 ? "//" : path3.slice(0, end);
  }
  function extname(path3) {
    assertPath(path3);
    let index2 = path3.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index2--) {
      const code4 = path3.codePointAt(index2);
      if (code4 === 47) {
        if (unmatchedSlash) {
          startPart = index2 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index2 + 1;
      }
      if (code4 === 46) {
        if (startDot < 0) {
          startDot = index2;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path3.slice(startDot, end);
  }
  function join(...segments) {
    let index2 = -1;
    let joined;
    while (++index2 < segments.length) {
      assertPath(segments[index2]);
      if (segments[index2]) {
        joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
      }
    }
    return joined === void 0 ? "." : normalize(joined);
  }
  function normalize(path3) {
    assertPath(path3);
    const absolute = path3.codePointAt(0) === 47;
    let value = normalizeString(path3, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path3.codePointAt(path3.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString(path3, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index2 = -1;
    let code4;
    let lastSlashIndex;
    while (++index2 <= path3.length) {
      if (index2 < path3.length) {
        code4 = path3.codePointAt(index2);
      } else if (code4 === 47) {
        break;
      } else {
        code4 = 47;
      }
      if (code4 === 47) {
        if (lastSlash === index2 - 1 || dots === 1) {
        } else if (lastSlash !== index2 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index2;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path3.slice(lastSlash + 1, index2);
          } else {
            result = path3.slice(lastSlash + 1, index2);
          }
          lastSegmentLength = index2 - lastSlash - 1;
        }
        lastSlash = index2;
        dots = 0;
      } else if (code4 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath(path3) {
    if (typeof path3 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path3)
      );
    }
  }
  var minpath;
  var init_minpath_browser = __esm({
    "node_modules/vfile/lib/minpath.browser.js"() {
      minpath = { basename, dirname, extname, join, sep: "/" };
    }
  });

  // node_modules/vfile/lib/minproc.browser.js
  function cwd() {
    return "/";
  }
  var minproc;
  var init_minproc_browser = __esm({
    "node_modules/vfile/lib/minproc.browser.js"() {
      minproc = { cwd };
    }
  });

  // node_modules/vfile/lib/minurl.shared.js
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }
  var init_minurl_shared = __esm({
    "node_modules/vfile/lib/minurl.shared.js"() {
    }
  });

  // node_modules/vfile/lib/minurl.browser.js
  function urlToPath(path3) {
    if (typeof path3 === "string") {
      path3 = new URL(path3);
    } else if (!isUrl(path3)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path3 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path3.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path3);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index2 = -1;
    while (++index2 < pathname.length) {
      if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
        const third = pathname.codePointAt(index2 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  var init_minurl_browser = __esm({
    "node_modules/vfile/lib/minurl.browser.js"() {
      init_minurl_shared();
      init_minurl_shared();
    }
  });

  // node_modules/vfile/lib/index.js
  function assertPart(part, name) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name) {
    if (!part) {
      throw new Error("`" + name + "` cannot be empty");
    }
  }
  function assertPath2(path3, name) {
    if (!path3) {
      throw new Error("Setting `" + name + "` requires `path` to be set too");
    }
  }
  function isUint8Array(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  var order, VFile;
  var init_lib4 = __esm({
    "node_modules/vfile/lib/index.js"() {
      init_vfile_message();
      init_minpath_browser();
      init_minproc_browser();
      init_minurl_browser();
      order = /** @type {const} */
      [
        "history",
        "path",
        "basename",
        "stem",
        "extname",
        "dirname"
      ];
      VFile = class {
        /**
         * Create a new virtual file.
         *
         * `options` is treated as:
         *
         * *   `string` or `Uint8Array` â€” `{value: options}`
         * *   `URL` â€” `{path: options}`
         * *   `VFile` â€” shallow copies its data over to the new file
         * *   `object` â€” all fields are shallow copied over to the new file
         *
         * Path related fields are set in the following order (least specific to
         * most specific): `history`, `path`, `basename`, `stem`, `extname`,
         * `dirname`.
         *
         * You cannot set `dirname` or `extname` without setting either `history`,
         * `path`, `basename`, or `stem` too.
         *
         * @param {Compatible | null | undefined} [value]
         *   File value.
         * @returns
         *   New instance.
         */
        constructor(value) {
          let options;
          if (!value) {
            options = {};
          } else if (isUrl(value)) {
            options = { path: value };
          } else if (typeof value === "string" || isUint8Array(value)) {
            options = { value };
          } else {
            options = value;
          }
          this.cwd = "cwd" in options ? "" : minproc.cwd();
          this.data = {};
          this.history = [];
          this.messages = [];
          this.value;
          this.map;
          this.result;
          this.stored;
          let index2 = -1;
          while (++index2 < order.length) {
            const field2 = order[index2];
            if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
              this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
            }
          }
          let field;
          for (field in options) {
            if (!order.includes(field)) {
              this[field] = options[field];
            }
          }
        }
        /**
         * Get the basename (including extname) (example: `'index.min.js'`).
         *
         * @returns {string | undefined}
         *   Basename.
         */
        get basename() {
          return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
        }
        /**
         * Set basename (including extname) (`'index.min.js'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be nullified (use `file.path = file.dirname` instead).
         *
         * @param {string} basename
         *   Basename.
         * @returns {undefined}
         *   Nothing.
         */
        set basename(basename2) {
          assertNonEmpty(basename2, "basename");
          assertPart(basename2, "basename");
          this.path = minpath.join(this.dirname || "", basename2);
        }
        /**
         * Get the parent path (example: `'~'`).
         *
         * @returns {string | undefined}
         *   Dirname.
         */
        get dirname() {
          return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
        }
        /**
         * Set the parent path (example: `'~'`).
         *
         * Cannot be set if thereâ€™s no `path` yet.
         *
         * @param {string | undefined} dirname
         *   Dirname.
         * @returns {undefined}
         *   Nothing.
         */
        set dirname(dirname2) {
          assertPath2(this.basename, "dirname");
          this.path = minpath.join(dirname2 || "", this.basename);
        }
        /**
         * Get the extname (including dot) (example: `'.js'`).
         *
         * @returns {string | undefined}
         *   Extname.
         */
        get extname() {
          return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
        }
        /**
         * Set the extname (including dot) (example: `'.js'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be set if thereâ€™s no `path` yet.
         *
         * @param {string | undefined} extname
         *   Extname.
         * @returns {undefined}
         *   Nothing.
         */
        set extname(extname2) {
          assertPart(extname2, "extname");
          assertPath2(this.dirname, "extname");
          if (extname2) {
            if (extname2.codePointAt(0) !== 46) {
              throw new Error("`extname` must start with `.`");
            }
            if (extname2.includes(".", 1)) {
              throw new Error("`extname` cannot contain multiple dots");
            }
          }
          this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
        }
        /**
         * Get the full path (example: `'~/index.min.js'`).
         *
         * @returns {string}
         *   Path.
         */
        get path() {
          return this.history[this.history.length - 1];
        }
        /**
         * Set the full path (example: `'~/index.min.js'`).
         *
         * Cannot be nullified.
         * You can set a file URL (a `URL` object with a `file:` protocol) which will
         * be turned into a path with `url.fileURLToPath`.
         *
         * @param {URL | string} path
         *   Path.
         * @returns {undefined}
         *   Nothing.
         */
        set path(path3) {
          if (isUrl(path3)) {
            path3 = urlToPath(path3);
          }
          assertNonEmpty(path3, "path");
          if (this.path !== path3) {
            this.history.push(path3);
          }
        }
        /**
         * Get the stem (basename w/o extname) (example: `'index.min'`).
         *
         * @returns {string | undefined}
         *   Stem.
         */
        get stem() {
          return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
        }
        /**
         * Set the stem (basename w/o extname) (example: `'index.min'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be nullified (use `file.path = file.dirname` instead).
         *
         * @param {string} stem
         *   Stem.
         * @returns {undefined}
         *   Nothing.
         */
        set stem(stem) {
          assertNonEmpty(stem, "stem");
          assertPart(stem, "stem");
          this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
        }
        // Normal prototypal methods.
        /**
         * Create a fatal message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `true` (error; file not usable)
         * and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * > ðŸª¦ **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {never}
         *   Never.
         * @throws {VFileMessage}
         *   Message.
         */
        fail(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
          message.fatal = true;
          throw message;
        }
        /**
         * Create an info message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `undefined` (info; change
         * likely not needed) and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * > ðŸª¦ **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {VFileMessage}
         *   Message.
         */
        info(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
          message.fatal = void 0;
          return message;
        }
        /**
         * Create a message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `false` (warning; change may be
         * needed) and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * > ðŸª¦ **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {VFileMessage}
         *   Message.
         */
        message(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = new VFileMessage(
            // @ts-expect-error: the overloads are fine.
            causeOrReason,
            optionsOrParentOrPlace,
            origin
          );
          if (this.path) {
            message.name = this.path + ":" + message.name;
            message.file = this.path;
          }
          message.fatal = false;
          this.messages.push(message);
          return message;
        }
        /**
         * Serialize the file.
         *
         * > **Note**: which encodings are supported depends on the engine.
         * > For info on Node.js, see:
         * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
         *
         * @param {string | null | undefined} [encoding='utf8']
         *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
         *   (default: `'utf-8'`).
         * @returns {string}
         *   Serialized file.
         */
        toString(encoding) {
          if (this.value === void 0) {
            return "";
          }
          if (typeof this.value === "string") {
            return this.value;
          }
          const decoder = new TextDecoder(encoding || void 0);
          return decoder.decode(this.value);
        }
      };
    }
  });

  // node_modules/vfile/index.js
  var init_vfile = __esm({
    "node_modules/vfile/index.js"() {
      init_lib4();
    }
  });

  // node_modules/unified/lib/callable-instance.js
  var CallableInstance;
  var init_callable_instance = __esm({
    "node_modules/unified/lib/callable-instance.js"() {
      CallableInstance = /**
       * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
       */
      /** @type {unknown} */
      /**
       * @this {Function}
       * @param {string | symbol} property
       * @returns {(...parameters: Array<unknown>) => unknown}
       */
      function(property) {
        const self2 = this;
        const constr = self2.constructor;
        const proto = (
          /** @type {Record<string | symbol, Function>} */
          // Prototypes do exist.
          // type-coverage:ignore-next-line
          constr.prototype
        );
        const value = proto[property];
        const apply = function() {
          return value.apply(apply, arguments);
        };
        Object.setPrototypeOf(apply, proto);
        return apply;
      };
    }
  });

  // node_modules/unified/lib/index.js
  function assertParser(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `parser`");
    }
  }
  function assertCompiler(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `compiler`");
    }
  }
  function assertUnfrozen(name, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node2) {
    if (!isPlainObject(node2) || typeof node2.type !== "string") {
      throw new TypeError("Expected node, got `" + node2 + "`");
    }
  }
  function assertDone(name, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAValue(value) {
    return typeof value === "string" || isUint8Array2(value);
  }
  function isUint8Array2(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  var import_extend, own, Processor, unified;
  var init_lib5 = __esm({
    "node_modules/unified/lib/index.js"() {
      init_bail();
      import_extend = __toESM(require_extend(), 1);
      init_default();
      init_is_plain_obj();
      init_trough();
      init_vfile();
      init_callable_instance();
      own = {}.hasOwnProperty;
      Processor = class _Processor extends CallableInstance {
        /**
         * Create a processor.
         */
        constructor() {
          super("copy");
          this.Compiler = void 0;
          this.Parser = void 0;
          this.attachers = [];
          this.compiler = void 0;
          this.freezeIndex = -1;
          this.frozen = void 0;
          this.namespace = {};
          this.parser = void 0;
          this.transformers = trough();
        }
        /**
         * Copy a processor.
         *
         * @deprecated
         *   This is a private internal method and should not be used.
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   New *unfrozen* processor ({@linkcode Processor}) that is
         *   configured to work the same as its ancestor.
         *   When the descendant processor is configured in the future it does not
         *   affect the ancestral processor.
         */
        copy() {
          const destination = (
            /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
            new _Processor()
          );
          let index2 = -1;
          while (++index2 < this.attachers.length) {
            const attacher = this.attachers[index2];
            destination.use(...attacher);
          }
          destination.data((0, import_extend.default)(true, {}, this.namespace));
          return destination;
        }
        /**
         * Configure the processor with info available to all plugins.
         * Information is stored in an object.
         *
         * Typically, options can be given to a specific plugin, but sometimes it
         * makes sense to have information shared with several plugins.
         * For example, a list of HTML elements that are self-closing, which is
         * needed during all phases.
         *
         * > **Note**: setting information cannot occur on *frozen* processors.
         * > Call the processor first to create a new unfrozen processor.
         *
         * > **Note**: to register custom data in TypeScript, augment the
         * > {@linkcode Data} interface.
         *
         * @example
         *   This example show how to get and set info:
         *
         *   ```js
         *   import {unified} from 'unified'
         *
         *   const processor = unified().data('alpha', 'bravo')
         *
         *   processor.data('alpha') // => 'bravo'
         *
         *   processor.data() // => {alpha: 'bravo'}
         *
         *   processor.data({charlie: 'delta'})
         *
         *   processor.data() // => {charlie: 'delta'}
         *   ```
         *
         * @template {keyof Data} Key
         *
         * @overload
         * @returns {Data}
         *
         * @overload
         * @param {Data} dataset
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {Key} key
         * @returns {Data[Key]}
         *
         * @overload
         * @param {Key} key
         * @param {Data[Key]} value
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @param {Data | Key} [key]
         *   Key to get or set, or entire dataset to set, or nothing to get the
         *   entire dataset (optional).
         * @param {Data[Key]} [value]
         *   Value to set (optional).
         * @returns {unknown}
         *   The current processor when setting, the value at `key` when getting, or
         *   the entire dataset when getting without key.
         */
        data(key2, value) {
          if (typeof key2 === "string") {
            if (arguments.length === 2) {
              assertUnfrozen("data", this.frozen);
              this.namespace[key2] = value;
              return this;
            }
            return own.call(this.namespace, key2) && this.namespace[key2] || void 0;
          }
          if (key2) {
            assertUnfrozen("data", this.frozen);
            this.namespace = key2;
            return this;
          }
          return this.namespace;
        }
        /**
         * Freeze a processor.
         *
         * Frozen processors are meant to be extended and not to be configured
         * directly.
         *
         * When a processor is frozen it cannot be unfrozen.
         * New processors working the same way can be created by calling the
         * processor.
         *
         * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
         * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
         * `.stringify()`, `.process()`, or `.processSync()` are called.
         *
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   The current processor.
         */
        freeze() {
          if (this.frozen) {
            return this;
          }
          const self2 = (
            /** @type {Processor} */
            /** @type {unknown} */
            this
          );
          while (++this.freezeIndex < this.attachers.length) {
            const [attacher, ...options] = this.attachers[this.freezeIndex];
            if (options[0] === false) {
              continue;
            }
            if (options[0] === true) {
              options[0] = void 0;
            }
            const transformer = attacher.call(self2, ...options);
            if (typeof transformer === "function") {
              this.transformers.use(transformer);
            }
          }
          this.frozen = true;
          this.freezeIndex = Number.POSITIVE_INFINITY;
          return this;
        }
        /**
         * Parse text to a syntax tree.
         *
         * > **Note**: `parse` freezes the processor if not already *frozen*.
         *
         * > **Note**: `parse` performs the parse phase, not the run phase or other
         * > phases.
         *
         * @param {Compatible | undefined} [file]
         *   file to parse (optional); typically `string` or `VFile`; any value
         *   accepted as `x` in `new VFile(x)`.
         * @returns {ParseTree extends undefined ? Node : ParseTree}
         *   Syntax tree representing `file`.
         */
        parse(file) {
          this.freeze();
          const realFile = vfile(file);
          const parser2 = this.parser || this.Parser;
          assertParser("parse", parser2);
          return parser2(String(realFile), realFile);
        }
        /**
         * Process the given file as configured on the processor.
         *
         * > **Note**: `process` freezes the processor if not already *frozen*.
         *
         * > **Note**: `process` performs the parse, run, and stringify phases.
         *
         * @overload
         * @param {Compatible | undefined} file
         * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
         * @returns {undefined}
         *
         * @overload
         * @param {Compatible | undefined} [file]
         * @returns {Promise<VFileWithOutput<CompileResult>>}
         *
         * @param {Compatible | undefined} [file]
         *   File (optional); typically `string` or `VFile`]; any value accepted as
         *   `x` in `new VFile(x)`.
         * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
         *   Callback (optional).
         * @returns {Promise<VFile> | undefined}
         *   Nothing if `done` is given.
         *   Otherwise a promise, rejected with a fatal error or resolved with the
         *   processed file.
         *
         *   The parsed, transformed, and compiled value is available at
         *   `file.value` (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most
         *   > compilers return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        process(file, done) {
          const self2 = this;
          this.freeze();
          assertParser("process", this.parser || this.Parser);
          assertCompiler("process", this.compiler || this.Compiler);
          return done ? executor(void 0, done) : new Promise(executor);
          function executor(resolve, reject) {
            const realFile = vfile(file);
            const parseTree3 = (
              /** @type {HeadTree extends undefined ? Node : HeadTree} */
              /** @type {unknown} */
              self2.parse(realFile)
            );
            self2.run(parseTree3, realFile, function(error, tree, file2) {
              if (error || !tree || !file2) {
                return realDone(error);
              }
              const compileTree = (
                /** @type {CompileTree extends undefined ? Node : CompileTree} */
                /** @type {unknown} */
                tree
              );
              const compileResult = self2.stringify(compileTree, file2);
              if (looksLikeAValue(compileResult)) {
                file2.value = compileResult;
              } else {
                file2.result = compileResult;
              }
              realDone(
                error,
                /** @type {VFileWithOutput<CompileResult>} */
                file2
              );
            });
            function realDone(error, file2) {
              if (error || !file2) {
                reject(error);
              } else if (resolve) {
                resolve(file2);
              } else {
                ok(done, "`done` is defined if `resolve` is not");
                done(void 0, file2);
              }
            }
          }
        }
        /**
         * Process the given file as configured on the processor.
         *
         * An error is thrown if asynchronous transforms are configured.
         *
         * > **Note**: `processSync` freezes the processor if not already *frozen*.
         *
         * > **Note**: `processSync` performs the parse, run, and stringify phases.
         *
         * @param {Compatible | undefined} [file]
         *   File (optional); typically `string` or `VFile`; any value accepted as
         *   `x` in `new VFile(x)`.
         * @returns {VFileWithOutput<CompileResult>}
         *   The processed file.
         *
         *   The parsed, transformed, and compiled value is available at
         *   `file.value` (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most
         *   > compilers return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        processSync(file) {
          let complete = false;
          let result;
          this.freeze();
          assertParser("processSync", this.parser || this.Parser);
          assertCompiler("processSync", this.compiler || this.Compiler);
          this.process(file, realDone);
          assertDone("processSync", "process", complete);
          ok(result, "we either bailed on an error or have a tree");
          return result;
          function realDone(error, file2) {
            complete = true;
            bail(error);
            result = file2;
          }
        }
        /**
         * Run *transformers* on a syntax tree.
         *
         * > **Note**: `run` freezes the processor if not already *frozen*.
         *
         * > **Note**: `run` performs the run phase, not other phases.
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
         * @returns {undefined}
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {Compatible | undefined} file
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
         * @returns {undefined}
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {Compatible | undefined} [file]
         * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
         *
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         *   Tree to transform and inspect.
         * @param {(
         *   RunCallback<TailTree extends undefined ? Node : TailTree> |
         *   Compatible
         * )} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
         *   Callback (optional).
         * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
         *   Nothing if `done` is given.
         *   Otherwise, a promise rejected with a fatal error or resolved with the
         *   transformed tree.
         */
        run(tree, file, done) {
          assertNode(tree);
          this.freeze();
          const transformers = this.transformers;
          if (!done && typeof file === "function") {
            done = file;
            file = void 0;
          }
          return done ? executor(void 0, done) : new Promise(executor);
          function executor(resolve, reject) {
            ok(
              typeof file !== "function",
              "`file` can\u2019t be a `done` anymore, we checked"
            );
            const realFile = vfile(file);
            transformers.run(tree, realFile, realDone);
            function realDone(error, outputTree, file2) {
              const resultingTree = (
                /** @type {TailTree extends undefined ? Node : TailTree} */
                outputTree || tree
              );
              if (error) {
                reject(error);
              } else if (resolve) {
                resolve(resultingTree);
              } else {
                ok(done, "`done` is defined if `resolve` is not");
                done(void 0, resultingTree, file2);
              }
            }
          }
        }
        /**
         * Run *transformers* on a syntax tree.
         *
         * An error is thrown if asynchronous transforms are configured.
         *
         * > **Note**: `runSync` freezes the processor if not already *frozen*.
         *
         * > **Note**: `runSync` performs the run phase, not other phases.
         *
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         *   Tree to transform and inspect.
         * @param {Compatible | undefined} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @returns {TailTree extends undefined ? Node : TailTree}
         *   Transformed tree.
         */
        runSync(tree, file) {
          let complete = false;
          let result;
          this.run(tree, file, realDone);
          assertDone("runSync", "run", complete);
          ok(result, "we either bailed on an error or have a tree");
          return result;
          function realDone(error, tree2) {
            bail(error);
            result = tree2;
            complete = true;
          }
        }
        /**
         * Compile a syntax tree.
         *
         * > **Note**: `stringify` freezes the processor if not already *frozen*.
         *
         * > **Note**: `stringify` performs the stringify phase, not the run phase
         * > or other phases.
         *
         * @param {CompileTree extends undefined ? Node : CompileTree} tree
         *   Tree to compile.
         * @param {Compatible | undefined} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @returns {CompileResult extends undefined ? Value : CompileResult}
         *   Textual representation of the tree (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most compilers
         *   > return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        stringify(tree, file) {
          this.freeze();
          const realFile = vfile(file);
          const compiler2 = this.compiler || this.Compiler;
          assertCompiler("stringify", compiler2);
          assertNode(tree);
          return compiler2(tree, realFile);
        }
        /**
         * Configure the processor to use a plugin, a list of usable values, or a
         * preset.
         *
         * If the processor is already using a plugin, the previous plugin
         * configuration is changed based on the options that are passed in.
         * In other words, the plugin is not added a second time.
         *
         * > **Note**: `use` cannot be called on *frozen* processors.
         * > Call the processor first to create a new unfrozen processor.
         *
         * @example
         *   There are many ways to pass plugins to `.use()`.
         *   This example gives an overview:
         *
         *   ```js
         *   import {unified} from 'unified'
         *
         *   unified()
         *     // Plugin with options:
         *     .use(pluginA, {x: true, y: true})
         *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
         *     .use(pluginA, {y: false, z: true})
         *     // Plugins:
         *     .use([pluginB, pluginC])
         *     // Two plugins, the second with options:
         *     .use([pluginD, [pluginE, {}]])
         *     // Preset with plugins and settings:
         *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
         *     // Settings only:
         *     .use({settings: {position: false}})
         *   ```
         *
         * @template {Array<unknown>} [Parameters=[]]
         * @template {Node | string | undefined} [Input=undefined]
         * @template [Output=Input]
         *
         * @overload
         * @param {Preset | null | undefined} [preset]
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {PluggableList} list
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {Plugin<Parameters, Input, Output>} plugin
         * @param {...(Parameters | [boolean])} parameters
         * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
         *
         * @param {PluggableList | Plugin | Preset | null | undefined} value
         *   Usable value.
         * @param {...unknown} parameters
         *   Parameters, when a plugin is given as a usable value.
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   Current processor.
         */
        use(value, ...parameters) {
          const attachers = this.attachers;
          const namespace = this.namespace;
          assertUnfrozen("use", this.frozen);
          if (value === null || value === void 0) {
          } else if (typeof value === "function") {
            addPlugin(value, parameters);
          } else if (typeof value === "object") {
            if (Array.isArray(value)) {
              addList(value);
            } else {
              addPreset(value);
            }
          } else {
            throw new TypeError("Expected usable value, not `" + value + "`");
          }
          return this;
          function add(value2) {
            if (typeof value2 === "function") {
              addPlugin(value2, []);
            } else if (typeof value2 === "object") {
              if (Array.isArray(value2)) {
                const [plugin, ...parameters2] = (
                  /** @type {PluginTuple<Array<unknown>>} */
                  value2
                );
                addPlugin(plugin, parameters2);
              } else {
                addPreset(value2);
              }
            } else {
              throw new TypeError("Expected usable value, not `" + value2 + "`");
            }
          }
          function addPreset(result) {
            if (!("plugins" in result) && !("settings" in result)) {
              throw new Error(
                "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
              );
            }
            addList(result.plugins);
            if (result.settings) {
              namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
            }
          }
          function addList(plugins) {
            let index2 = -1;
            if (plugins === null || plugins === void 0) {
            } else if (Array.isArray(plugins)) {
              while (++index2 < plugins.length) {
                const thing = plugins[index2];
                add(thing);
              }
            } else {
              throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
            }
          }
          function addPlugin(plugin, parameters2) {
            let index2 = -1;
            let entryIndex = -1;
            while (++index2 < attachers.length) {
              if (attachers[index2][0] === plugin) {
                entryIndex = index2;
                break;
              }
            }
            if (entryIndex === -1) {
              attachers.push([plugin, ...parameters2]);
            } else if (parameters2.length > 0) {
              let [primary, ...rest] = parameters2;
              const currentPrimary = attachers[entryIndex][1];
              if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
                primary = (0, import_extend.default)(true, currentPrimary, primary);
              }
              attachers[entryIndex] = [plugin, primary, ...rest];
            }
          }
        }
      };
      unified = new Processor().freeze();
    }
  });

  // node_modules/unified/index.js
  var init_unified = __esm({
    "node_modules/unified/index.js"() {
      init_lib5();
    }
  });

  // node_modules/mdast-util-to-string/lib/index.js
  function toString(value, options) {
    const settings = options || emptyOptions;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one(value, includeImageAlt, includeHtml);
  }
  function one(value, includeImageAlt, includeHtml) {
    if (node(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all(values, includeImageAlt, includeHtml) {
    const result = [];
    let index2 = -1;
    while (++index2 < values.length) {
      result[index2] = one(values[index2], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value) {
    return Boolean(value && typeof value === "object");
  }
  var emptyOptions;
  var init_lib6 = __esm({
    "node_modules/mdast-util-to-string/lib/index.js"() {
      emptyOptions = {};
    }
  });

  // node_modules/mdast-util-to-string/index.js
  var init_mdast_util_to_string = __esm({
    "node_modules/mdast-util-to-string/index.js"() {
      init_lib6();
    }
  });

  // node_modules/decode-named-character-reference/index.dom.js
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element.innerHTML = characterReference2;
    const character = element.textContent;
    if (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      character.charCodeAt(character.length - 1) === 59 && value !== "semi"
    ) {
      return false;
    }
    return character === characterReference2 ? false : character;
  }
  var element;
  var init_index_dom = __esm({
    "node_modules/decode-named-character-reference/index.dom.js"() {
      element = document.createElement("i");
    }
  });

  // node_modules/micromark-util-chunked/index.js
  function splice(list4, start, remove, items) {
    const end = list4.length;
    let chunkStart = 0;
    let parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove);
      list4.splice(...parameters);
    } else {
      if (remove) list4.splice(start, remove);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        list4.splice(...parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  function push(list4, items) {
    if (list4.length > 0) {
      splice(list4, list4.length, 0, items);
      return list4;
    }
    return items;
  }
  var init_micromark_util_chunked = __esm({
    "node_modules/micromark-util-chunked/index.js"() {
    }
  });

  // node_modules/micromark-util-combine-extensions/index.js
  function combineExtensions(extensions) {
    const all4 = {};
    let index2 = -1;
    while (++index2 < extensions.length) {
      syntaxExtension(all4, extensions[index2]);
    }
    return all4;
  }
  function syntaxExtension(all4, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty.call(all4, hook) ? all4[hook] : void 0;
      const left = maybe || (all4[hook] = {});
      const right = extension2[hook];
      let code4;
      if (right) {
        for (code4 in right) {
          if (!hasOwnProperty.call(left, code4)) left[code4] = [];
          const value = right[code4];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code4],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list4) {
    let index2 = -1;
    const before = [];
    while (++index2 < list4.length) {
      ;
      (list4[index2].add === "after" ? existing : before).push(list4[index2]);
    }
    splice(existing, 0, 0, before);
  }
  var hasOwnProperty;
  var init_micromark_util_combine_extensions = __esm({
    "node_modules/micromark-util-combine-extensions/index.js"() {
      init_micromark_util_chunked();
      hasOwnProperty = {}.hasOwnProperty;
    }
  });

  // node_modules/micromark-util-decode-numeric-character-reference/index.js
  function decodeNumericCharacterReference(value, base) {
    const code4 = Number.parseInt(value, base);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code4 < 9 || code4 === 11 || code4 > 13 && code4 < 32 || // Control character (DEL) of C0, and C1 controls.
      code4 > 126 && code4 < 160 || // Lone high surrogates and low surrogates.
      code4 > 55295 && code4 < 57344 || // Noncharacters.
      code4 > 64975 && code4 < 65008 || /* eslint-disable no-bitwise */
      (code4 & 65535) === 65535 || (code4 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code4 > 1114111
    ) {
      return "\uFFFD";
    }
    return String.fromCodePoint(code4);
  }
  var init_micromark_util_decode_numeric_character_reference = __esm({
    "node_modules/micromark-util-decode-numeric-character-reference/index.js"() {
    }
  });

  // node_modules/micromark-util-normalize-identifier/index.js
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  var init_micromark_util_normalize_identifier = __esm({
    "node_modules/micromark-util-normalize-identifier/index.js"() {
    }
  });

  // node_modules/micromark-util-character/index.js
  function asciiControl(code4) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code4 !== null && (code4 < 32 || code4 === 127)
    );
  }
  function markdownLineEnding(code4) {
    return code4 !== null && code4 < -2;
  }
  function markdownLineEndingOrSpace(code4) {
    return code4 !== null && (code4 < 0 || code4 === 32);
  }
  function markdownSpace(code4) {
    return code4 === -2 || code4 === -1 || code4 === 32;
  }
  function regexCheck(regex) {
    return check;
    function check(code4) {
      return code4 !== null && code4 > -1 && regex.test(String.fromCharCode(code4));
    }
  }
  var asciiAlpha, asciiAlphanumeric, asciiAtext, asciiDigit, asciiHexDigit, asciiPunctuation, unicodePunctuation, unicodeWhitespace;
  var init_micromark_util_character = __esm({
    "node_modules/micromark-util-character/index.js"() {
      asciiAlpha = regexCheck(/[A-Za-z]/);
      asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
      asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
      asciiDigit = regexCheck(/\d/);
      asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
      asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
      unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
      unicodeWhitespace = regexCheck(/\s/);
    }
  });

  // node_modules/micromark-util-sanitize-uri/index.js
  function normalizeUri(value) {
    const result = [];
    let index2 = -1;
    let start = 0;
    let skip = 0;
    while (++index2 < value.length) {
      const code4 = value.charCodeAt(index2);
      let replace2 = "";
      if (code4 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
        skip = 2;
      } else if (code4 < 128) {
        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code4))) {
          replace2 = String.fromCharCode(code4);
        }
      } else if (code4 > 55295 && code4 < 57344) {
        const next = value.charCodeAt(index2 + 1);
        if (code4 < 56320 && next > 56319 && next < 57344) {
          replace2 = String.fromCharCode(code4, next);
          skip = 1;
        } else {
          replace2 = "\uFFFD";
        }
      } else {
        replace2 = String.fromCharCode(code4);
      }
      if (replace2) {
        result.push(value.slice(start, index2), encodeURIComponent(replace2));
        start = index2 + skip + 1;
        replace2 = "";
      }
      if (skip) {
        index2 += skip;
        skip = 0;
      }
    }
    return result.join("") + value.slice(start);
  }
  var init_micromark_util_sanitize_uri = __esm({
    "node_modules/micromark-util-sanitize-uri/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-space/index.js
  function factorySpace(effects, ok3, type, max) {
    const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
    let size = 0;
    return start;
    function start(code4) {
      if (markdownSpace(code4)) {
        effects.enter(type);
        return prefix(code4);
      }
      return ok3(code4);
    }
    function prefix(code4) {
      if (markdownSpace(code4) && size++ < limit) {
        effects.consume(code4);
        return prefix;
      }
      effects.exit(type);
      return ok3(code4);
    }
  }
  var init_micromark_factory_space = __esm({
    "node_modules/micromark-factory-space/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark/lib/initialize/content.js
  function initializeContent(effects) {
    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
    let previous4;
    return contentStart;
    function afterContentStartConstruct(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code4) {
      effects.enter("paragraph");
      return lineStart(code4);
    }
    function lineStart(code4) {
      const token = effects.enter("chunkText", {
        contentType: "text",
        previous: previous4
      });
      if (previous4) {
        previous4.next = token;
      }
      previous4 = token;
      return data(code4);
    }
    function data(code4) {
      if (code4 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code4);
        return;
      }
      if (markdownLineEnding(code4)) {
        effects.consume(code4);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code4);
      return data;
    }
  }
  var content;
  var init_content = __esm({
    "node_modules/micromark/lib/initialize/content.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      content = {
        tokenize: initializeContent
      };
    }
  });

  // node_modules/micromark/lib/initialize/document.js
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start;
    function start(code4) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code4);
      }
      return checkNewContainers(code4);
    }
    function documentContinue(code4) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point4;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point4
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
        return checkNewContainers(code4);
      }
      return start(code4);
    }
    function checkNewContainers(code4) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code4);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code4);
        }
        self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
      }
      self2.containerState = {};
      return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code4);
    }
    function thereIsANewContainer(code4) {
      if (childFlow) closeFlow();
      exitContainers(continued);
      return documentContinued(code4);
    }
    function thereIsNoNewContainer(code4) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code4);
    }
    function documentContinued(code4) {
      self2.containerState = {};
      return effects.attempt(containerConstruct, containerContinue, flowStart)(code4);
    }
    function containerContinue(code4) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code4);
    }
    function flowStart(code4) {
      if (code4 === null) {
        if (childFlow) closeFlow();
        exitContainers(0);
        effects.consume(code4);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        _tokenizer: childFlow,
        contentType: "flow",
        previous: childToken
      });
      return flowContinue(code4);
    }
    function flowContinue(code4) {
      if (code4 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code4);
        return;
      }
      if (markdownLineEnding(code4)) {
        effects.consume(code4);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start;
      }
      effects.consume(code4);
      return flowContinue;
    }
    function writeToChild(token, endOfFile) {
      const stream = self2.sliceStream(token);
      if (endOfFile) stream.push(null);
      token.previous = childToken;
      if (childToken) childToken.next = token;
      childToken = token;
      childFlow.defineSkip(token.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token.start.line]) {
        let index2 = childFlow.events.length;
        while (index2--) {
          if (
            // The token starts before the line endingâ€¦
            childFlow.events[index2][1].start.offset < lineStartOffset && // â€¦and either is not ended yetâ€¦
            (!childFlow.events[index2][1].end || // â€¦or ends after it.
            childFlow.events[index2][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point4;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point4 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index2 = indexBeforeExits;
        while (index2 < self2.events.length) {
          self2.events[index2][1].end = {
            ...point4
          };
          index2++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index2;
      }
    }
    function exitContainers(size) {
      let index2 = stack.length;
      while (index2-- > size) {
        const entry = stack[index2];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok3, nok) {
    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  var document2, containerConstruct;
  var init_document = __esm({
    "node_modules/micromark/lib/initialize/document.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_chunked();
      document2 = {
        tokenize: initializeDocument
      };
      containerConstruct = {
        tokenize: tokenizeContainer
      };
    }
  });

  // node_modules/micromark-util-classify-character/index.js
  function classifyCharacter(code4) {
    if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return 1;
    }
    if (unicodePunctuation(code4)) {
      return 2;
    }
  }
  var init_micromark_util_classify_character = __esm({
    "node_modules/micromark-util-classify-character/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-util-resolve-all/index.js
  function resolveAll(constructs2, events, context) {
    const called = [];
    let index2 = -1;
    while (++index2 < constructs2.length) {
      const resolve = constructs2[index2].resolveAll;
      if (resolve && !called.includes(resolve)) {
        events = resolve(events, context);
        called.push(resolve);
      }
    }
    return events;
  }
  var init_micromark_util_resolve_all = __esm({
    "node_modules/micromark-util-resolve-all/index.js"() {
    }
  });

  // node_modules/micromark-core-commonmark/lib/attention.js
  function resolveAllAttention(events, context) {
    let index2 = -1;
    let open2;
    let group;
    let text10;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
        open2 = index2;
        while (open2--) {
          if (events[open2][0] === "exit" && events[open2][1].type === "attentionSequence" && events[open2][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open2][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
            if ((events[open2][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open2][1].end.offset - events[open2][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
              continue;
            }
            use = events[open2][1].end.offset - events[open2][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
            const start = {
              ...events[open2][1].end
            };
            const end = {
              ...events[index2][1].start
            };
            movePoint(start, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start,
              end: {
                ...events[open2][1].end
              }
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...events[index2][1].start
              },
              end
            };
            text10 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: {
                ...events[open2][1].end
              },
              end: {
                ...events[index2][1].start
              }
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: {
                ...openingSequence.start
              },
              end: {
                ...closingSequence.end
              }
            };
            events[open2][1].end = {
              ...openingSequence.start
            };
            events[index2][1].start = {
              ...closingSequence.end
            };
            nextEvents = [];
            if (events[open2][1].end.offset - events[open2][1].start.offset) {
              nextEvents = push(nextEvents, [["enter", events[open2][1], context], ["exit", events[open2][1], context]]);
            }
            nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text10, context]]);
            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open2 + 1, index2), context));
            nextEvents = push(nextEvents, [["exit", text10, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
            if (events[index2][1].end.offset - events[index2][1].start.offset) {
              offset = 2;
              nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
            } else {
              offset = 0;
            }
            splice(events, open2 - 1, index2 - open2 + 3, nextEvents);
            index2 = open2 + nextEvents.length - offset - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "attentionSequence") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok3) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous4 = this.previous;
    const before = classifyCharacter(previous4);
    let marker;
    return start;
    function start(code4) {
      marker = code4;
      effects.enter("attentionSequence");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker) {
        effects.consume(code4);
        return inside;
      }
      const token = effects.exit("attentionSequence");
      const after = classifyCharacter(code4);
      const open2 = !after || after === 2 && before || attentionMarkers2.includes(code4);
      const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous4);
      token._open = Boolean(marker === 42 ? open2 : open2 && (before || !close2));
      token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open2));
      return ok3(code4);
    }
  }
  function movePoint(point4, offset) {
    point4.column += offset;
    point4.offset += offset;
    point4._bufferIndex += offset;
  }
  var attention;
  var init_attention = __esm({
    "node_modules/micromark-core-commonmark/lib/attention.js"() {
      init_micromark_util_chunked();
      init_micromark_util_classify_character();
      init_micromark_util_resolve_all();
      attention = {
        name: "attention",
        resolveAll: resolveAllAttention,
        tokenize: tokenizeAttention
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/autolink.js
  function tokenizeAutolink(effects, ok3, nok) {
    let size = 0;
    return start;
    function start(code4) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code4);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open2;
    }
    function open2(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return schemeOrEmailAtext;
      }
      if (code4 === 64) {
        return nok(code4);
      }
      return emailAtext(code4);
    }
    function schemeOrEmailAtext(code4) {
      if (code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) {
        size = 1;
        return schemeInsideOrEmailAtext(code4);
      }
      return emailAtext(code4);
    }
    function schemeInsideOrEmailAtext(code4) {
      if (code4 === 58) {
        effects.consume(code4);
        size = 0;
        return urlInside;
      }
      if ((code4 === 43 || code4 === 45 || code4 === 46 || asciiAlphanumeric(code4)) && size++ < 32) {
        effects.consume(code4);
        return schemeInsideOrEmailAtext;
      }
      size = 0;
      return emailAtext(code4);
    }
    function urlInside(code4) {
      if (code4 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code4);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      if (code4 === null || code4 === 32 || code4 === 60 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return urlInside;
    }
    function emailAtext(code4) {
      if (code4 === 64) {
        effects.consume(code4);
        return emailAtSignOrDot;
      }
      if (asciiAtext(code4)) {
        effects.consume(code4);
        return emailAtext;
      }
      return nok(code4);
    }
    function emailAtSignOrDot(code4) {
      return asciiAlphanumeric(code4) ? emailLabel(code4) : nok(code4);
    }
    function emailLabel(code4) {
      if (code4 === 46) {
        effects.consume(code4);
        size = 0;
        return emailAtSignOrDot;
      }
      if (code4 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code4);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      return emailValue(code4);
    }
    function emailValue(code4) {
      if ((code4 === 45 || asciiAlphanumeric(code4)) && size++ < 63) {
        const next = code4 === 45 ? emailValue : emailLabel;
        effects.consume(code4);
        return next;
      }
      return nok(code4);
    }
  }
  var autolink;
  var init_autolink = __esm({
    "node_modules/micromark-core-commonmark/lib/autolink.js"() {
      init_micromark_util_character();
      autolink = {
        name: "autolink",
        tokenize: tokenizeAutolink
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/blank-line.js
  function tokenizeBlankLine(effects, ok3, nok) {
    return start;
    function start(code4) {
      return markdownSpace(code4) ? factorySpace(effects, after, "linePrefix")(code4) : after(code4);
    }
    function after(code4) {
      return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }
  var blankLine;
  var init_blank_line = __esm({
    "node_modules/micromark-core-commonmark/lib/blank-line.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      blankLine = {
        partial: true,
        tokenize: tokenizeBlankLine
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/block-quote.js
  function tokenizeBlockQuoteStart(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      if (code4 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code4);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      if (markdownSpace(code4)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code4);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok3;
      }
      effects.exit("blockQuotePrefix");
      return ok3(code4);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
    const self2 = this;
    return contStart;
    function contStart(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
      }
      return contBefore(code4);
    }
    function contBefore(code4) {
      return effects.attempt(blockQuote, ok3, nok)(code4);
    }
  }
  function exit(effects) {
    effects.exit("blockQuote");
  }
  var blockQuote;
  var init_block_quote = __esm({
    "node_modules/micromark-core-commonmark/lib/block-quote.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      blockQuote = {
        continuation: {
          tokenize: tokenizeBlockQuoteContinuation
        },
        exit,
        name: "blockQuote",
        tokenize: tokenizeBlockQuoteStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/character-escape.js
  function tokenizeCharacterEscape(effects, ok3, nok) {
    return start;
    function start(code4) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code4);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code4) {
      if (asciiPunctuation(code4)) {
        effects.enter("characterEscapeValue");
        effects.consume(code4);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok3;
      }
      return nok(code4);
    }
  }
  var characterEscape;
  var init_character_escape = __esm({
    "node_modules/micromark-core-commonmark/lib/character-escape.js"() {
      init_micromark_util_character();
      characterEscape = {
        name: "characterEscape",
        tokenize: tokenizeCharacterEscape
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/character-reference.js
  function tokenizeCharacterReference(effects, ok3, nok) {
    const self2 = this;
    let size = 0;
    let max;
    let test;
    return start;
    function start(code4) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code4);
      effects.exit("characterReferenceMarker");
      return open2;
    }
    function open2(code4) {
      if (code4 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code4);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric;
      }
      effects.enter("characterReferenceValue");
      max = 31;
      test = asciiAlphanumeric;
      return value(code4);
    }
    function numeric(code4) {
      if (code4 === 88 || code4 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code4);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max = 6;
        test = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max = 7;
      test = asciiDigit;
      return value(code4);
    }
    function value(code4) {
      if (code4 === 59 && size) {
        const token = effects.exit("characterReferenceValue");
        if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
          return nok(code4);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code4);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok3;
      }
      if (test(code4) && size++ < max) {
        effects.consume(code4);
        return value;
      }
      return nok(code4);
    }
  }
  var characterReference;
  var init_character_reference = __esm({
    "node_modules/micromark-core-commonmark/lib/character-reference.js"() {
      init_index_dom();
      init_micromark_util_character();
      characterReference = {
        name: "characterReference",
        tokenize: tokenizeCharacterReference
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-fenced.js
  function tokenizeCodeFenced(effects, ok3, nok) {
    const self2 = this;
    const closeStart = {
      partial: true,
      tokenize: tokenizeCloseStart
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker;
    return start;
    function start(code4) {
      return beforeSequenceOpen(code4);
    }
    function beforeSequenceOpen(code4) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker = code4;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === marker) {
        sizeOpen++;
        effects.consume(code4);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code4);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace(code4) ? factorySpace(effects, infoBefore, "whitespace")(code4) : infoBefore(code4);
    }
    function infoBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok3(code4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code4);
    }
    function info(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, metaBefore, "whitespace")(code4);
      }
      if (code4 === 96 && code4 === marker) {
        return nok(code4);
      }
      effects.consume(code4);
      return info;
    }
    function metaBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return infoBefore(code4);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta(code4);
    }
    function meta(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code4);
      }
      if (code4 === 96 && code4 === marker) {
        return nok(code4);
      }
      effects.consume(code4);
      return meta;
    }
    function atNonLazyBreak(code4) {
      return effects.attempt(closeStart, after, contentBefore)(code4);
    }
    function contentBefore(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code4) {
      return initialPrefix > 0 && markdownSpace(code4) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code4) : beforeContentChunk(code4);
    }
    function beforeContentChunk(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code4);
    }
    function contentChunk(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code4);
      }
      effects.consume(code4);
      return contentChunk;
    }
    function after(code4) {
      effects.exit("codeFenced");
      return ok3(code4);
    }
    function tokenizeCloseStart(effects2, ok4, nok2) {
      let size = 0;
      return startBefore;
      function startBefore(code4) {
        effects2.enter("lineEnding");
        effects2.consume(code4);
        effects2.exit("lineEnding");
        return start2;
      }
      function start2(code4) {
        effects2.enter("codeFencedFence");
        return markdownSpace(code4) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : beforeSequenceClose(code4);
      }
      function beforeSequenceClose(code4) {
        if (code4 === marker) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code4);
        }
        return nok2(code4);
      }
      function sequenceClose(code4) {
        if (code4 === marker) {
          size++;
          effects2.consume(code4);
          return sequenceClose;
        }
        if (size >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace(code4) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code4) : sequenceCloseAfter(code4);
        }
        return nok2(code4);
      }
      function sequenceCloseAfter(code4) {
        if (code4 === null || markdownLineEnding(code4)) {
          effects2.exit("codeFencedFence");
          return ok4(code4);
        }
        return nok2(code4);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code4) {
      return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
    }
  }
  var nonLazyContinuation, codeFenced;
  var init_code_fenced = __esm({
    "node_modules/micromark-core-commonmark/lib/code-fenced.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      nonLazyContinuation = {
        partial: true,
        tokenize: tokenizeNonLazyContinuation
      };
      codeFenced = {
        concrete: true,
        name: "codeFenced",
        tokenize: tokenizeCodeFenced
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-indented.js
  function tokenizeCodeIndented(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      effects.enter("codeIndented");
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
    }
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code4) : nok(code4);
    }
    function atBreak(code4) {
      if (code4 === null) {
        return after(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.attempt(furtherStart, atBreak, after)(code4);
      }
      effects.enter("codeFlowValue");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("codeFlowValue");
        return atBreak(code4);
      }
      effects.consume(code4);
      return inside;
    }
    function after(code4) {
      effects.exit("codeIndented");
      return ok3(code4);
    }
  }
  function tokenizeFurtherStart(effects, ok3, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code4) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code4);
    }
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code4) : markdownLineEnding(code4) ? furtherStart2(code4) : nok(code4);
    }
  }
  var codeIndented, furtherStart;
  var init_code_indented = __esm({
    "node_modules/micromark-core-commonmark/lib/code-indented.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      codeIndented = {
        name: "codeIndented",
        tokenize: tokenizeCodeIndented
      };
      furtherStart = {
        partial: true,
        tokenize: tokenizeFurtherStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-text.js
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index2;
    let enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index2 = headEnterIndex;
      while (++index2 < tailExitIndex) {
        if (events[index2][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index2 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index2 <= tailExitIndex) {
      if (enter === void 0) {
        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
          enter = index2;
        }
      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
        events[enter][1].type = "codeTextData";
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          tailExitIndex -= index2 - enter - 2;
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return events;
  }
  function previous(code4) {
    return code4 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok3, nok) {
    const self2 = this;
    let sizeOpen = 0;
    let size;
    let token;
    return start;
    function start(code4) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === 96) {
        effects.consume(code4);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between(code4);
    }
    function between(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 32) {
        effects.enter("space");
        effects.consume(code4);
        effects.exit("space");
        return between;
      }
      if (code4 === 96) {
        token = effects.enter("codeTextSequence");
        size = 0;
        return sequenceClose(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return between;
      }
      effects.enter("codeTextData");
      return data(code4);
    }
    function data(code4) {
      if (code4 === null || code4 === 32 || code4 === 96 || markdownLineEnding(code4)) {
        effects.exit("codeTextData");
        return between(code4);
      }
      effects.consume(code4);
      return data;
    }
    function sequenceClose(code4) {
      if (code4 === 96) {
        effects.consume(code4);
        size++;
        return sequenceClose;
      }
      if (size === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok3(code4);
      }
      token.type = "codeTextData";
      return data(code4);
    }
  }
  var codeText;
  var init_code_text = __esm({
    "node_modules/micromark-core-commonmark/lib/code-text.js"() {
      init_micromark_util_character();
      codeText = {
        name: "codeText",
        previous,
        resolve: resolveCodeText,
        tokenize: tokenizeCodeText
      };
    }
  });

  // node_modules/micromark-util-subtokenize/lib/splice-buffer.js
  function chunkedPush(list4, right) {
    let chunkStart = 0;
    if (right.length < 1e4) {
      list4.push(...right);
    } else {
      while (chunkStart < right.length) {
        list4.push(...right.slice(chunkStart, chunkStart + 1e4));
        chunkStart += 1e4;
      }
    }
  }
  var SpliceBuffer;
  var init_splice_buffer = __esm({
    "node_modules/micromark-util-subtokenize/lib/splice-buffer.js"() {
      SpliceBuffer = class {
        /**
         * @param {ReadonlyArray<T> | null | undefined} [initial]
         *   Initial items (optional).
         * @returns
         *   Splice buffer.
         */
        constructor(initial) {
          this.left = initial ? [...initial] : [];
          this.right = [];
        }
        /**
         * Array access;
         * does not move the cursor.
         *
         * @param {number} index
         *   Index.
         * @return {T}
         *   Item.
         */
        get(index2) {
          if (index2 < 0 || index2 >= this.left.length + this.right.length) {
            throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
          }
          if (index2 < this.left.length) return this.left[index2];
          return this.right[this.right.length - index2 + this.left.length - 1];
        }
        /**
         * The length of the splice buffer, one greater than the largest index in the
         * array.
         */
        get length() {
          return this.left.length + this.right.length;
        }
        /**
         * Remove and return `list[0]`;
         * moves the cursor to `0`.
         *
         * @returns {T | undefined}
         *   Item, optional.
         */
        shift() {
          this.setCursor(0);
          return this.right.pop();
        }
        /**
         * Slice the buffer to get an array;
         * does not move the cursor.
         *
         * @param {number} start
         *   Start.
         * @param {number | null | undefined} [end]
         *   End (optional).
         * @returns {Array<T>}
         *   Array of items.
         */
        slice(start, end) {
          const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
          if (stop < this.left.length) {
            return this.left.slice(start, stop);
          }
          if (start > this.left.length) {
            return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
          }
          return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
        }
        /**
         * Mimics the behavior of Array.prototype.splice() except for the change of
         * interface necessary to avoid segfaults when patching in very large arrays.
         *
         * This operation moves cursor is moved to `start` and results in the cursor
         * placed after any inserted items.
         *
         * @param {number} start
         *   Start;
         *   zero-based index at which to start changing the array;
         *   negative numbers count backwards from the end of the array and values
         *   that are out-of bounds are clamped to the appropriate end of the array.
         * @param {number | null | undefined} [deleteCount=0]
         *   Delete count (default: `0`);
         *   maximum number of elements to delete, starting from start.
         * @param {Array<T> | null | undefined} [items=[]]
         *   Items to include in place of the deleted items (default: `[]`).
         * @return {Array<T>}
         *   Any removed items.
         */
        splice(start, deleteCount, items) {
          const count = deleteCount || 0;
          this.setCursor(Math.trunc(start));
          const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
          if (items) chunkedPush(this.left, items);
          return removed.reverse();
        }
        /**
         * Remove and return the highest-numbered item in the array, so
         * `list[list.length - 1]`;
         * Moves the cursor to `length`.
         *
         * @returns {T | undefined}
         *   Item, optional.
         */
        pop() {
          this.setCursor(Number.POSITIVE_INFINITY);
          return this.left.pop();
        }
        /**
         * Inserts a single item to the high-numbered side of the array;
         * moves the cursor to `length`.
         *
         * @param {T} item
         *   Item.
         * @returns {undefined}
         *   Nothing.
         */
        push(item) {
          this.setCursor(Number.POSITIVE_INFINITY);
          this.left.push(item);
        }
        /**
         * Inserts many items to the high-numbered side of the array.
         * Moves the cursor to `length`.
         *
         * @param {Array<T>} items
         *   Items.
         * @returns {undefined}
         *   Nothing.
         */
        pushMany(items) {
          this.setCursor(Number.POSITIVE_INFINITY);
          chunkedPush(this.left, items);
        }
        /**
         * Inserts a single item to the low-numbered side of the array;
         * Moves the cursor to `0`.
         *
         * @param {T} item
         *   Item.
         * @returns {undefined}
         *   Nothing.
         */
        unshift(item) {
          this.setCursor(0);
          this.right.push(item);
        }
        /**
         * Inserts many items to the low-numbered side of the array;
         * moves the cursor to `0`.
         *
         * @param {Array<T>} items
         *   Items.
         * @returns {undefined}
         *   Nothing.
         */
        unshiftMany(items) {
          this.setCursor(0);
          chunkedPush(this.right, items.reverse());
        }
        /**
         * Move the cursor to a specific position in the array. Requires
         * time proportional to the distance moved.
         *
         * If `n < 0`, the cursor will end up at the beginning.
         * If `n > length`, the cursor will end up at the end.
         *
         * @param {number} n
         *   Position.
         * @return {undefined}
         *   Nothing.
         */
        setCursor(n) {
          if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;
          if (n < this.left.length) {
            const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
            chunkedPush(this.right, removed.reverse());
          } else {
            const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
            chunkedPush(this.left, removed.reverse());
          }
        }
      };
    }
  });

  // node_modules/micromark-util-subtokenize/index.js
  function subtokenize(eventsArray) {
    const jumps = {};
    let index2 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    const events = new SpliceBuffer(eventsArray);
    while (++index2 < events.length) {
      while (index2 in jumps) {
        index2 = jumps[index2];
      }
      event = events.get(index2);
      if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index2));
          index2 = jumps[index2];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index2;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events.get(otherIndex);
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events.get(lineIndex)[1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") {
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = {
            ...events.get(lineIndex)[1].start
          };
          parameters = events.slice(lineIndex, index2);
          parameters.unshift(event);
          events.splice(lineIndex, index2 - lineIndex + 1, parameters);
        }
      }
    }
    splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token = events.get(eventIndex)[1];
    const context = events.get(eventIndex)[2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    let tokenizer = token._tokenizer;
    if (!tokenizer) {
      tokenizer = context.parser[token.contentType](token.start);
      if (token._contentTypeTextTrailing) {
        tokenizer._contentTypeTextTrailing = true;
      }
    }
    const childEvents = tokenizer.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous4;
    let index2 = -1;
    let current = token;
    let adjust = 0;
    let start = 0;
    const breaks = [start];
    while (current) {
      while (events.get(++startPosition)[1] !== current) {
      }
      startPositions.push(startPosition);
      if (!current._tokenizer) {
        stream = context.sliceStream(current);
        if (!current.next) {
          stream.push(null);
        }
        if (previous4) {
          tokenizer.defineSkip(current.start);
        }
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer.write(stream);
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous4 = current;
      current = current.next;
    }
    current = token;
    while (++index2 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
      ) {
        start = index2 + 1;
        breaks.push(start);
        current._tokenizer = void 0;
        current.previous = void 0;
        current = current.next;
      }
    }
    tokenizer.events = [];
    if (current) {
      current._tokenizer = void 0;
      current.previous = void 0;
    } else {
      breaks.pop();
    }
    index2 = breaks.length;
    while (index2--) {
      const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
      const start2 = startPositions.pop();
      jumps.push([start2, start2 + slice.length - 1]);
      events.splice(start2, 2, slice);
    }
    jumps.reverse();
    index2 = -1;
    while (++index2 < jumps.length) {
      gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
      adjust += jumps[index2][1] - jumps[index2][0] - 1;
    }
    return gaps;
  }
  var init_micromark_util_subtokenize = __esm({
    "node_modules/micromark-util-subtokenize/index.js"() {
      init_micromark_util_chunked();
      init_splice_buffer();
    }
  });

  // node_modules/micromark-core-commonmark/lib/content.js
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok3) {
    let previous4;
    return chunkStart;
    function chunkStart(code4) {
      effects.enter("content");
      previous4 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code4);
    }
    function chunkInside(code4) {
      if (code4 === null) {
        return contentEnd(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code4);
      }
      effects.consume(code4);
      return chunkInside;
    }
    function contentEnd(code4) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok3(code4);
    }
    function contentContinue(code4) {
      effects.consume(code4);
      effects.exit("chunkContent");
      previous4.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous4
      });
      previous4 = previous4.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok3, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code4) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return nok(code4);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok3(code4);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code4);
    }
  }
  var content2, continuationConstruct;
  var init_content2 = __esm({
    "node_modules/micromark-core-commonmark/lib/content.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_subtokenize();
      content2 = {
        resolve: resolveContent,
        tokenize: tokenizeContent
      };
      continuationConstruct = {
        partial: true,
        tokenize: tokenizeContinuation
      };
    }
  });

  // node_modules/micromark-factory-destination/index.js
  function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
    const limit = max || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start;
    function start(code4) {
      if (code4 === 60) {
        effects.enter(type);
        effects.enter(literalType);
        effects.enter(literalMarkerType);
        effects.consume(code4);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code4 === null || code4 === 32 || code4 === 41 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw2(code4);
    }
    function enclosedBefore(code4) {
      if (code4 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code4);
        effects.exit(literalMarkerType);
        effects.exit(literalType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code4);
    }
    function enclosed(code4) {
      if (code4 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType);
        return enclosedBefore(code4);
      }
      if (code4 === null || code4 === 60 || markdownLineEnding(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code4) {
      if (code4 === 60 || code4 === 62 || code4 === 92) {
        effects.consume(code4);
        return enclosed;
      }
      return enclosed(code4);
    }
    function raw2(code4) {
      if (!balance && (code4 === null || code4 === 41 || markdownLineEndingOrSpace(code4))) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok3(code4);
      }
      if (balance < limit && code4 === 40) {
        effects.consume(code4);
        balance++;
        return raw2;
      }
      if (code4 === 41) {
        effects.consume(code4);
        balance--;
        return raw2;
      }
      if (code4 === null || code4 === 32 || code4 === 40 || asciiControl(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? rawEscape : raw2;
    }
    function rawEscape(code4) {
      if (code4 === 40 || code4 === 41 || code4 === 92) {
        effects.consume(code4);
        return raw2;
      }
      return raw2(code4);
    }
  }
  var init_micromark_factory_destination = __esm({
    "node_modules/micromark-factory-destination/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-label/index.js
  function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
    const self2 = this;
    let size = 0;
    let seen;
    return start;
    function start(code4) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.enter(stringType);
      return atBreak;
    }
    function atBreak(code4) {
      if (size > 999 || code4 === null || code4 === 91 || code4 === 93 && !seen || // To do: remove in the future once weâ€™ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnâ€™t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code4 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit(stringType);
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code4);
    }
    function labelInside(code4) {
      if (code4 === null || code4 === 91 || code4 === 93 || markdownLineEnding(code4) || size++ > 999) {
        effects.exit("chunkString");
        return atBreak(code4);
      }
      effects.consume(code4);
      if (!seen) seen = !markdownSpace(code4);
      return code4 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size++;
        return labelInside;
      }
      return labelInside(code4);
    }
  }
  var init_micromark_factory_label = __esm({
    "node_modules/micromark-factory-label/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-title/index.js
  function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
    let marker;
    return start;
    function start(code4) {
      if (code4 === 34 || code4 === 39 || code4 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        marker = code4 === 40 ? 41 : code4;
        return begin;
      }
      return nok(code4);
    }
    function begin(code4) {
      if (code4 === marker) {
        effects.enter(markerType);
        effects.consume(code4);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      return atBreak(code4);
    }
    function atBreak(code4) {
      if (code4 === marker) {
        effects.exit(stringType);
        return begin(marker);
      }
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return factorySpace(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker || code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        return atBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? escape2 : inside;
    }
    function escape2(code4) {
      if (code4 === marker || code4 === 92) {
        effects.consume(code4);
        return inside;
      }
      return inside(code4);
    }
  }
  var init_micromark_factory_title = __esm({
    "node_modules/micromark-factory-title/index.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-whitespace/index.js
  function factoryWhitespace(effects, ok3) {
    let seen;
    return start;
    function start(code4) {
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        seen = true;
        return start;
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code4);
      }
      return ok3(code4);
    }
  }
  var init_micromark_factory_whitespace = __esm({
    "node_modules/micromark-factory-whitespace/index.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-core-commonmark/lib/definition.js
  function tokenizeDefinition(effects, ok3, nok) {
    const self2 = this;
    let identifier;
    return start;
    function start(code4) {
      effects.enter("definition");
      return before(code4);
    }
    function before(code4) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we donâ€™t need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code4);
    }
    function labelAfter(code4) {
      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code4 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code4);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code4);
    }
    function markerAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, destinationBefore)(code4) : destinationBefore(code4);
    }
    function destinationBefore(code4) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we donâ€™t need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code4);
    }
    function destinationAfter(code4) {
      return effects.attempt(titleBefore, after, after)(code4);
    }
    function after(code4) {
      return markdownSpace(code4) ? factorySpace(effects, afterWhitespace, "whitespace")(code4) : afterWhitespace(code4);
    }
    function afterWhitespace(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier);
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  function tokenizeTitleBefore(effects, ok3, nok) {
    return titleBefore2;
    function titleBefore2(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, beforeMarker)(code4) : nok(code4);
    }
    function beforeMarker(code4) {
      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code4);
    }
    function titleAfter(code4) {
      return markdownSpace(code4) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code4) : titleAfterOptionalWhitespace(code4);
    }
    function titleAfterOptionalWhitespace(code4) {
      return code4 === null || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
    }
  }
  var definition, titleBefore;
  var init_definition = __esm({
    "node_modules/micromark-core-commonmark/lib/definition.js"() {
      init_micromark_factory_destination();
      init_micromark_factory_label();
      init_micromark_factory_space();
      init_micromark_factory_title();
      init_micromark_factory_whitespace();
      init_micromark_util_character();
      init_micromark_util_normalize_identifier();
      definition = {
        name: "definition",
        tokenize: tokenizeDefinition
      };
      titleBefore = {
        partial: true,
        tokenize: tokenizeTitleBefore
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/hard-break-escape.js
  function tokenizeHardBreakEscape(effects, ok3, nok) {
    return start;
    function start(code4) {
      effects.enter("hardBreakEscape");
      effects.consume(code4);
      return after;
    }
    function after(code4) {
      if (markdownLineEnding(code4)) {
        effects.exit("hardBreakEscape");
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  var hardBreakEscape;
  var init_hard_break_escape = __esm({
    "node_modules/micromark-core-commonmark/lib/hard-break-escape.js"() {
      init_micromark_util_character();
      hardBreakEscape = {
        name: "hardBreakEscape",
        tokenize: tokenizeHardBreakEscape
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/heading-atx.js
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content3;
    let text10;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content3 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text10 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text10, context], ["exit", text10, context], ["exit", content3, context]]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok3, nok) {
    let size = 0;
    return start;
    function start(code4) {
      effects.enter("atxHeading");
      return before(code4);
    }
    function before(code4) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === 35 && size++ < 6) {
        effects.consume(code4);
        return sequenceOpen;
      }
      if (code4 === null || markdownLineEndingOrSpace(code4)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code4);
      }
      return nok(code4);
    }
    function atBreak(code4) {
      if (code4 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("atxHeading");
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, atBreak, "whitespace")(code4);
      }
      effects.enter("atxHeadingText");
      return data(code4);
    }
    function sequenceFurther(code4) {
      if (code4 === 35) {
        effects.consume(code4);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code4);
    }
    function data(code4) {
      if (code4 === null || code4 === 35 || markdownLineEndingOrSpace(code4)) {
        effects.exit("atxHeadingText");
        return atBreak(code4);
      }
      effects.consume(code4);
      return data;
    }
  }
  var headingAtx;
  var init_heading_atx = __esm({
    "node_modules/micromark-core-commonmark/lib/heading-atx.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_chunked();
      headingAtx = {
        name: "headingAtx",
        resolve: resolveHeadingAtx,
        tokenize: tokenizeHeadingAtx
      };
    }
  });

  // node_modules/micromark-util-html-tag-name/index.js
  var htmlBlockNames, htmlRawNames;
  var init_micromark_util_html_tag_name = __esm({
    "node_modules/micromark-util-html-tag-name/index.js"() {
      htmlBlockNames = [
        "address",
        "article",
        "aside",
        "base",
        "basefont",
        "blockquote",
        "body",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hr",
        "html",
        "iframe",
        "legend",
        "li",
        "link",
        "main",
        "menu",
        "menuitem",
        "nav",
        "noframes",
        "ol",
        "optgroup",
        "option",
        "p",
        "param",
        "search",
        "section",
        "summary",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "track",
        "ul"
      ];
      htmlRawNames = ["pre", "script", "style", "textarea"];
    }
  });

  // node_modules/micromark-core-commonmark/lib/html-flow.js
  function resolveToHtmlFlow(events) {
    let index2 = events.length;
    while (index2--) {
      if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
        break;
      }
    }
    if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
      events[index2][1].start = events[index2 - 2][1].start;
      events[index2 + 1][1].start = events[index2 - 2][1].start;
      events.splice(index2 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let closingTag;
    let buffer;
    let index2;
    let markerB;
    return start;
    function start(code4) {
      return before(code4);
    }
    function before(code4) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code4);
      return open2;
    }
    function open2(code4) {
      if (code4 === 33) {
        effects.consume(code4);
        return declarationOpen;
      }
      if (code4 === 47) {
        effects.consume(code4);
        closingTag = true;
        return tagCloseStart;
      }
      if (code4 === 63) {
        effects.consume(code4);
        marker = 3;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        buffer = String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function declarationOpen(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        marker = 2;
        return commentOpenInside;
      }
      if (code4 === 91) {
        effects.consume(code4);
        marker = 5;
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        marker = 4;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code4);
    }
    function commentOpenInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code4);
    }
    function cdataOpenInside(code4) {
      const value = "CDATA[";
      if (code4 === value.charCodeAt(index2++)) {
        effects.consume(code4);
        if (index2 === value.length) {
          return self2.interrupt ? ok3 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code4);
    }
    function tagCloseStart(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        buffer = String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function tagName(code4) {
      if (code4 === null || code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        const slash = code4 === 47;
        const name = buffer.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name)) {
          marker = 1;
          return self2.interrupt ? ok3(code4) : continuation(code4);
        }
        if (htmlBlockNames.includes(buffer.toLowerCase())) {
          marker = 6;
          if (slash) {
            effects.consume(code4);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok3(code4) : continuation(code4);
        }
        marker = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code4) : closingTag ? completeClosingTagAfter(code4) : completeAttributeNameBefore(code4);
      }
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        buffer += String.fromCharCode(code4);
        return tagName;
      }
      return nok(code4);
    }
    function basicSelfClosing(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return self2.interrupt ? ok3 : continuation;
      }
      return nok(code4);
    }
    function completeClosingTagAfter(code4) {
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeClosingTagAfter;
      }
      return completeEnd(code4);
    }
    function completeAttributeNameBefore(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        return completeEnd;
      }
      if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
        effects.consume(code4);
        return completeAttributeName;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeNameBefore;
      }
      return completeEnd(code4);
    }
    function completeAttributeName(code4) {
      if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code4);
    }
    function completeAttributeNameAfter(code4) {
      if (code4 === 61) {
        effects.consume(code4);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code4);
    }
    function completeAttributeValueBefore(code4) {
      if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 34 || code4 === 39) {
        effects.consume(code4);
        markerB = code4;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code4);
    }
    function completeAttributeValueQuoted(code4) {
      if (code4 === markerB) {
        effects.consume(code4);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code4 === null || markdownLineEnding(code4)) {
        return nok(code4);
      }
      effects.consume(code4);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code4) {
      if (code4 === null || code4 === 34 || code4 === 39 || code4 === 47 || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96 || markdownLineEndingOrSpace(code4)) {
        return completeAttributeNameAfter(code4);
      }
      effects.consume(code4);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code4) {
      if (code4 === 47 || code4 === 62 || markdownSpace(code4)) {
        return completeAttributeNameBefore(code4);
      }
      return nok(code4);
    }
    function completeEnd(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return completeAfter;
      }
      return nok(code4);
    }
    function completeAfter(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return continuation(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return completeAfter;
      }
      return nok(code4);
    }
    function continuation(code4) {
      if (code4 === 45 && marker === 2) {
        effects.consume(code4);
        return continuationCommentInside;
      }
      if (code4 === 60 && marker === 1) {
        effects.consume(code4);
        return continuationRawTagOpen;
      }
      if (code4 === 62 && marker === 4) {
        effects.consume(code4);
        return continuationClose;
      }
      if (code4 === 63 && marker === 3) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      if (code4 === 93 && marker === 5) {
        effects.consume(code4);
        return continuationCdataInside;
      }
      if (markdownLineEnding(code4) && (marker === 6 || marker === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(blankLineBefore, continuationAfter, continuationStart)(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("htmlFlowData");
        return continuationStart(code4);
      }
      effects.consume(code4);
      return continuation;
    }
    function continuationStart(code4) {
      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code4);
    }
    function continuationStartNonLazy(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return continuationStart(code4);
      }
      effects.enter("htmlFlowData");
      return continuation(code4);
    }
    function continuationCommentInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationRawTagOpen(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code4);
    }
    function continuationRawEndTag(code4) {
      if (code4 === 62) {
        const name = buffer.toLowerCase();
        if (htmlRawNames.includes(name)) {
          effects.consume(code4);
          return continuationClose;
        }
        return continuation(code4);
      }
      if (asciiAlpha(code4) && buffer.length < 8) {
        effects.consume(code4);
        buffer += String.fromCharCode(code4);
        return continuationRawEndTag;
      }
      return continuation(code4);
    }
    function continuationCdataInside(code4) {
      if (code4 === 93) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationDeclarationInside(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        return continuationClose;
      }
      if (code4 === 45 && marker === 2) {
        effects.consume(code4);
        return continuationDeclarationInside;
      }
      return continuation(code4);
    }
    function continuationClose(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code4);
      }
      effects.consume(code4);
      return continuationClose;
    }
    function continuationAfter(code4) {
      effects.exit("htmlFlow");
      return ok3(code4);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      if (markdownLineEnding(code4)) {
        effects.enter("lineEnding");
        effects.consume(code4);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
    }
  }
  function tokenizeBlankLineBefore(effects, ok3, nok) {
    return start;
    function start(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return effects.attempt(blankLine, ok3, nok);
    }
  }
  var htmlFlow, blankLineBefore, nonLazyContinuationStart;
  var init_html_flow = __esm({
    "node_modules/micromark-core-commonmark/lib/html-flow.js"() {
      init_micromark_util_character();
      init_micromark_util_html_tag_name();
      init_blank_line();
      htmlFlow = {
        concrete: true,
        name: "htmlFlow",
        resolveTo: resolveToHtmlFlow,
        tokenize: tokenizeHtmlFlow
      };
      blankLineBefore = {
        partial: true,
        tokenize: tokenizeBlankLineBefore
      };
      nonLazyContinuationStart = {
        partial: true,
        tokenize: tokenizeNonLazyContinuationStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/html-text.js
  function tokenizeHtmlText(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let index2;
    let returnState;
    return start;
    function start(code4) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code4);
      return open2;
    }
    function open2(code4) {
      if (code4 === 33) {
        effects.consume(code4);
        return declarationOpen;
      }
      if (code4 === 47) {
        effects.consume(code4);
        return tagCloseStart;
      }
      if (code4 === 63) {
        effects.consume(code4);
        return instruction;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return tagOpen;
      }
      return nok(code4);
    }
    function declarationOpen(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentOpenInside;
      }
      if (code4 === 91) {
        effects.consume(code4);
        index2 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return declaration;
      }
      return nok(code4);
    }
    function commentOpenInside(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentEnd;
      }
      return nok(code4);
    }
    function comment4(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 45) {
        effects.consume(code4);
        return commentClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = comment4;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return comment4;
    }
    function commentClose(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return commentEnd;
      }
      return comment4(code4);
    }
    function commentEnd(code4) {
      return code4 === 62 ? end(code4) : code4 === 45 ? commentClose(code4) : comment4(code4);
    }
    function cdataOpenInside(code4) {
      const value = "CDATA[";
      if (code4 === value.charCodeAt(index2++)) {
        effects.consume(code4);
        return index2 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code4);
    }
    function cdata(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.consume(code4);
        return cdataClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = cdata;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return cdata;
    }
    function cdataClose(code4) {
      if (code4 === 93) {
        effects.consume(code4);
        return cdataEnd;
      }
      return cdata(code4);
    }
    function cdataEnd(code4) {
      if (code4 === 62) {
        return end(code4);
      }
      if (code4 === 93) {
        effects.consume(code4);
        return cdataEnd;
      }
      return cdata(code4);
    }
    function declaration(code4) {
      if (code4 === null || code4 === 62) {
        return end(code4);
      }
      if (markdownLineEnding(code4)) {
        returnState = declaration;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return declaration;
    }
    function instruction(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (code4 === 63) {
        effects.consume(code4);
        return instructionClose;
      }
      if (markdownLineEnding(code4)) {
        returnState = instruction;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return instruction;
    }
    function instructionClose(code4) {
      return code4 === 62 ? end(code4) : instruction(code4);
    }
    function tagCloseStart(code4) {
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return tagClose;
      }
      return nok(code4);
    }
    function tagClose(code4) {
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagClose;
      }
      return tagCloseBetween(code4);
    }
    function tagCloseBetween(code4) {
      if (markdownLineEnding(code4)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagCloseBetween;
      }
      return end(code4);
    }
    function tagOpen(code4) {
      if (code4 === 45 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagOpen;
      }
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      return nok(code4);
    }
    function tagOpenBetween(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        return end;
      }
      if (code4 === 58 || code4 === 95 || asciiAlpha(code4)) {
        effects.consume(code4);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenBetween;
      }
      return end(code4);
    }
    function tagOpenAttributeName(code4) {
      if (code4 === 45 || code4 === 46 || code4 === 58 || code4 === 95 || asciiAlphanumeric(code4)) {
        effects.consume(code4);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code4);
    }
    function tagOpenAttributeNameAfter(code4) {
      if (code4 === 61) {
        effects.consume(code4);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code4);
    }
    function tagOpenAttributeValueBefore(code4) {
      if (code4 === null || code4 === 60 || code4 === 61 || code4 === 62 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 34 || code4 === 39) {
        effects.consume(code4);
        marker = code4;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code4);
      }
      if (markdownSpace(code4)) {
        effects.consume(code4);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code4);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code4) {
      if (code4 === marker) {
        effects.consume(code4);
        marker = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code4);
      }
      effects.consume(code4);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code4) {
      if (code4 === null || code4 === 34 || code4 === 39 || code4 === 60 || code4 === 61 || code4 === 96) {
        return nok(code4);
      }
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      effects.consume(code4);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code4) {
      if (code4 === 47 || code4 === 62 || markdownLineEndingOrSpace(code4)) {
        return tagOpenBetween(code4);
      }
      return nok(code4);
    }
    function end(code4) {
      if (code4 === 62) {
        effects.consume(code4);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok3;
      }
      return nok(code4);
    }
    function lineEndingBefore(code4) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code4) {
      return markdownSpace(code4) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4) : lineEndingAfterPrefix(code4);
    }
    function lineEndingAfterPrefix(code4) {
      effects.enter("htmlTextData");
      return returnState(code4);
    }
  }
  var htmlText;
  var init_html_text = __esm({
    "node_modules/micromark-core-commonmark/lib/html-text.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      htmlText = {
        name: "htmlText",
        tokenize: tokenizeHtmlText
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-end.js
  function resolveAllLabelEnd(events) {
    let index2 = -1;
    const newEvents = [];
    while (++index2 < events.length) {
      const token = events[index2][1];
      newEvents.push(events[index2]);
      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
        const offset = token.type === "labelImage" ? 4 : 2;
        token.type = "data";
        index2 += offset;
      }
    }
    if (events.length !== newEvents.length) {
      splice(events, 0, events.length, newEvents);
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index2 = events.length;
    let offset = 0;
    let token;
    let open2;
    let close2;
    let media;
    while (index2--) {
      token = events[index2][1];
      if (open2) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index2][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close2) {
        if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open2 = index2;
          if (token.type !== "labelLink") {
            offset = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close2 = index2;
      }
    }
    const group = {
      type: events[open2][1].type === "labelLink" ? "link" : "image",
      start: {
        ...events[open2][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    const label = {
      type: "label",
      start: {
        ...events[open2][1].start
      },
      end: {
        ...events[close2][1].end
      }
    };
    const text10 = {
      type: "labelText",
      start: {
        ...events[open2 + offset + 2][1].end
      },
      end: {
        ...events[close2 - 2][1].start
      }
    };
    media = [["enter", group, context], ["enter", label, context]];
    media = push(media, events.slice(open2 + 1, open2 + offset + 3));
    media = push(media, [["enter", text10, context]]);
    media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open2 + offset + 4, close2 - 3), context));
    media = push(media, [["exit", text10, context], events[close2 - 2], events[close2 - 1], ["exit", label, context]]);
    media = push(media, events.slice(close2 + 1));
    media = push(media, [["exit", group, context]]);
    splice(events, open2, events.length, media);
    return events;
  }
  function tokenizeLabelEnd(effects, ok3, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    let labelStart;
    let defined;
    while (index2--) {
      if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
        labelStart = self2.events[index2][1];
        break;
      }
    }
    return start;
    function start(code4) {
      if (!labelStart) {
        return nok(code4);
      }
      if (labelStart._inactive) {
        return labelEndNok(code4);
      }
      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })));
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code4);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code4) {
      if (code4 === 40) {
        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code4);
      }
      if (code4 === 91) {
        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code4);
      }
      return defined ? labelEndOk(code4) : labelEndNok(code4);
    }
    function referenceNotFull(code4) {
      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code4);
    }
    function labelEndOk(code4) {
      return ok3(code4);
    }
    function labelEndNok(code4) {
      labelStart._balanced = true;
      return nok(code4);
    }
  }
  function tokenizeResource(effects, ok3, nok) {
    return resourceStart;
    function resourceStart(code4) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code4);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceOpen)(code4) : resourceOpen(code4);
    }
    function resourceOpen(code4) {
      if (code4 === 41) {
        return resourceEnd(code4);
      }
      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code4);
    }
    function resourceDestinationAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceBetween)(code4) : resourceEnd(code4);
    }
    function resourceDestinationMissing(code4) {
      return nok(code4);
    }
    function resourceBetween(code4) {
      if (code4 === 34 || code4 === 39 || code4 === 40) {
        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code4);
      }
      return resourceEnd(code4);
    }
    function resourceTitleAfter(code4) {
      return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceEnd)(code4) : resourceEnd(code4);
    }
    function resourceEnd(code4) {
      if (code4 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code4);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok3;
      }
      return nok(code4);
    }
  }
  function tokenizeReferenceFull(effects, ok3, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code4) {
      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code4);
    }
    function referenceFullAfter(code4) {
      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code4) : nok(code4);
    }
    function referenceFullMissing(code4) {
      return nok(code4);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok3, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code4) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code4);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code4) {
      if (code4 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code4);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok3;
      }
      return nok(code4);
    }
  }
  var labelEnd, resourceConstruct, referenceFullConstruct, referenceCollapsedConstruct;
  var init_label_end = __esm({
    "node_modules/micromark-core-commonmark/lib/label-end.js"() {
      init_micromark_factory_destination();
      init_micromark_factory_label();
      init_micromark_factory_title();
      init_micromark_factory_whitespace();
      init_micromark_util_character();
      init_micromark_util_chunked();
      init_micromark_util_normalize_identifier();
      init_micromark_util_resolve_all();
      labelEnd = {
        name: "labelEnd",
        resolveAll: resolveAllLabelEnd,
        resolveTo: resolveToLabelEnd,
        tokenize: tokenizeLabelEnd
      };
      resourceConstruct = {
        tokenize: tokenizeResource
      };
      referenceFullConstruct = {
        tokenize: tokenizeReferenceFull
      };
      referenceCollapsedConstruct = {
        tokenize: tokenizeReferenceCollapsed
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-start-image.js
  function tokenizeLabelStartImage(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code4);
      effects.exit("labelImageMarker");
      return open2;
    }
    function open2(code4) {
      if (code4 === 91) {
        effects.enter("labelMarker");
        effects.consume(code4);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
    }
  }
  var labelStartImage;
  var init_label_start_image = __esm({
    "node_modules/micromark-core-commonmark/lib/label-start-image.js"() {
      init_label_end();
      labelStartImage = {
        name: "labelStartImage",
        resolveAll: labelEnd.resolveAll,
        tokenize: tokenizeLabelStartImage
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-start-link.js
  function tokenizeLabelStartLink(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code4);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code4) {
      return code4 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
    }
  }
  var labelStartLink;
  var init_label_start_link = __esm({
    "node_modules/micromark-core-commonmark/lib/label-start-link.js"() {
      init_label_end();
      labelStartLink = {
        name: "labelStartLink",
        resolveAll: labelEnd.resolveAll,
        tokenize: tokenizeLabelStartLink
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/line-ending.js
  function tokenizeLineEnding(effects, ok3) {
    return start;
    function start(code4) {
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return factorySpace(effects, ok3, "linePrefix");
    }
  }
  var lineEnding;
  var init_line_ending = __esm({
    "node_modules/micromark-core-commonmark/lib/line-ending.js"() {
      init_micromark_factory_space();
      lineEnding = {
        name: "lineEnding",
        tokenize: tokenizeLineEnding
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/thematic-break.js
  function tokenizeThematicBreak(effects, ok3, nok) {
    let size = 0;
    let marker;
    return start;
    function start(code4) {
      effects.enter("thematicBreak");
      return before(code4);
    }
    function before(code4) {
      marker = code4;
      return atBreak(code4);
    }
    function atBreak(code4) {
      if (code4 === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code4);
      }
      if (size >= 3 && (code4 === null || markdownLineEnding(code4))) {
        effects.exit("thematicBreak");
        return ok3(code4);
      }
      return nok(code4);
    }
    function sequence(code4) {
      if (code4 === marker) {
        effects.consume(code4);
        size++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace(code4) ? factorySpace(effects, atBreak, "whitespace")(code4) : atBreak(code4);
    }
  }
  var thematicBreak;
  var init_thematic_break = __esm({
    "node_modules/micromark-core-commonmark/lib/thematic-break.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      thematicBreak = {
        name: "thematicBreak",
        tokenize: tokenizeThematicBreak
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/list.js
  function tokenizeListStart(effects, ok3, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size = 0;
    return start;
    function start(code4) {
      const kind = self2.containerState.type || (code4 === 42 || code4 === 43 || code4 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code4 === self2.containerState.marker : asciiDigit(code4)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code4 === 42 || code4 === 45 ? effects.check(thematicBreak, nok, atMarker)(code4) : atMarker(code4);
        }
        if (!self2.interrupt || code4 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code4);
        }
      }
      return nok(code4);
    }
    function inside(code4) {
      if (asciiDigit(code4) && ++size < 10) {
        effects.consume(code4);
        return inside;
      }
      if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code4 === self2.containerState.marker : code4 === 41 || code4 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code4);
      }
      return nok(code4);
    }
    function atMarker(code4) {
      effects.enter("listItemMarker");
      effects.consume(code4);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code4;
      return effects.check(
        blankLine,
        // Canâ€™t be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
      );
    }
    function onBlank(code4) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code4);
    }
    function otherPrefix(code4) {
      if (markdownSpace(code4)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code4);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code4);
    }
    function endOfPrefix(code4) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok3(code4);
    }
  }
  function tokenizeListContinuation(effects, ok3, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine, onBlank, notBlank);
    function onBlank(code4) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code4);
    }
    function notBlank(code4) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code4)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code4);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code4);
    }
    function notInCurrentItem(code4) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace(effects, effects.attempt(list, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
    }
  }
  function tokenizeIndent(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code4) : nok(code4);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace(code4) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code4) : nok(code4);
    }
  }
  var list, listItemPrefixWhitespaceConstruct, indentConstruct;
  var init_list = __esm({
    "node_modules/micromark-core-commonmark/lib/list.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_blank_line();
      init_thematic_break();
      list = {
        continuation: {
          tokenize: tokenizeListContinuation
        },
        exit: tokenizeListEnd,
        name: "list",
        tokenize: tokenizeListStart
      };
      listItemPrefixWhitespaceConstruct = {
        partial: true,
        tokenize: tokenizeListItemPrefixWhitespace
      };
      indentConstruct = {
        partial: true,
        tokenize: tokenizeIndent
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/setext-underline.js
  function resolveToSetextUnderline(events, context) {
    let index2 = events.length;
    let content3;
    let text10;
    let definition3;
    while (index2--) {
      if (events[index2][0] === "enter") {
        if (events[index2][1].type === "content") {
          content3 = index2;
          break;
        }
        if (events[index2][1].type === "paragraph") {
          text10 = index2;
        }
      } else {
        if (events[index2][1].type === "content") {
          events.splice(index2, 1);
        }
        if (!definition3 && events[index2][1].type === "definition") {
          definition3 = index2;
        }
      }
    }
    const heading3 = {
      type: "setextHeading",
      start: {
        ...events[content3][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    events[text10][1].type = "setextHeadingText";
    if (definition3) {
      events.splice(text10, 0, ["enter", heading3, context]);
      events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
      events[content3][1].end = {
        ...events[definition3][1].end
      };
    } else {
      events[content3][1] = heading3;
    }
    events.push(["exit", heading3, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok3, nok) {
    const self2 = this;
    let marker;
    return start;
    function start(code4) {
      let index2 = self2.events.length;
      let paragraph3;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph3 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
        effects.enter("setextHeadingLine");
        marker = code4;
        return before(code4);
      }
      return nok(code4);
    }
    function before(code4) {
      effects.enter("setextHeadingLineSequence");
      return inside(code4);
    }
    function inside(code4) {
      if (code4 === marker) {
        effects.consume(code4);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace(code4) ? factorySpace(effects, after, "lineSuffix")(code4) : after(code4);
    }
    function after(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("setextHeadingLine");
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  var setextUnderline;
  var init_setext_underline = __esm({
    "node_modules/micromark-core-commonmark/lib/setext-underline.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      setextUnderline = {
        name: "setextUnderline",
        resolveTo: resolveToSetextUnderline,
        tokenize: tokenizeSetextUnderline
      };
    }
  });

  // node_modules/micromark-core-commonmark/index.js
  var init_micromark_core_commonmark = __esm({
    "node_modules/micromark-core-commonmark/index.js"() {
      init_attention();
      init_autolink();
      init_blank_line();
      init_block_quote();
      init_character_escape();
      init_character_reference();
      init_code_fenced();
      init_code_indented();
      init_code_text();
      init_content2();
      init_definition();
      init_hard_break_escape();
      init_heading_atx();
      init_html_flow();
      init_html_text();
      init_label_end();
      init_label_start_image();
      init_label_start_link();
      init_line_ending();
      init_list();
      init_setext_underline();
      init_thematic_break();
    }
  });

  // node_modules/micromark/lib/initialize/flow.js
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix"))
    );
    return initial;
    function atBlankEnding(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code4);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code4) {
      if (code4 === null) {
        effects.consume(code4);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }
  var flow;
  var init_flow = __esm({
    "node_modules/micromark/lib/initialize/flow.js"() {
      init_micromark_core_commonmark();
      init_micromark_factory_space();
      flow = {
        tokenize: initializeFlow
      };
    }
  });

  // node_modules/micromark/lib/initialize/text.js
  function initializeFactory(field) {
    return {
      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
      tokenize: initializeText
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs2 = this.parser.constructs[field];
      const text10 = effects.attempt(constructs2, start, notText);
      return start;
      function start(code4) {
        return atBreak(code4) ? text10(code4) : notText(code4);
      }
      function notText(code4) {
        if (code4 === null) {
          effects.consume(code4);
          return;
        }
        effects.enter("data");
        effects.consume(code4);
        return data;
      }
      function data(code4) {
        if (atBreak(code4)) {
          effects.exit("data");
          return text10(code4);
        }
        effects.consume(code4);
        return data;
      }
      function atBreak(code4) {
        if (code4 === null) {
          return true;
        }
        const list4 = constructs2[code4];
        let index2 = -1;
        if (list4) {
          while (++index2 < list4.length) {
            const item = list4[index2];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index2 = -1;
      let enter;
      while (++index2 <= events.length) {
        if (enter === void 0) {
          if (events[index2] && events[index2][1].type === "data") {
            enter = index2;
            index2++;
          }
        } else if (!events[index2] || events[index2][1].type !== "data") {
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data);
        let index2 = chunks.length;
        let bufferIndex = -1;
        let size = 0;
        let tabs;
        while (index2--) {
          const chunk = chunks[index2];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size++;
              bufferIndex--;
            }
            if (bufferIndex) break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size++;
          } else if (chunk === -1) {
          } else {
            index2++;
            break;
          }
        }
        if (context._contentTypeTextTrailing && eventIndex === events.length) {
          size = 0;
        }
        if (size) {
          const token = {
            type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
              _index: data.start._index + index2,
              line: data.end.line,
              column: data.end.column - size,
              offset: data.end.offset - size
            },
            end: {
              ...data.end
            }
          };
          data.end = {
            ...token.start
          };
          if (data.start.offset === data.end.offset) {
            Object.assign(data, token);
          } else {
            events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }
  var resolver, string, text;
  var init_text = __esm({
    "node_modules/micromark/lib/initialize/text.js"() {
      resolver = {
        resolveAll: createResolver()
      };
      string = initializeFactory("string");
      text = initializeFactory("text");
    }
  });

  // node_modules/micromark/lib/constructs.js
  var constructs_exports = {};
  __export(constructs_exports, {
    attentionMarkers: () => attentionMarkers,
    contentInitial: () => contentInitial,
    disable: () => disable,
    document: () => document3,
    flow: () => flow2,
    flowInitial: () => flowInitial,
    insideSpan: () => insideSpan,
    string: () => string2,
    text: () => text2
  });
  var document3, contentInitial, flowInitial, flow2, string2, text2, insideSpan, attentionMarkers, disable;
  var init_constructs = __esm({
    "node_modules/micromark/lib/constructs.js"() {
      init_micromark_core_commonmark();
      init_text();
      document3 = {
        [42]: list,
        [43]: list,
        [45]: list,
        [48]: list,
        [49]: list,
        [50]: list,
        [51]: list,
        [52]: list,
        [53]: list,
        [54]: list,
        [55]: list,
        [56]: list,
        [57]: list,
        [62]: blockQuote
      };
      contentInitial = {
        [91]: definition
      };
      flowInitial = {
        [-2]: codeIndented,
        [-1]: codeIndented,
        [32]: codeIndented
      };
      flow2 = {
        [35]: headingAtx,
        [42]: thematicBreak,
        [45]: [setextUnderline, thematicBreak],
        [60]: htmlFlow,
        [61]: setextUnderline,
        [95]: thematicBreak,
        [96]: codeFenced,
        [126]: codeFenced
      };
      string2 = {
        [38]: characterReference,
        [92]: characterEscape
      };
      text2 = {
        [-5]: lineEnding,
        [-4]: lineEnding,
        [-3]: lineEnding,
        [33]: labelStartImage,
        [38]: characterReference,
        [42]: attention,
        [60]: [autolink, htmlText],
        [91]: labelStartLink,
        [92]: [hardBreakEscape, characterEscape],
        [93]: labelEnd,
        [95]: attention,
        [96]: codeText
      };
      insideSpan = {
        null: [attention, resolver]
      };
      attentionMarkers = {
        null: [42, 95]
      };
      disable = {
        null: []
      };
    }
  });

  // node_modules/micromark/lib/create-tokenizer.js
  function createTokenizer(parser2, initialize, from) {
    let point4 = {
      _bufferIndex: -1,
      _index: 0,
      line: from && from.line || 1,
      column: from && from.column || 1,
      offset: from && from.offset || 0
    };
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    let consumed = true;
    const effects = {
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      consume,
      enter,
      exit: exit3,
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      code: null,
      containerState: {},
      defineSkip,
      events: [],
      now,
      parser: parser2,
      previous: null,
      sliceSerialize,
      sliceStream,
      write
    };
    let state = initialize.tokenize.call(context, effects);
    let expectedCode;
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    return context;
    function write(slice) {
      chunks = push(chunks, slice);
      main2();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token, expandTabs) {
      return serializeChunks(sliceStream(token), expandTabs);
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now() {
      const {
        _bufferIndex,
        _index,
        line,
        column,
        offset
      } = point4;
      return {
        _bufferIndex,
        _index,
        line,
        column,
        offset
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main2() {
      let chunkIndex;
      while (point4._index < chunks.length) {
        const chunk = chunks[point4._index];
        if (typeof chunk === "string") {
          chunkIndex = point4._index;
          if (point4._bufferIndex < 0) {
            point4._bufferIndex = 0;
          }
          while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point4._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code4) {
      consumed = void 0;
      expectedCode = code4;
      state = state(code4);
    }
    function consume(code4) {
      if (markdownLineEnding(code4)) {
        point4.line++;
        point4.column = 1;
        point4.offset += code4 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code4 !== -1) {
        point4.column++;
        point4.offset++;
      }
      if (point4._bufferIndex < 0) {
        point4._index++;
      } else {
        point4._bufferIndex++;
        if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
        // strings.
        /** @type {string} */
        chunks[point4._index].length) {
          point4._bufferIndex = -1;
          point4._index++;
        }
      }
      context.previous = code4;
      consumed = true;
    }
    function enter(type, fields) {
      const token = fields || {};
      token.type = type;
      token.start = now();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit3(type) {
      const token = stack.pop();
      token.end = now();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs2, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs2) ? (
          /* c8 ignore next 1 */
          handleListOfConstructs(constructs2)
        ) : "tokenize" in constructs2 ? (
          // Looks like a construct.
          handleListOfConstructs([
            /** @type {Construct} */
            constructs2
          ])
        ) : handleMapOfConstructs(constructs2);
        function handleMapOfConstructs(map3) {
          return start;
          function start(code4) {
            const left = code4 !== null && map3[code4];
            const all4 = code4 !== null && map3.null;
            const list4 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(left) ? left : left ? [left] : [],
              ...Array.isArray(all4) ? all4 : all4 ? [all4] : []
            ];
            return handleListOfConstructs(list4)(code4);
          }
        }
        function handleListOfConstructs(list4) {
          listOfConstructs = list4;
          constructIndex = 0;
          if (list4.length === 0) {
            return bogusState;
          }
          return handleConstruct(list4[constructIndex]);
        }
        function handleConstruct(construct) {
          return start;
          function start(code4) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok(code4);
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok3,
              nok
            )(code4);
          }
        }
        function ok3(code4) {
          consumed = true;
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code4) {
          consumed = true;
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from2) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      const startPoint = now();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        from: startEventsIndex,
        restore
      };
      function restore() {
        point4 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point4.line in columnStart && point4.column < 2) {
        point4.column = columnStart[point4.line];
        point4.offset += columnStart[point4.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token) {
    const startIndex = token.start._index;
    const startBufferIndex = token.start._bufferIndex;
    const endIndex = token.end._index;
    const endBufferIndex = token.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head2 = view[0];
        if (typeof head2 === "string") {
          view[0] = head2.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks(chunks, expandTabs) {
    let index2 = -1;
    const result = [];
    let atTab;
    while (++index2 < chunks.length) {
      const chunk = chunks[index2];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }
  var init_create_tokenizer = __esm({
    "node_modules/micromark/lib/create-tokenizer.js"() {
      init_micromark_util_character();
      init_micromark_util_chunked();
      init_micromark_util_resolve_all();
    }
  });

  // node_modules/micromark/lib/parse.js
  function parse(options) {
    const settings = options || {};
    const constructs2 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions([constructs_exports, ...settings.extensions || []])
    );
    const parser2 = {
      constructs: constructs2,
      content: create2(content),
      defined: [],
      document: create2(document2),
      flow: create2(flow),
      lazy: {},
      string: create2(string),
      text: create2(text)
    };
    return parser2;
    function create2(initial) {
      return creator;
      function creator(from) {
        return createTokenizer(parser2, initial, from);
      }
    }
  }
  var init_parse = __esm({
    "node_modules/micromark/lib/parse.js"() {
      init_micromark_util_combine_extensions();
      init_content();
      init_document();
      init_flow();
      init_text();
      init_constructs();
      init_create_tokenizer();
    }
  });

  // node_modules/micromark/lib/postprocess.js
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }
  var init_postprocess = __esm({
    "node_modules/micromark/lib/postprocess.js"() {
      init_micromark_util_subtokenize();
    }
  });

  // node_modules/micromark/lib/preprocess.js
  function preprocess() {
    let column = 1;
    let buffer = "";
    let start = true;
    let atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      const chunks = [];
      let match;
      let next;
      let startPosition;
      let endPosition;
      let code4;
      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
      startPosition = 0;
      buffer = "";
      if (start) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start = void 0;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match = search.exec(value);
        endPosition = match && match.index !== void 0 ? match.index : value.length;
        code4 = value.charCodeAt(endPosition);
        if (!match) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code4 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          switch (code4) {
            case 0: {
              chunks.push(65533);
              column++;
              break;
            }
            case 9: {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next) chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn) chunks.push(-5);
        if (buffer) chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }
  var search;
  var init_preprocess = __esm({
    "node_modules/micromark/lib/preprocess.js"() {
      search = /[\0\t\n\r]/g;
    }
  });

  // node_modules/micromark/index.js
  var init_micromark = __esm({
    "node_modules/micromark/index.js"() {
      init_parse();
      init_postprocess();
      init_preprocess();
    }
  });

  // node_modules/micromark-util-decode-string/index.js
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head2 = $2.charCodeAt(0);
    if (head2 === 35) {
      const head3 = $2.charCodeAt(1);
      const hex = head3 === 120 || head3 === 88;
      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  var characterEscapeOrReference;
  var init_micromark_util_decode_string = __esm({
    "node_modules/micromark-util-decode-string/index.js"() {
      init_index_dom();
      init_micromark_util_decode_numeric_character_reference();
      characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    }
  });

  // node_modules/mdast-util-from-markdown/lib/index.js
  function fromMarkdown(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
  }
  function compiler(options) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link3),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading3),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition3),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis3),
        hardBreakEscape: opener(hardBreak3),
        hardBreakTrailing: opener(hardBreak3),
        htmlFlow: opener(html7, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html7, buffer),
        htmlTextData: onenterdata,
        image: opener(image3),
        label: buffer,
        link: opener(link3),
        listItem: opener(listItem3),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list4, onenterlistordered),
        listUnordered: opener(list4),
        paragraph: opener(paragraph3),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading3),
        strong: opener(strong3),
        thematicBreak: opener(thematicBreak4)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        characterReference: onexitcharacterreference,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure(config, (options || {}).mdastExtensions || []);
    const data = {};
    return compile;
    function compile(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter,
        exit: exit3,
        buffer,
        resume,
        data
      };
      const listStack = [];
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
          if (events[index2][0] === "enter") {
            listStack.push(index2);
          } else {
            const tail = listStack.pop();
            index2 = prepareList(events, tail, index2);
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        const handler = config[events[index2][0]];
        if (own2.call(handler, events[index2][1].type)) {
          handler[events[index2][1].type].call(Object.assign({
            sliceSerialize: events[index2][2].sliceSerialize
          }, context), events[index2][1]);
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point2(events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: point2(events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      };
      index2 = -1;
      while (++index2 < config.transforms.length) {
        tree = config.transforms[index2](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start, length) {
      let index2 = start - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem4;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index2 <= length) {
        const event = events[index2];
        switch (event[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter") {
              if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace": {
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem4) {
            let tailIndex = index2;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit") continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
              } else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem4._spread = true;
            }
            listItem4.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index2, 0, ["exit", listItem4, event[2]]);
            index2++;
            length++;
          }
          if (event[1].type === "listItemPrefix") {
            const item = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: weâ€™ll add `end` in a second.
              end: void 0
            };
            listItem4 = item;
            events.splice(index2, 0, ["enter", item, event[2]]);
            index2++;
            length++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start][1]._spread = listSpread;
      return length;
    }
    function opener(create2, and) {
      return open2;
      function open2(token) {
        enter.call(this, create2(token), token);
        if (and) and.call(this, token);
      }
    }
    function buffer() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter(node2, token, errorHandler) {
      const parent = this.stack[this.stack.length - 1];
      const siblings2 = parent.children;
      siblings2.push(node2);
      this.stack.push(node2);
      this.tokenStack.push([token, errorHandler || void 0]);
      node2.position = {
        start: point2(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function closer(and) {
      return close2;
      function close2(token) {
        if (and) and.call(this, token);
        exit3.call(this, token);
      }
    }
    function exit3(token, onExitError) {
      const node2 = this.stack.pop();
      const open2 = this.tokenStack.pop();
      if (!open2) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): it\u2019s not open");
      } else if (open2[0].type !== token.type) {
        if (onExitError) {
          onExitError.call(this, token, open2[0]);
        } else {
          const handler = open2[1] || defaultOnError;
          handler.call(this, token, open2[0]);
        }
      }
      node2.position.end = point2(token.end);
    }
    function resume() {
      return toString(this.stack.pop());
    }
    function onenterlistordered() {
      this.data.expectingFirstListItemValue = true;
    }
    function onenterlistitemvalue(token) {
      if (this.data.expectingFirstListItemValue) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
        this.data.expectingFirstListItemValue = void 0;
      }
    }
    function onexitcodefencedfenceinfo() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.lang = data2;
    }
    function onexitcodefencedfencemeta() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.meta = data2;
    }
    function onexitcodefencedfence() {
      if (this.data.flowCodeInside) return;
      this.buffer();
      this.data.flowCodeInside = true;
    }
    function onexitcodefenced() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      this.data.flowCodeInside = void 0;
    }
    function onexitcodeindented() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitdefinitiondestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitatxheadingsequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      if (!node2.depth) {
        const depth = this.sliceSerialize(token).length;
        node2.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      this.data.setextHeadingSlurpLineEnding = true;
    }
    function onexitsetextheadinglinesequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function onenterdata(token) {
      const node2 = this.stack[this.stack.length - 1];
      const siblings2 = node2.children;
      let tail = siblings2[siblings2.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text10();
        tail.position = {
          start: point2(token.start),
          // @ts-expect-error: weâ€™ll add `end` later.
          end: void 0
        };
        siblings2.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point2(token.end);
    }
    function onexitlineending(token) {
      const context = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point2(token.end);
        this.data.atHardBreak = void 0;
        return;
      }
      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      this.data.atHardBreak = true;
    }
    function onexithtmlflow() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexithtmltext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitcodetext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitlink() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitimage() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitlabeltext(token) {
      const string3 = this.sliceSerialize(token);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string3);
      ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
    }
    function onexitlabel() {
      const fragment = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      this.data.inReference = true;
      if (node2.type === "link") {
        const children2 = fragment.children;
        node2.children = children2;
      } else {
        node2.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitresourcetitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitresource() {
      this.data.inReference = void 0;
    }
    function onenterreference() {
      this.data.referenceType = "collapsed";
    }
    function onexitreferencestring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
      this.data.referenceType = "full";
    }
    function onexitcharacterreferencemarker(token) {
      this.data.characterReferenceType = token.type;
    }
    function onexitcharacterreferencevalue(token) {
      const data2 = this.sliceSerialize(token);
      const type = this.data.characterReferenceType;
      let value;
      if (type) {
        value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        this.data.characterReferenceType = void 0;
      } else {
        const result = decodeNamedCharacterReference(data2);
        value = result;
      }
      const tail = this.stack[this.stack.length - 1];
      tail.value += value;
    }
    function onexitcharacterreference(token) {
      const tail = this.stack.pop();
      tail.position.end = point2(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition3() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis3() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading3() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function hardBreak3() {
      return {
        type: "break"
      };
    }
    function html7() {
      return {
        type: "html",
        value: ""
      };
    }
    function image3() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link3() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list4(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem3(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph3() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong3() {
      return {
        type: "strong",
        children: []
      };
    }
    function text10() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak4() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point2(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure(combined, extensions) {
    let index2 = -1;
    while (++index2 < extensions.length) {
      const value = extensions[index2];
      if (Array.isArray(value)) {
        configure(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key2;
    for (key2 in extension2) {
      if (own2.call(extension2, key2)) {
        switch (key2) {
          case "canContainEols": {
            const right = extension2[key2];
            if (right) {
              combined[key2].push(...right);
            }
            break;
          }
          case "transforms": {
            const right = extension2[key2];
            if (right) {
              combined[key2].push(...right);
            }
            break;
          }
          case "enter":
          case "exit": {
            const right = extension2[key2];
            if (right) {
              Object.assign(combined[key2], right);
            }
            break;
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open");
    } else {
      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open");
    }
  }
  var own2;
  var init_lib7 = __esm({
    "node_modules/mdast-util-from-markdown/lib/index.js"() {
      init_mdast_util_to_string();
      init_micromark();
      init_micromark_util_decode_numeric_character_reference();
      init_micromark_util_decode_string();
      init_micromark_util_normalize_identifier();
      init_index_dom();
      init_unist_util_stringify_position();
      own2 = {}.hasOwnProperty;
    }
  });

  // node_modules/mdast-util-from-markdown/index.js
  var init_mdast_util_from_markdown = __esm({
    "node_modules/mdast-util-from-markdown/index.js"() {
      init_lib7();
    }
  });

  // node_modules/remark-parse/lib/index.js
  function remarkParse(options) {
    const self2 = this;
    self2.parser = parser2;
    function parser2(doc) {
      return fromMarkdown(doc, {
        ...self2.data("settings"),
        ...options,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      });
    }
  }
  var init_lib8 = __esm({
    "node_modules/remark-parse/lib/index.js"() {
      init_mdast_util_from_markdown();
    }
  });

  // node_modules/remark-parse/index.js
  var init_remark_parse = __esm({
    "node_modules/remark-parse/index.js"() {
      init_lib8();
    }
  });

  // node_modules/ccount/index.js
  function ccount(value, character) {
    const source = String(value);
    if (typeof character !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index2 = source.indexOf(character);
    while (index2 !== -1) {
      count++;
      index2 = source.indexOf(character, index2 + character.length);
    }
    return count;
  }
  var init_ccount = __esm({
    "node_modules/ccount/index.js"() {
    }
  });

  // node_modules/escape-string-regexp/index.js
  function escapeStringRegexp(string3) {
    if (typeof string3 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  var init_escape_string_regexp = __esm({
    "node_modules/escape-string-regexp/index.js"() {
    }
  });

  // node_modules/unist-util-is/lib/index.js
  function anyFactory(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convert(tests[index2]);
    }
    return castFactory(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory(all4);
    function all4(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value, index2, parent) {
      return Boolean(
        looksLikeANode(value) && testFunction.call(
          this,
          value,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok2() {
    return true;
  }
  function looksLikeANode(value) {
    return value !== null && typeof value === "object" && "type" in value;
  }
  var convert;
  var init_lib9 = __esm({
    "node_modules/unist-util-is/lib/index.js"() {
      convert = // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
       *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
       *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
       *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
       *   ((test?: Test) => Check)
       * )}
       */
      /**
       * @param {Test} [test]
       * @returns {Check}
       */
      function(test) {
        if (test === null || test === void 0) {
          return ok2;
        }
        if (typeof test === "function") {
          return castFactory(test);
        }
        if (typeof test === "object") {
          return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
        }
        if (typeof test === "string") {
          return typeFactory(test);
        }
        throw new Error("Expected function, string, or object as test");
      };
    }
  });

  // node_modules/unist-util-is/index.js
  var init_unist_util_is = __esm({
    "node_modules/unist-util-is/index.js"() {
      init_lib9();
    }
  });

  // node_modules/unist-util-visit-parents/lib/color.js
  function color(d) {
    return d;
  }
  var init_color = __esm({
    "node_modules/unist-util-visit-parents/lib/color.js"() {
    }
  });

  // node_modules/unist-util-visit-parents/lib/index.js
  function visitParents(tree, test, visitor, reverse) {
    let check;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
    } else {
      check = test;
    }
    const is2 = convert(check);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = (
        /** @type {Record<string, unknown>} */
        node2 && typeof node2 === "object" ? node2 : {}
      );
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = empty;
        let subresult;
        let offset;
        let grandparents;
        if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if ("children" in node2 && node2.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node2
          );
          if (nodeAsParent.children && result[0] !== SKIP) {
            offset = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset > -1 && offset < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset];
              subresult = factory(child, offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return value === null || value === void 0 ? empty : [value];
  }
  var empty, CONTINUE, EXIT, SKIP;
  var init_lib10 = __esm({
    "node_modules/unist-util-visit-parents/lib/index.js"() {
      init_unist_util_is();
      init_color();
      empty = [];
      CONTINUE = true;
      EXIT = false;
      SKIP = "skip";
    }
  });

  // node_modules/unist-util-visit-parents/index.js
  var init_unist_util_visit_parents = __esm({
    "node_modules/unist-util-visit-parents/index.js"() {
      init_lib10();
    }
  });

  // node_modules/mdast-util-find-and-replace/lib/index.js
  function findAndReplace(tree, list4, options) {
    const settings = options || {};
    const ignored = convert(settings.ignore || []);
    const pairs = toPairs(list4);
    let pairIndex = -1;
    while (++pairIndex < pairs.length) {
      visitParents(tree, "text", visitor);
    }
    function visitor(node2, parents) {
      let index2 = -1;
      let grandparent;
      while (++index2 < parents.length) {
        const parent = parents[index2];
        const siblings2 = grandparent ? grandparent.children : void 0;
        if (ignored(
          parent,
          siblings2 ? siblings2.indexOf(parent) : void 0,
          grandparent
        )) {
          return;
        }
        grandparent = parent;
      }
      if (grandparent) {
        return handler(node2, parents);
      }
    }
    function handler(node2, parents) {
      const parent = parents[parents.length - 1];
      const find2 = pairs[pairIndex][0];
      const replace2 = pairs[pairIndex][1];
      let start = 0;
      const siblings2 = parent.children;
      const index2 = siblings2.indexOf(node2);
      let change = false;
      let nodes = [];
      find2.lastIndex = 0;
      let match = find2.exec(node2.value);
      while (match) {
        const position3 = match.index;
        const matchObject = {
          index: match.index,
          input: match.input,
          stack: [...parents, node2]
        };
        let value = replace2(...match, matchObject);
        if (typeof value === "string") {
          value = value.length > 0 ? { type: "text", value } : void 0;
        }
        if (value === false) {
          find2.lastIndex = position3 + 1;
        } else {
          if (start !== position3) {
            nodes.push({
              type: "text",
              value: node2.value.slice(start, position3)
            });
          }
          if (Array.isArray(value)) {
            nodes.push(...value);
          } else if (value) {
            nodes.push(value);
          }
          start = position3 + match[0].length;
          change = true;
        }
        if (!find2.global) {
          break;
        }
        match = find2.exec(node2.value);
      }
      if (change) {
        if (start < node2.value.length) {
          nodes.push({ type: "text", value: node2.value.slice(start) });
        }
        parent.children.splice(index2, 1, ...nodes);
      } else {
        nodes = [node2];
      }
      return index2 + nodes.length;
    }
  }
  function toPairs(tupleOrList) {
    const result = [];
    if (!Array.isArray(tupleOrList)) {
      throw new TypeError("Expected find and replace tuple or list of tuples");
    }
    const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
    let index2 = -1;
    while (++index2 < list4.length) {
      const tuple = list4[index2];
      result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
    }
    return result;
  }
  function toExpression(find2) {
    return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
  }
  function toFunction(replace2) {
    return typeof replace2 === "function" ? replace2 : function() {
      return replace2;
    };
  }
  var init_lib11 = __esm({
    "node_modules/mdast-util-find-and-replace/lib/index.js"() {
      init_escape_string_regexp();
      init_unist_util_visit_parents();
      init_unist_util_is();
    }
  });

  // node_modules/mdast-util-find-and-replace/index.js
  var init_mdast_util_find_and_replace = __esm({
    "node_modules/mdast-util-find-and-replace/index.js"() {
      init_lib11();
    }
  });

  // node_modules/mdast-util-gfm-autolink-literal/lib/index.js
  function gfmAutolinkLiteralFromMarkdown() {
    return {
      transforms: [transformGfmAutolinkLiterals],
      enter: {
        literalAutolink: enterLiteralAutolink,
        literalAutolinkEmail: enterLiteralAutolinkValue,
        literalAutolinkHttp: enterLiteralAutolinkValue,
        literalAutolinkWww: enterLiteralAutolinkValue
      },
      exit: {
        literalAutolink: exitLiteralAutolink,
        literalAutolinkEmail: exitLiteralAutolinkEmail,
        literalAutolinkHttp: exitLiteralAutolinkHttp,
        literalAutolinkWww: exitLiteralAutolinkWww
      }
    };
  }
  function gfmAutolinkLiteralToMarkdown() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct,
          notInConstruct
        }
      ]
    };
  }
  function enterLiteralAutolink(token) {
    this.enter({ type: "link", title: null, url: "", children: [] }, token);
  }
  function enterLiteralAutolinkValue(token) {
    this.config.enter.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkHttp(token) {
    this.config.exit.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkWww(token) {
    this.config.exit.data.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "link");
    node2.url = "http://" + this.sliceSerialize(token);
  }
  function exitLiteralAutolinkEmail(token) {
    this.config.exit.autolinkEmail.call(this, token);
  }
  function exitLiteralAutolink(token) {
    this.exit(token);
  }
  function transformGfmAutolinkLiterals(tree) {
    findAndReplace(
      tree,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
        [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function findUrl(_, protocol, domain2, path3, match) {
    let prefix = "";
    if (!previous2(match)) {
      return false;
    }
    if (/^w/i.test(protocol)) {
      domain2 = protocol + domain2;
      protocol = "";
      prefix = "http://";
    }
    if (!isCorrectDomain(domain2)) {
      return false;
    }
    const parts = splitUrl(domain2 + path3);
    if (!parts[0]) return false;
    const result = {
      type: "link",
      title: null,
      url: prefix + protocol + parts[0],
      children: [{ type: "text", value: protocol + parts[0] }]
    };
    if (parts[1]) {
      return [result, { type: "text", value: parts[1] }];
    }
    return result;
  }
  function findEmail(_, atext, label, match) {
    if (
      // Not an expected previous character.
      !previous2(match, true) || // Label ends in not allowed character.
      /[-\d_]$/.test(label)
    ) {
      return false;
    }
    return {
      type: "link",
      title: null,
      url: "mailto:" + atext + "@" + label,
      children: [{ type: "text", value: atext + "@" + label }]
    };
  }
  function isCorrectDomain(domain2) {
    const parts = domain2.split(".");
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
      return false;
    }
    return true;
  }
  function splitUrl(url) {
    const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
    if (!trailExec) {
      return [url, void 0];
    }
    url = url.slice(0, trailExec.index);
    let trail2 = trailExec[0];
    let closingParenIndex = trail2.indexOf(")");
    const openingParens = ccount(url, "(");
    let closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail2.slice(0, closingParenIndex + 1);
      trail2 = trail2.slice(closingParenIndex + 1);
      closingParenIndex = trail2.indexOf(")");
      closingParens++;
    }
    return [url, trail2];
  }
  function previous2(match, email) {
    const code4 = match.input.charCodeAt(match.index - 1);
    return (match.index === 0 || unicodeWhitespace(code4) || unicodePunctuation(code4)) && // If itâ€™s an email, the previous character should not be a slash.
    (!email || code4 !== 47);
  }
  var inConstruct, notInConstruct;
  var init_lib12 = __esm({
    "node_modules/mdast-util-gfm-autolink-literal/lib/index.js"() {
      init_ccount();
      init_default();
      init_micromark_util_character();
      init_mdast_util_find_and_replace();
      inConstruct = "phrasing";
      notInConstruct = ["autolink", "link", "image", "label"];
    }
  });

  // node_modules/mdast-util-gfm-autolink-literal/index.js
  var init_mdast_util_gfm_autolink_literal = __esm({
    "node_modules/mdast-util-gfm-autolink-literal/index.js"() {
      init_lib12();
    }
  });

  // node_modules/mdast-util-gfm-footnote/lib/index.js
  function enterFootnoteCallString() {
    this.buffer();
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function enterFootnoteDefinition(token) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      token
    );
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "footnoteReference");
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    node2.label = label;
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "footnoteDefinition");
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    node2.label = label;
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function footnoteReferencePeek() {
    return "[";
  }
  function footnoteReference(node2, _, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteReference");
    const subexit = state.enter("reference");
    value += tracker.move(
      state.safe(state.associationId(node2), { after: "]", before: value })
    );
    subexit();
    exit3();
    value += tracker.move("]");
    return value;
  }
  function gfmFootnoteFromMarkdown() {
    return {
      enter: {
        gfmFootnoteCallString: enterFootnoteCallString,
        gfmFootnoteCall: enterFootnoteCall,
        gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: enterFootnoteDefinition
      },
      exit: {
        gfmFootnoteCallString: exitFootnoteCallString,
        gfmFootnoteCall: exitFootnoteCall,
        gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: exitFootnoteDefinition
      }
    };
  }
  function gfmFootnoteToMarkdown(options) {
    let firstLineBlank = false;
    if (options && options.firstLineBlank) {
      firstLineBlank = true;
    }
    return {
      handlers: { footnoteDefinition, footnoteReference },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function footnoteDefinition(node2, _, state, info) {
      const tracker = state.createTracker(info);
      let value = tracker.move("[^");
      const exit3 = state.enter("footnoteDefinition");
      const subexit = state.enter("label");
      value += tracker.move(
        state.safe(state.associationId(node2), { before: value, after: "]" })
      );
      subexit();
      value += tracker.move("]:");
      if (node2.children && node2.children.length > 0) {
        tracker.shift(4);
        value += tracker.move(
          (firstLineBlank ? "\n" : " ") + state.indentLines(
            state.containerFlow(node2, tracker.current()),
            firstLineBlank ? mapAll : mapExceptFirst
          )
        );
      }
      exit3();
      return value;
    }
  }
  function mapExceptFirst(line, index2, blank) {
    return index2 === 0 ? line : mapAll(line, index2, blank);
  }
  function mapAll(line, index2, blank) {
    return (blank ? "" : "    ") + line;
  }
  var init_lib13 = __esm({
    "node_modules/mdast-util-gfm-footnote/lib/index.js"() {
      init_default();
      init_micromark_util_normalize_identifier();
      footnoteReference.peek = footnoteReferencePeek;
    }
  });

  // node_modules/mdast-util-gfm-footnote/index.js
  var init_mdast_util_gfm_footnote = __esm({
    "node_modules/mdast-util-gfm-footnote/index.js"() {
      init_lib13();
    }
  });

  // node_modules/mdast-util-gfm-strikethrough/lib/index.js
  function gfmStrikethroughFromMarkdown() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: enterStrikethrough },
      exit: { strikethrough: exitStrikethrough }
    };
  }
  function gfmStrikethroughToMarkdown() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: constructsWithoutStrikethrough
        }
      ],
      handlers: { delete: handleDelete }
    };
  }
  function enterStrikethrough(token) {
    this.enter({ type: "delete", children: [] }, token);
  }
  function exitStrikethrough(token) {
    this.exit(token);
  }
  function handleDelete(node2, _, state, info) {
    const tracker = state.createTracker(info);
    const exit3 = state.enter("strikethrough");
    let value = tracker.move("~~");
    value += state.containerPhrasing(node2, {
      ...tracker.current(),
      before: value,
      after: "~"
    });
    value += tracker.move("~~");
    exit3();
    return value;
  }
  function peekDelete() {
    return "~";
  }
  var constructsWithoutStrikethrough;
  var init_lib14 = __esm({
    "node_modules/mdast-util-gfm-strikethrough/lib/index.js"() {
      constructsWithoutStrikethrough = [
        "autolink",
        "destinationLiteral",
        "destinationRaw",
        "reference",
        "titleQuote",
        "titleApostrophe"
      ];
      handleDelete.peek = peekDelete;
    }
  });

  // node_modules/mdast-util-gfm-strikethrough/index.js
  var init_mdast_util_gfm_strikethrough = __esm({
    "node_modules/mdast-util-gfm-strikethrough/index.js"() {
      init_lib14();
    }
  });

  // node_modules/markdown-table/index.js
  function defaultStringLength(value) {
    return value.length;
  }
  function markdownTable(table2, options) {
    const settings = options || {};
    const align = (settings.align || []).concat();
    const stringLength = settings.stringLength || defaultStringLength;
    const alignments = [];
    const cellMatrix = [];
    const sizeMatrix = [];
    const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    while (++rowIndex < table2.length) {
      const row3 = [];
      const sizes2 = [];
      let columnIndex2 = -1;
      if (table2[rowIndex].length > mostCellsPerRow) {
        mostCellsPerRow = table2[rowIndex].length;
      }
      while (++columnIndex2 < table2[rowIndex].length) {
        const cell2 = serialize(table2[rowIndex][columnIndex2]);
        if (settings.alignDelimiters !== false) {
          const size = stringLength(cell2);
          sizes2[columnIndex2] = size;
          if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
            longestCellByColumn[columnIndex2] = size;
          }
        }
        row3.push(cell2);
      }
      cellMatrix[rowIndex] = row3;
      sizeMatrix[rowIndex] = sizes2;
    }
    let columnIndex = -1;
    if (typeof align === "object" && "length" in align) {
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = toAlignment(align[columnIndex]);
      }
    } else {
      const code4 = toAlignment(align);
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = code4;
      }
    }
    columnIndex = -1;
    const row2 = [];
    const sizes = [];
    while (++columnIndex < mostCellsPerRow) {
      const code4 = alignments[columnIndex];
      let before = "";
      let after = "";
      if (code4 === 99) {
        before = ":";
        after = ":";
      } else if (code4 === 108) {
        before = ":";
      } else if (code4 === 114) {
        after = ":";
      }
      let size = settings.alignDelimiters === false ? 1 : Math.max(
        1,
        longestCellByColumn[columnIndex] - before.length - after.length
      );
      const cell2 = before + "-".repeat(size) + after;
      if (settings.alignDelimiters !== false) {
        size = before.length + size + after.length;
        if (size > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size;
        }
        sizes[columnIndex] = size;
      }
      row2[columnIndex] = cell2;
    }
    cellMatrix.splice(1, 0, row2);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    const lines = [];
    while (++rowIndex < cellMatrix.length) {
      const row3 = cellMatrix[rowIndex];
      const sizes2 = sizeMatrix[rowIndex];
      columnIndex = -1;
      const line = [];
      while (++columnIndex < mostCellsPerRow) {
        const cell2 = row3[columnIndex] || "";
        let before = "";
        let after = "";
        if (settings.alignDelimiters !== false) {
          const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
          const code4 = alignments[columnIndex];
          if (code4 === 114) {
            before = " ".repeat(size);
          } else if (code4 === 99) {
            if (size % 2) {
              before = " ".repeat(size / 2 + 0.5);
              after = " ".repeat(size / 2 - 0.5);
            } else {
              before = " ".repeat(size / 2);
              after = before;
            }
          } else {
            after = " ".repeat(size);
          }
        }
        if (settings.delimiterStart !== false && !columnIndex) {
          line.push("|");
        }
        if (settings.padding !== false && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
        // empty: there will be a closing space.
        !(settings.alignDelimiters === false && cell2 === "") && (settings.delimiterStart !== false || columnIndex)) {
          line.push(" ");
        }
        if (settings.alignDelimiters !== false) {
          line.push(before);
        }
        line.push(cell2);
        if (settings.alignDelimiters !== false) {
          line.push(after);
        }
        if (settings.padding !== false) {
          line.push(" ");
        }
        if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
          line.push("|");
        }
      }
      lines.push(
        settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
      );
    }
    return lines.join("\n");
  }
  function serialize(value) {
    return value === null || value === void 0 ? "" : String(value);
  }
  function toAlignment(value) {
    const code4 = typeof value === "string" ? value.codePointAt(0) : 0;
    return code4 === 67 || code4 === 99 ? 99 : code4 === 76 || code4 === 108 ? 108 : code4 === 82 || code4 === 114 ? 114 : 0;
  }
  var init_markdown_table = __esm({
    "node_modules/markdown-table/index.js"() {
    }
  });

  // node_modules/zwitch/index.js
  function zwitch(key2, options) {
    const settings = options || {};
    function one4(value, ...parameters) {
      let fn = one4.invalid;
      const handlers2 = one4.handlers;
      if (value && own3.call(value, key2)) {
        const id = String(value[key2]);
        fn = own3.call(handlers2, id) ? handlers2[id] : one4.unknown;
      }
      if (fn) {
        return fn.call(this, value, ...parameters);
      }
    }
    one4.handlers = settings.handlers || {};
    one4.invalid = settings.invalid;
    one4.unknown = settings.unknown;
    return one4;
  }
  var own3;
  var init_zwitch = __esm({
    "node_modules/zwitch/index.js"() {
      own3 = {}.hasOwnProperty;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
  function blockquote(node2, _, state, info) {
    const exit3 = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map
    );
    exit3();
    return value;
  }
  function map(line, _, blank) {
    return ">" + (blank ? "" : " ") + line;
  }
  var init_blockquote = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/blockquote.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
  }
  function listInScope(stack, list4, none) {
    if (typeof list4 === "string") {
      list4 = [list4];
    }
    if (!list4 || list4.length === 0) {
      return none;
    }
    let index2 = -1;
    while (++index2 < list4.length) {
      if (stack.includes(list4[index2])) {
        return true;
      }
    }
    return false;
  }
  var init_pattern_in_scope = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/break.js
  function hardBreak(_, _1, state, info) {
    let index2 = -1;
    while (++index2 < state.unsafe.length) {
      if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
  var init_break = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/break.js"() {
      init_pattern_in_scope();
    }
  });

  // node_modules/longest-streak/index.js
  function longestStreak(value, substring) {
    const source = String(value);
    let index2 = source.indexOf(substring);
    let expected = index2;
    let count = 0;
    let max = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index2 !== -1) {
      if (index2 === expected) {
        if (++count > max) {
          max = count;
        }
      } else {
        count = 1;
      }
      expected = index2 + substring.length;
      index2 = source.indexOf(substring, expected);
    }
    return max;
  }
  var init_longest_streak = __esm({
    "node_modules/longest-streak/index.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
  function formatCodeAsIndented(node2, state) {
    return Boolean(
      state.options.fences === false && node2.value && // If thereâ€™s no infoâ€¦
      !node2.lang && // And thereâ€™s a non-whitespace characterâ€¦
      /[^ \r\n]/.test(node2.value) && // And the value doesnâ€™t start or end in a blankâ€¦
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
    );
  }
  var init_format_code_as_indented = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-fence.js
  function checkFence(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }
  var init_check_fence = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-fence.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/code.js
  function code(node2, _, state, info) {
    const marker = checkFence(state);
    const raw2 = node2.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node2, state)) {
      const exit4 = state.enter("codeIndented");
      const value2 = state.indentLines(raw2, map2);
      exit4();
      return value2;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
    const exit3 = state.enter("codeFenced");
    let value = tracker.move(sequence);
    if (node2.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value += tracker.move(
        state.safe(node2.lang, {
          before: value,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node2.lang && node2.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value += tracker.move(" ");
      value += tracker.move(
        state.safe(node2.meta, {
          before: value,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw2) {
      value += tracker.move(raw2 + "\n");
    }
    value += tracker.move(sequence);
    exit3();
    return value;
  }
  function map2(line, _, blank) {
    return (blank ? "" : "    ") + line;
  }
  var init_code = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/code.js"() {
      init_longest_streak();
      init_format_code_as_indented();
      init_check_fence();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-quote.js
  function checkQuote(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }
  var init_check_quote = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-quote.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/definition.js
  function definition2(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    value += tracker.move(
      state.safe(state.associationId(node2), {
        before: value,
        after: "]",
        ...tracker.current()
      })
    );
    value += tracker.move("]: ");
    subexit();
    if (
      // If thereâ€™s no url, orâ€¦
      !node2.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    exit3();
    return value;
  }
  var init_definition2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/definition.js"() {
      init_check_quote();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
  function checkEmphasis(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  var init_check_emphasis = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
  function encodeCharacterReference(code4) {
    return "&#x" + code4.toString(16).toUpperCase() + ";";
  }
  var init_encode_character_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/encode-info.js
  function encodeInfo(outside, inside, marker) {
    const outsideKind = classifyCharacter(outside);
    const insideKind = classifyCharacter(inside);
    if (outsideKind === void 0) {
      return insideKind === void 0 ? (
        // Letter inside:
        // we have to encode *both* letters for `_` as it is looser.
        // it already forms for `*` (and GFMs `~`).
        marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (letter, whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: encode outer (letter)
        { inside: false, outside: true }
      );
    }
    if (outsideKind === 1) {
      return insideKind === void 0 ? (
        // Letter inside: already forms.
        { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: already forms.
        { inside: false, outside: false }
      );
    }
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: true, outside: false }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  var init_encode_info = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/encode-info.js"() {
      init_micromark_util_classify_character();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
  function emphasis(node2, _, state, info) {
    const marker = checkEmphasis(state);
    const exit3 = state.enter("emphasis");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker);
    let between = tracker.move(
      state.containerPhrasing(node2, {
        after: marker,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between.charCodeAt(0);
    const open2 = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker
    );
    if (open2.inside) {
      between = encodeCharacterReference(betweenHead) + between.slice(1);
    }
    const betweenTail = between.charCodeAt(between.length - 1);
    const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
    if (close2.inside) {
      between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close2.outside,
      before: open2.outside
    };
    return before + between + after;
  }
  function emphasisPeek(_, _1, state) {
    return state.options.emphasis || "*";
  }
  var init_emphasis = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/emphasis.js"() {
      init_check_emphasis();
      init_encode_character_reference();
      init_encode_info();
      emphasis.peek = emphasisPeek;
    }
  });

  // node_modules/unist-util-visit/lib/index.js
  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test;
    let visitor;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test = void 0;
      visitor = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test = testOrVisitor;
      visitor = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      const index2 = parent ? parent.children.indexOf(node2) : void 0;
      return visitor(node2, index2, parent);
    }
  }
  var init_lib15 = __esm({
    "node_modules/unist-util-visit/lib/index.js"() {
      init_unist_util_visit_parents();
      init_unist_util_visit_parents();
    }
  });

  // node_modules/unist-util-visit/index.js
  var init_unist_util_visit = __esm({
    "node_modules/unist-util-visit/index.js"() {
      init_lib15();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
  function formatHeadingAsSetext(node2, state) {
    let literalWithBreak = false;
    visit(node2, function(node3) {
      if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
        literalWithBreak = true;
        return EXIT;
      }
    });
    return Boolean(
      (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
    );
  }
  var init_format_heading_as_setext = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js"() {
      init_unist_util_visit();
      init_mdast_util_to_string();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/heading.js
  function heading(node2, _, state, info) {
    const rank = Math.max(Math.min(6, node2.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node2, state)) {
      const exit4 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value2 = state.containerPhrasing(node2, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit4();
      return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole sizeâ€¦
        value2.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)â€¦
        (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit3 = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value = state.containerPhrasing(node2, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value)) {
      value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
    }
    value = value ? sequence + " " + value : sequence;
    if (state.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit3();
    return value;
  }
  var init_heading = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/heading.js"() {
      init_encode_character_reference();
      init_format_heading_as_setext();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/html.js
  function html(node2) {
    return node2.value || "";
  }
  function htmlPeek() {
    return "<";
  }
  var init_html = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/html.js"() {
      html.peek = htmlPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/image.js
  function image(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    value += tracker.move(
      state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If thereâ€™s no url but there is a titleâ€¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function imagePeek() {
    return "!";
  }
  var init_image = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/image.js"() {
      init_check_quote();
      image.peek = imagePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
  function imageReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit3 = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    const alt = state.safe(node2.alt, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(alt + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !alt || alt !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }
  var init_image_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/image-reference.js"() {
      imageReference.peek = imageReferencePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
  function inlineCode(node2, _, state) {
    let value = node2.value || "";
    let sequence = "`";
    let index2 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
      value = " " + value + " ";
    }
    while (++index2 < state.unsafe.length) {
      const pattern = state.unsafe[index2];
      const expression = state.compilePattern(pattern);
      let match;
      if (!pattern.atBreak) continue;
      while (match = expression.exec(value)) {
        let position3 = match.index;
        if (value.charCodeAt(position3) === 10 && value.charCodeAt(position3 - 1) === 13) {
          position3--;
        }
        value = value.slice(0, position3) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }
  var init_inline_code = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"() {
      inlineCode.peek = inlineCodePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
  function formatLinkAsAutolink(node2, state) {
    const raw2 = toString(node2);
    return Boolean(
      !state.options.resourceLink && // If thereâ€™s a urlâ€¦
      node2.url && // And thereâ€™s a no titleâ€¦
      !node2.title && // And the content of `node` is a single text nodeâ€¦
      node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the contentâ€¦
      (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocolâ€¦
      /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
      // references donâ€™t work), space, or angle bracketsâ€¦
      !/[\0- <>\u007F]/.test(node2.url)
    );
  }
  var init_format_link_as_autolink = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js"() {
      init_mdast_util_to_string();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/link.js
  function link(node2, _, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit3;
    let subexit;
    if (formatLinkAsAutolink(node2, state)) {
      const stack = state.stack;
      state.stack = [];
      exit3 = state.enter("autolink");
      let value2 = tracker.move("<");
      value2 += tracker.move(
        state.containerPhrasing(node2, {
          before: value2,
          after: ">",
          ...tracker.current()
        })
      );
      value2 += tracker.move(">");
      exit3();
      state.stack = stack;
      return value2;
    }
    exit3 = state.enter("link");
    subexit = state.enter("label");
    let value = tracker.move("[");
    value += tracker.move(
      state.containerPhrasing(node2, {
        before: value,
        after: "](",
        ...tracker.current()
      })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If thereâ€™s no url but there is a titleâ€¦
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function linkPeek(node2, _, state) {
    return formatLinkAsAutolink(node2, state) ? "<" : "[";
  }
  var init_link = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/link.js"() {
      init_check_quote();
      init_format_link_as_autolink();
      link.peek = linkPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
  function linkReference(node2, _, state, info) {
    const type = node2.referenceType;
    const exit3 = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    const text10 = state.containerPhrasing(node2, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(text10 + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !text10 || text10 !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }
  var init_link_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/link-reference.js"() {
      linkReference.peek = linkReferencePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
  function checkBullet(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }
  var init_check_bullet = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }
  var init_check_bullet_other = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js"() {
      init_check_bullet();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
  function checkBulletOrdered(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }
  var init_check_bullet_ordered = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-rule.js
  function checkRule(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }
  var init_check_rule = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-rule.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/list.js
  function list2(node2, parent, state, info) {
    const exit3 = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
    let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
    if (!node2.ordered) {
      const firstListItem = node2.children ? node2.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index2 = -1;
        while (++index2 < node2.children.length) {
          const item = node2.children[index2];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value = state.containerFlow(node2, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit3();
    return value;
  }
  var init_list2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/list.js"() {
      init_check_bullet();
      init_check_bullet_other();
      init_check_bullet_ordered();
      init_check_rule();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
  function checkListItemIndent(state) {
    const style2 = state.options.listItemIndent || "one";
    if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style2;
  }
  var init_check_list_item_indent = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/list-item.js
  function listItem(node2, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
    }
    let size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size - bullet.length));
    tracker.shift(size);
    const exit3 = state.enter("listItem");
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map3
    );
    exit3();
    return value;
    function map3(line, index2, blank) {
      if (index2) {
        return (blank ? "" : " ".repeat(size)) + line;
      }
      return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
    }
  }
  var init_list_item = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/list-item.js"() {
      init_check_bullet();
      init_check_list_item_indent();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
  function paragraph(node2, _, state, info) {
    const exit3 = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, info);
    subexit();
    exit3();
    return value;
  }
  var init_paragraph = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/paragraph.js"() {
    }
  });

  // node_modules/mdast-util-phrasing/lib/index.js
  var phrasing;
  var init_lib16 = __esm({
    "node_modules/mdast-util-phrasing/lib/index.js"() {
      init_unist_util_is();
      phrasing = /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
      convert([
        "break",
        "delete",
        "emphasis",
        // To do: next major: removed since footnotes were added to GFM.
        "footnote",
        "footnoteReference",
        "image",
        "imageReference",
        "inlineCode",
        // Enabled by `mdast-util-math`:
        "inlineMath",
        "link",
        "linkReference",
        // Enabled by `mdast-util-mdx`:
        "mdxJsxTextElement",
        // Enabled by `mdast-util-mdx`:
        "mdxTextExpression",
        "strong",
        "text",
        // Enabled by `mdast-util-directive`:
        "textDirective"
      ]);
    }
  });

  // node_modules/mdast-util-phrasing/index.js
  var init_mdast_util_phrasing = __esm({
    "node_modules/mdast-util-phrasing/index.js"() {
      init_lib16();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/root.js
  function root(node2, _, state, info) {
    const hasPhrasing = node2.children.some(function(d) {
      return phrasing(d);
    });
    const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return container.call(state, node2, info);
  }
  var init_root = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/root.js"() {
      init_mdast_util_phrasing();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-strong.js
  function checkStrong(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  var init_check_strong = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-strong.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/strong.js
  function strong(node2, _, state, info) {
    const marker = checkStrong(state);
    const exit3 = state.enter("strong");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker + marker);
    let between = tracker.move(
      state.containerPhrasing(node2, {
        after: marker,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between.charCodeAt(0);
    const open2 = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker
    );
    if (open2.inside) {
      between = encodeCharacterReference(betweenHead) + between.slice(1);
    }
    const betweenTail = between.charCodeAt(between.length - 1);
    const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
    if (close2.inside) {
      between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker + marker);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close2.outside,
      before: open2.outside
    };
    return before + between + after;
  }
  function strongPeek(_, _1, state) {
    return state.options.strong || "*";
  }
  var init_strong = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/strong.js"() {
      init_check_strong();
      init_encode_character_reference();
      init_encode_info();
      strong.peek = strongPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/text.js
  function text3(node2, _, state, info) {
    return state.safe(node2.value, info);
  }
  var init_text2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/text.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }
  var init_check_rule_repetition = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
  function thematicBreak2(_, _1, state) {
    const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value.slice(0, -1) : value;
  }
  var init_thematic_break2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js"() {
      init_check_rule_repetition();
      init_check_rule();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/index.js
  var handle;
  var init_handle = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/index.js"() {
      init_blockquote();
      init_break();
      init_code();
      init_definition2();
      init_emphasis();
      init_heading();
      init_html();
      init_image();
      init_image_reference();
      init_inline_code();
      init_link();
      init_link_reference();
      init_list2();
      init_list_item();
      init_paragraph();
      init_root();
      init_strong();
      init_text2();
      init_thematic_break2();
      handle = {
        blockquote,
        break: hardBreak,
        code,
        definition: definition2,
        emphasis,
        hardBreak,
        heading,
        html,
        image,
        imageReference,
        inlineCode,
        link,
        linkReference,
        list: list2,
        listItem,
        paragraph,
        root,
        strong,
        text: text3,
        thematicBreak: thematicBreak2
      };
    }
  });

  // node_modules/mdast-util-to-markdown/index.js
  var init_mdast_util_to_markdown = __esm({
    "node_modules/mdast-util-to-markdown/index.js"() {
      init_handle();
    }
  });

  // node_modules/mdast-util-gfm-table/lib/index.js
  function gfmTableFromMarkdown() {
    return {
      enter: {
        table: enterTable,
        tableData: enterCell,
        tableHeader: enterCell,
        tableRow: enterRow
      },
      exit: {
        codeText: exitCodeText,
        table: exitTable,
        tableData: exit2,
        tableHeader: exit2,
        tableRow: exit2
      }
    };
  }
  function enterTable(token) {
    const align = token._align;
    ok(align, "expected `_align` on table");
    this.enter(
      {
        type: "table",
        align: align.map(function(d) {
          return d === "none" ? null : d;
        }),
        children: []
      },
      token
    );
    this.data.inTable = true;
  }
  function exitTable(token) {
    this.exit(token);
    this.data.inTable = void 0;
  }
  function enterRow(token) {
    this.enter({ type: "tableRow", children: [] }, token);
  }
  function exit2(token) {
    this.exit(token);
  }
  function enterCell(token) {
    this.enter({ type: "tableCell", children: [] }, token);
  }
  function exitCodeText(token) {
    let value = this.resume();
    if (this.data.inTable) {
      value = value.replace(/\\([\\|])/g, replace);
    }
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "inlineCode");
    node2.value = value;
    this.exit(token);
  }
  function replace($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
  function gfmTableToMarkdown(options) {
    const settings = options || {};
    const padding = settings.tableCellPadding;
    const alignDelimiters = settings.tablePipeAlign;
    const stringLength = settings.stringLength;
    const around = padding ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: "\n", inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: true, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: true, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: true, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: inlineCodeWithTable,
        table: handleTable,
        tableCell: handleTableCell,
        tableRow: handleTableRow
      }
    };
    function handleTable(node2, _, state, info) {
      return serializeData(handleTableAsData(node2, state, info), node2.align);
    }
    function handleTableRow(node2, _, state, info) {
      const row2 = handleTableRowAsData(node2, state, info);
      const value = serializeData([row2]);
      return value.slice(0, value.indexOf("\n"));
    }
    function handleTableCell(node2, _, state, info) {
      const exit3 = state.enter("tableCell");
      const subexit = state.enter("phrasing");
      const value = state.containerPhrasing(node2, {
        ...info,
        before: around,
        after: around
      });
      subexit();
      exit3();
      return value;
    }
    function serializeData(matrix, align) {
      return markdownTable(matrix, {
        align,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength
      });
    }
    function handleTableAsData(node2, state, info) {
      const children2 = node2.children;
      let index2 = -1;
      const result = [];
      const subexit = state.enter("table");
      while (++index2 < children2.length) {
        result[index2] = handleTableRowAsData(children2[index2], state, info);
      }
      subexit();
      return result;
    }
    function handleTableRowAsData(node2, state, info) {
      const children2 = node2.children;
      let index2 = -1;
      const result = [];
      const subexit = state.enter("tableRow");
      while (++index2 < children2.length) {
        result[index2] = handleTableCell(children2[index2], node2, state, info);
      }
      subexit();
      return result;
    }
    function inlineCodeWithTable(node2, parent, state) {
      let value = handle.inlineCode(node2, parent, state);
      if (state.stack.includes("tableCell")) {
        value = value.replace(/\|/g, "\\$&");
      }
      return value;
    }
  }
  var init_lib17 = __esm({
    "node_modules/mdast-util-gfm-table/lib/index.js"() {
      init_default();
      init_markdown_table();
      init_mdast_util_to_markdown();
    }
  });

  // node_modules/mdast-util-gfm-table/index.js
  var init_mdast_util_gfm_table = __esm({
    "node_modules/mdast-util-gfm-table/index.js"() {
      init_lib17();
    }
  });

  // node_modules/mdast-util-gfm-task-list-item/lib/index.js
  function gfmTaskListItemFromMarkdown() {
    return {
      exit: {
        taskListCheckValueChecked: exitCheck,
        taskListCheckValueUnchecked: exitCheck,
        paragraph: exitParagraphWithTaskListItem
      }
    };
  }
  function gfmTaskListItemToMarkdown() {
    return {
      unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
      handlers: { listItem: listItemWithTaskListItem }
    };
  }
  function exitCheck(token) {
    const node2 = this.stack[this.stack.length - 2];
    ok(node2.type === "listItem");
    node2.checked = token.type === "taskListCheckValueChecked";
  }
  function exitParagraphWithTaskListItem(token) {
    const parent = this.stack[this.stack.length - 2];
    if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
      const node2 = this.stack[this.stack.length - 1];
      ok(node2.type === "paragraph");
      const head2 = node2.children[0];
      if (head2 && head2.type === "text") {
        const siblings2 = parent.children;
        let index2 = -1;
        let firstParaghraph;
        while (++index2 < siblings2.length) {
          const sibling = siblings2[index2];
          if (sibling.type === "paragraph") {
            firstParaghraph = sibling;
            break;
          }
        }
        if (firstParaghraph === node2) {
          head2.value = head2.value.slice(1);
          if (head2.value.length === 0) {
            node2.children.shift();
          } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
            head2.position.start.column++;
            head2.position.start.offset++;
            node2.position.start = Object.assign({}, head2.position.start);
          }
        }
      }
    }
    this.exit(token);
  }
  function listItemWithTaskListItem(node2, parent, state, info) {
    const head2 = node2.children[0];
    const checkable = typeof node2.checked === "boolean" && head2 && head2.type === "paragraph";
    const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
    const tracker = state.createTracker(info);
    if (checkable) {
      tracker.move(checkbox);
    }
    let value = handle.listItem(node2, parent, state, {
      ...info,
      ...tracker.current()
    });
    if (checkable) {
      value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    function check($0) {
      return $0 + checkbox;
    }
  }
  var init_lib18 = __esm({
    "node_modules/mdast-util-gfm-task-list-item/lib/index.js"() {
      init_default();
      init_mdast_util_to_markdown();
    }
  });

  // node_modules/mdast-util-gfm-task-list-item/index.js
  var init_mdast_util_gfm_task_list_item = __esm({
    "node_modules/mdast-util-gfm-task-list-item/index.js"() {
      init_lib18();
    }
  });

  // node_modules/mdast-util-gfm/lib/index.js
  function gfmFromMarkdown() {
    return [
      gfmAutolinkLiteralFromMarkdown(),
      gfmFootnoteFromMarkdown(),
      gfmStrikethroughFromMarkdown(),
      gfmTableFromMarkdown(),
      gfmTaskListItemFromMarkdown()
    ];
  }
  function gfmToMarkdown(options) {
    return {
      extensions: [
        gfmAutolinkLiteralToMarkdown(),
        gfmFootnoteToMarkdown(options),
        gfmStrikethroughToMarkdown(),
        gfmTableToMarkdown(options),
        gfmTaskListItemToMarkdown()
      ]
    };
  }
  var init_lib19 = __esm({
    "node_modules/mdast-util-gfm/lib/index.js"() {
      init_mdast_util_gfm_autolink_literal();
      init_mdast_util_gfm_footnote();
      init_mdast_util_gfm_strikethrough();
      init_mdast_util_gfm_table();
      init_mdast_util_gfm_task_list_item();
    }
  });

  // node_modules/mdast-util-gfm/index.js
  var init_mdast_util_gfm = __esm({
    "node_modules/mdast-util-gfm/index.js"() {
      init_lib19();
    }
  });

  // node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
  function gfmAutolinkLiteral() {
    return {
      text: text4
    };
  }
  function tokenizeEmailAutolink(effects, ok3, nok) {
    const self2 = this;
    let dot;
    let data;
    return start;
    function start(code4) {
      if (!gfmAtext(code4) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code4);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkEmail");
      return atext(code4);
    }
    function atext(code4) {
      if (gfmAtext(code4)) {
        effects.consume(code4);
        return atext;
      }
      if (code4 === 64) {
        effects.consume(code4);
        return emailDomain;
      }
      return nok(code4);
    }
    function emailDomain(code4) {
      if (code4 === 46) {
        return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code4);
      }
      if (code4 === 45 || code4 === 95 || asciiAlphanumeric(code4)) {
        data = true;
        effects.consume(code4);
        return emailDomain;
      }
      return emailDomainAfter(code4);
    }
    function emailDomainDot(code4) {
      effects.consume(code4);
      dot = true;
      return emailDomain;
    }
    function emailDomainAfter(code4) {
      if (data && dot && asciiAlpha(self2.previous)) {
        effects.exit("literalAutolinkEmail");
        effects.exit("literalAutolink");
        return ok3(code4);
      }
      return nok(code4);
    }
  }
  function tokenizeWwwAutolink(effects, ok3, nok) {
    const self2 = this;
    return wwwStart;
    function wwwStart(code4) {
      if (code4 !== 87 && code4 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code4);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkWww");
      return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code4);
    }
    function wwwAfter(code4) {
      effects.exit("literalAutolinkWww");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
  }
  function tokenizeProtocolAutolink(effects, ok3, nok) {
    const self2 = this;
    let buffer = "";
    let seen = false;
    return protocolStart;
    function protocolStart(code4) {
      if ((code4 === 72 || code4 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        buffer += String.fromCodePoint(code4);
        effects.consume(code4);
        return protocolPrefixInside;
      }
      return nok(code4);
    }
    function protocolPrefixInside(code4) {
      if (asciiAlpha(code4) && buffer.length < 5) {
        buffer += String.fromCodePoint(code4);
        effects.consume(code4);
        return protocolPrefixInside;
      }
      if (code4 === 58) {
        const protocol = buffer.toLowerCase();
        if (protocol === "http" || protocol === "https") {
          effects.consume(code4);
          return protocolSlashesInside;
        }
      }
      return nok(code4);
    }
    function protocolSlashesInside(code4) {
      if (code4 === 47) {
        effects.consume(code4);
        if (seen) {
          return afterProtocol;
        }
        seen = true;
        return protocolSlashesInside;
      }
      return nok(code4);
    }
    function afterProtocol(code4) {
      return code4 === null || asciiControl(code4) || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || unicodePunctuation(code4) ? nok(code4) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code4);
    }
    function protocolAfter(code4) {
      effects.exit("literalAutolinkHttp");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
  }
  function tokenizeWwwPrefix(effects, ok3, nok) {
    let size = 0;
    return wwwPrefixInside;
    function wwwPrefixInside(code4) {
      if ((code4 === 87 || code4 === 119) && size < 3) {
        size++;
        effects.consume(code4);
        return wwwPrefixInside;
      }
      if (code4 === 46 && size === 3) {
        effects.consume(code4);
        return wwwPrefixAfter;
      }
      return nok(code4);
    }
    function wwwPrefixAfter(code4) {
      return code4 === null ? nok(code4) : ok3(code4);
    }
  }
  function tokenizeDomain(effects, ok3, nok) {
    let underscoreInLastSegment;
    let underscoreInLastLastSegment;
    let seen;
    return domainInside;
    function domainInside(code4) {
      if (code4 === 46 || code4 === 95) {
        return effects.check(trail, domainAfter, domainAtPunctuation)(code4);
      }
      if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== 45 && unicodePunctuation(code4)) {
        return domainAfter(code4);
      }
      seen = true;
      effects.consume(code4);
      return domainInside;
    }
    function domainAtPunctuation(code4) {
      if (code4 === 95) {
        underscoreInLastSegment = true;
      } else {
        underscoreInLastLastSegment = underscoreInLastSegment;
        underscoreInLastSegment = void 0;
      }
      effects.consume(code4);
      return domainInside;
    }
    function domainAfter(code4) {
      if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
        return nok(code4);
      }
      return ok3(code4);
    }
  }
  function tokenizePath(effects, ok3) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    function pathInside(code4) {
      if (code4 === 40) {
        sizeOpen++;
        effects.consume(code4);
        return pathInside;
      }
      if (code4 === 41 && sizeClose < sizeOpen) {
        return pathAtPunctuation(code4);
      }
      if (code4 === 33 || code4 === 34 || code4 === 38 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 60 || code4 === 63 || code4 === 93 || code4 === 95 || code4 === 126) {
        return effects.check(trail, ok3, pathAtPunctuation)(code4);
      }
      if (code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
        return ok3(code4);
      }
      effects.consume(code4);
      return pathInside;
    }
    function pathAtPunctuation(code4) {
      if (code4 === 41) {
        sizeClose++;
      }
      effects.consume(code4);
      return pathInside;
    }
  }
  function tokenizeTrail(effects, ok3, nok) {
    return trail2;
    function trail2(code4) {
      if (code4 === 33 || code4 === 34 || code4 === 39 || code4 === 41 || code4 === 42 || code4 === 44 || code4 === 46 || code4 === 58 || code4 === 59 || code4 === 63 || code4 === 95 || code4 === 126) {
        effects.consume(code4);
        return trail2;
      }
      if (code4 === 38) {
        effects.consume(code4);
        return trailCharacterReferenceStart;
      }
      if (code4 === 93) {
        effects.consume(code4);
        return trailBracketAfter;
      }
      if (
        // `<` is an end.
        code4 === 60 || // So is whitespace.
        code4 === null || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)
      ) {
        return ok3(code4);
      }
      return nok(code4);
    }
    function trailBracketAfter(code4) {
      if (code4 === null || code4 === 40 || code4 === 91 || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
        return ok3(code4);
      }
      return trail2(code4);
    }
    function trailCharacterReferenceStart(code4) {
      return asciiAlpha(code4) ? trailCharacterReferenceInside(code4) : nok(code4);
    }
    function trailCharacterReferenceInside(code4) {
      if (code4 === 59) {
        effects.consume(code4);
        return trail2;
      }
      if (asciiAlpha(code4)) {
        effects.consume(code4);
        return trailCharacterReferenceInside;
      }
      return nok(code4);
    }
  }
  function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
    return start;
    function start(code4) {
      effects.consume(code4);
      return after;
    }
    function after(code4) {
      return asciiAlphanumeric(code4) ? nok(code4) : ok3(code4);
    }
  }
  function previousWww(code4) {
    return code4 === null || code4 === 40 || code4 === 42 || code4 === 95 || code4 === 91 || code4 === 93 || code4 === 126 || markdownLineEndingOrSpace(code4);
  }
  function previousProtocol(code4) {
    return !asciiAlpha(code4);
  }
  function previousEmail(code4) {
    return !(code4 === 47 || gfmAtext(code4));
  }
  function gfmAtext(code4) {
    return code4 === 43 || code4 === 45 || code4 === 46 || code4 === 95 || asciiAlphanumeric(code4);
  }
  function previousUnbalanced(events) {
    let index2 = events.length;
    let result = false;
    while (index2--) {
      const token = events[index2][1];
      if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
        result = true;
        break;
      }
      if (token._gfmAutolinkLiteralWalkedInto) {
        result = false;
        break;
      }
    }
    if (events.length > 0 && !result) {
      events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
  }
  var wwwPrefix, domain, path, trail, emailDomainDotTrail, wwwAutolink, protocolAutolink, emailAutolink, text4, code2;
  var init_syntax = __esm({
    "node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"() {
      init_micromark_util_character();
      wwwPrefix = {
        tokenize: tokenizeWwwPrefix,
        partial: true
      };
      domain = {
        tokenize: tokenizeDomain,
        partial: true
      };
      path = {
        tokenize: tokenizePath,
        partial: true
      };
      trail = {
        tokenize: tokenizeTrail,
        partial: true
      };
      emailDomainDotTrail = {
        tokenize: tokenizeEmailDomainDotTrail,
        partial: true
      };
      wwwAutolink = {
        name: "wwwAutolink",
        tokenize: tokenizeWwwAutolink,
        previous: previousWww
      };
      protocolAutolink = {
        name: "protocolAutolink",
        tokenize: tokenizeProtocolAutolink,
        previous: previousProtocol
      };
      emailAutolink = {
        name: "emailAutolink",
        tokenize: tokenizeEmailAutolink,
        previous: previousEmail
      };
      text4 = {};
      code2 = 48;
      while (code2 < 123) {
        text4[code2] = emailAutolink;
        code2++;
        if (code2 === 58) code2 = 65;
        else if (code2 === 91) code2 = 97;
      }
      text4[43] = emailAutolink;
      text4[45] = emailAutolink;
      text4[46] = emailAutolink;
      text4[95] = emailAutolink;
      text4[72] = [emailAutolink, protocolAutolink];
      text4[104] = [emailAutolink, protocolAutolink];
      text4[87] = [emailAutolink, wwwAutolink];
      text4[119] = [emailAutolink, wwwAutolink];
    }
  });

  // node_modules/micromark-extension-gfm-autolink-literal/index.js
  var init_micromark_extension_gfm_autolink_literal = __esm({
    "node_modules/micromark-extension-gfm-autolink-literal/index.js"() {
      init_syntax();
    }
  });

  // node_modules/micromark-extension-gfm-footnote/lib/syntax.js
  function gfmFootnote() {
    return {
      document: {
        [91]: {
          name: "gfmFootnoteDefinition",
          tokenize: tokenizeDefinitionStart,
          continuation: {
            tokenize: tokenizeDefinitionContinuation
          },
          exit: gfmFootnoteDefinitionEnd
        }
      },
      text: {
        [91]: {
          name: "gfmFootnoteCall",
          tokenize: tokenizeGfmFootnoteCall
        },
        [93]: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: tokenizePotentialGfmFootnoteCall,
          resolveTo: resolveToPotentialGfmFootnoteCall
        }
      }
    };
  }
  function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    let index2 = self2.events.length;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let labelStart;
    while (index2--) {
      const token = self2.events[index2][1];
      if (token.type === "labelImage") {
        labelStart = token;
        break;
      }
      if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
        break;
      }
    }
    return start;
    function start(code4) {
      if (!labelStart || !labelStart._balanced) {
        return nok(code4);
      }
      const id = normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      }));
      if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
        return nok(code4);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      return ok3(code4);
    }
  }
  function resolveToPotentialGfmFootnoteCall(events, context) {
    let index2 = events.length;
    let labelStart;
    while (index2--) {
      if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
        labelStart = events[index2][1];
        break;
      }
    }
    events[index2 + 1][1].type = "data";
    events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
    const call = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, events[index2 + 3][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const marker = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, events[index2 + 3][1].end),
      end: Object.assign({}, events[index2 + 3][1].end)
    };
    marker.end.column++;
    marker.end.offset++;
    marker.end._bufferIndex++;
    const string3 = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, marker.end),
      end: Object.assign({}, events[events.length - 1][1].start)
    };
    const chunk = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, string3.start),
      end: Object.assign({}, string3.end)
    };
    const replacement = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      events[index2 + 1],
      events[index2 + 2],
      ["enter", call, context],
      // The `[`
      events[index2 + 3],
      events[index2 + 4],
      // The `^`.
      ["enter", marker, context],
      ["exit", marker, context],
      // Everything in between.
      ["enter", string3, context],
      ["enter", chunk, context],
      ["exit", chunk, context],
      ["exit", string3, context],
      // The ending (`]`, properly parsed and labelled).
      events[events.length - 2],
      events[events.length - 1],
      ["exit", call, context]
    ];
    events.splice(index2, events.length - index2 + 1, ...replacement);
    return events;
  }
  function tokenizeGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let size = 0;
    let data;
    return start;
    function start(code4) {
      effects.enter("gfmFootnoteCall");
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      return callStart;
    }
    function callStart(code4) {
      if (code4 !== 94) return nok(code4);
      effects.enter("gfmFootnoteCallMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallMarker");
      effects.enter("gfmFootnoteCallString");
      effects.enter("chunkString").contentType = "string";
      return callData;
    }
    function callData(code4) {
      if (
        // Too long.
        size > 999 || // Closing brace with nothing.
        code4 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
      ) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteCallString");
        if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
          return nok(code4);
        }
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteCallLabelMarker");
        effects.exit("gfmFootnoteCall");
        return ok3;
      }
      if (!markdownLineEndingOrSpace(code4)) {
        data = true;
      }
      size++;
      effects.consume(code4);
      return code4 === 92 ? callEscape : callData;
    }
    function callEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size++;
        return callData;
      }
      return callData(code4);
    }
  }
  function tokenizeDefinitionStart(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let identifier;
    let size = 0;
    let data;
    return start;
    function start(code4) {
      effects.enter("gfmFootnoteDefinition")._container = true;
      effects.enter("gfmFootnoteDefinitionLabel");
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      return labelAtMarker;
    }
    function labelAtMarker(code4) {
      if (code4 === 94) {
        effects.enter("gfmFootnoteDefinitionMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteDefinitionMarker");
        effects.enter("gfmFootnoteDefinitionLabelString");
        effects.enter("chunkString").contentType = "string";
        return labelInside;
      }
      return nok(code4);
    }
    function labelInside(code4) {
      if (
        // Too long.
        size > 999 || // Closing brace with nothing.
        code4 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code4 === null || code4 === 91 || markdownLineEndingOrSpace(code4)
      ) {
        return nok(code4);
      }
      if (code4 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteDefinitionLabelString");
        identifier = normalizeIdentifier(self2.sliceSerialize(token));
        effects.enter("gfmFootnoteDefinitionLabelMarker");
        effects.consume(code4);
        effects.exit("gfmFootnoteDefinitionLabelMarker");
        effects.exit("gfmFootnoteDefinitionLabel");
        return labelAfter;
      }
      if (!markdownLineEndingOrSpace(code4)) {
        data = true;
      }
      size++;
      effects.consume(code4);
      return code4 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code4) {
      if (code4 === 91 || code4 === 92 || code4 === 93) {
        effects.consume(code4);
        size++;
        return labelInside;
      }
      return labelInside(code4);
    }
    function labelAfter(code4) {
      if (code4 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code4);
        effects.exit("definitionMarker");
        if (!defined.includes(identifier)) {
          defined.push(identifier);
        }
        return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
      }
      return nok(code4);
    }
    function whitespaceAfter(code4) {
      return ok3(code4);
    }
  }
  function tokenizeDefinitionContinuation(effects, ok3, nok) {
    return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
  }
  function gfmFootnoteDefinitionEnd(effects) {
    effects.exit("gfmFootnoteDefinition");
  }
  function tokenizeIndent2(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
    function afterPrefix(code4) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code4) : nok(code4);
    }
  }
  var indent;
  var init_syntax2 = __esm({
    "node_modules/micromark-extension-gfm-footnote/lib/syntax.js"() {
      init_micromark_core_commonmark();
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_normalize_identifier();
      indent = {
        tokenize: tokenizeIndent2,
        partial: true
      };
    }
  });

  // node_modules/micromark-extension-gfm-footnote/index.js
  var init_micromark_extension_gfm_footnote = __esm({
    "node_modules/micromark-extension-gfm-footnote/index.js"() {
      init_syntax2();
    }
  });

  // node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
  function gfmStrikethrough(options) {
    const options_ = options || {};
    let single = options_.singleTilde;
    const tokenizer = {
      name: "strikethrough",
      tokenize: tokenizeStrikethrough,
      resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === void 0) {
      single = true;
    }
    return {
      text: {
        [126]: tokenizer
      },
      insideSpan: {
        null: [tokenizer]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function resolveAllStrikethrough(events, context) {
      let index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
          let open2 = index2;
          while (open2--) {
            if (events[open2][0] === "exit" && events[open2][1].type === "strikethroughSequenceTemporary" && events[open2][1]._open && // If the sizes are the same:
            events[index2][1].end.offset - events[index2][1].start.offset === events[open2][1].end.offset - events[open2][1].start.offset) {
              events[index2][1].type = "strikethroughSequence";
              events[open2][1].type = "strikethroughSequence";
              const strikethrough2 = {
                type: "strikethrough",
                start: Object.assign({}, events[open2][1].start),
                end: Object.assign({}, events[index2][1].end)
              };
              const text10 = {
                type: "strikethroughText",
                start: Object.assign({}, events[open2][1].end),
                end: Object.assign({}, events[index2][1].start)
              };
              const nextEvents = [["enter", strikethrough2, context], ["enter", events[open2][1], context], ["exit", events[open2][1], context], ["enter", text10, context]];
              const insideSpan2 = context.parser.constructs.insideSpan.null;
              if (insideSpan2) {
                splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open2 + 1, index2), context));
              }
              splice(nextEvents, nextEvents.length, 0, [["exit", text10, context], ["enter", events[index2][1], context], ["exit", events[index2][1], context], ["exit", strikethrough2, context]]);
              splice(events, open2 - 1, index2 - open2 + 3, nextEvents);
              index2 = open2 + nextEvents.length - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "strikethroughSequenceTemporary") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeStrikethrough(effects, ok3, nok) {
      const previous4 = this.previous;
      const events = this.events;
      let size = 0;
      return start;
      function start(code4) {
        if (previous4 === 126 && events[events.length - 1][1].type !== "characterEscape") {
          return nok(code4);
        }
        effects.enter("strikethroughSequenceTemporary");
        return more(code4);
      }
      function more(code4) {
        const before = classifyCharacter(previous4);
        if (code4 === 126) {
          if (size > 1) return nok(code4);
          effects.consume(code4);
          size++;
          return more;
        }
        if (size < 2 && !single) return nok(code4);
        const token = effects.exit("strikethroughSequenceTemporary");
        const after = classifyCharacter(code4);
        token._open = !after || after === 2 && Boolean(before);
        token._close = !before || before === 2 && Boolean(after);
        return ok3(code4);
      }
    }
  }
  var init_syntax3 = __esm({
    "node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"() {
      init_micromark_util_chunked();
      init_micromark_util_classify_character();
      init_micromark_util_resolve_all();
    }
  });

  // node_modules/micromark-extension-gfm-strikethrough/index.js
  var init_micromark_extension_gfm_strikethrough = __esm({
    "node_modules/micromark-extension-gfm-strikethrough/index.js"() {
      init_syntax3();
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/edit-map.js
  function addImplementation(editMap, at, remove, add) {
    let index2 = 0;
    if (remove === 0 && add.length === 0) {
      return;
    }
    while (index2 < editMap.map.length) {
      if (editMap.map[index2][0] === at) {
        editMap.map[index2][1] += remove;
        editMap.map[index2][2].push(...add);
        return;
      }
      index2 += 1;
    }
    editMap.map.push([at, remove, add]);
  }
  var EditMap;
  var init_edit_map = __esm({
    "node_modules/micromark-extension-gfm-table/lib/edit-map.js"() {
      EditMap = class {
        /**
         * Create a new edit map.
         */
        constructor() {
          this.map = [];
        }
        /**
         * Create an edit: a remove and/or add at a certain place.
         *
         * @param {number} index
         * @param {number} remove
         * @param {Array<Event>} add
         * @returns {undefined}
         */
        add(index2, remove, add) {
          addImplementation(this, index2, remove, add);
        }
        // To do: add this when moving to `micromark`.
        // /**
        //  * Create an edit: but insert `add` before existing additions.
        //  *
        //  * @param {number} index
        //  * @param {number} remove
        //  * @param {Array<Event>} add
        //  * @returns {undefined}
        //  */
        // addBefore(index, remove, add) {
        //   addImplementation(this, index, remove, add, true)
        // }
        /**
         * Done, change the events.
         *
         * @param {Array<Event>} events
         * @returns {undefined}
         */
        consume(events) {
          this.map.sort(function(a, b) {
            return a[0] - b[0];
          });
          if (this.map.length === 0) {
            return;
          }
          let index2 = this.map.length;
          const vecs = [];
          while (index2 > 0) {
            index2 -= 1;
            vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]), this.map[index2][2]);
            events.length = this.map[index2][0];
          }
          vecs.push(events.slice());
          events.length = 0;
          let slice = vecs.pop();
          while (slice) {
            for (const element6 of slice) {
              events.push(element6);
            }
            slice = vecs.pop();
          }
          this.map.length = 0;
        }
      };
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/infer.js
  function gfmTableAlign(events, index2) {
    let inDelimiterRow = false;
    const align = [];
    while (index2 < events.length) {
      const event = events[index2];
      if (inDelimiterRow) {
        if (event[0] === "enter") {
          if (event[1].type === "tableContent") {
            align.push(events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
          }
        } else if (event[1].type === "tableContent") {
          if (events[index2 - 1][1].type === "tableDelimiterMarker") {
            const alignIndex = align.length - 1;
            align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
          }
        } else if (event[1].type === "tableDelimiterRow") {
          break;
        }
      } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
        inDelimiterRow = true;
      }
      index2 += 1;
    }
    return align;
  }
  var init_infer = __esm({
    "node_modules/micromark-extension-gfm-table/lib/infer.js"() {
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/syntax.js
  function gfmTable() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: tokenizeTable,
          resolveAll: resolveTable
        }
      }
    };
  }
  function tokenizeTable(effects, ok3, nok) {
    const self2 = this;
    let size = 0;
    let sizeB = 0;
    let seen;
    return start;
    function start(code4) {
      let index2 = self2.events.length - 1;
      while (index2 > -1) {
        const type = self2.events[index2][1].type;
        if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        type === "linePrefix") index2--;
        else break;
      }
      const tail = index2 > -1 ? self2.events[index2][1].type : null;
      const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
      if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      return next(code4);
    }
    function headRowBefore(code4) {
      effects.enter("tableHead");
      effects.enter("tableRow");
      return headRowStart(code4);
    }
    function headRowStart(code4) {
      if (code4 === 124) {
        return headRowBreak(code4);
      }
      seen = true;
      sizeB += 1;
      return headRowBreak(code4);
    }
    function headRowBreak(code4) {
      if (code4 === null) {
        return nok(code4);
      }
      if (markdownLineEnding(code4)) {
        if (sizeB > 1) {
          sizeB = 0;
          self2.interrupt = true;
          effects.exit("tableRow");
          effects.enter("lineEnding");
          effects.consume(code4);
          effects.exit("lineEnding");
          return headDelimiterStart;
        }
        return nok(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, headRowBreak, "whitespace")(code4);
      }
      sizeB += 1;
      if (seen) {
        seen = false;
        size += 1;
      }
      if (code4 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        seen = true;
        return headRowBreak;
      }
      effects.enter("data");
      return headRowData(code4);
    }
    function headRowData(code4) {
      if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
        effects.exit("data");
        return headRowBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? headRowEscape : headRowData;
    }
    function headRowEscape(code4) {
      if (code4 === 92 || code4 === 124) {
        effects.consume(code4);
        return headRowData;
      }
      return headRowData(code4);
    }
    function headDelimiterStart(code4) {
      self2.interrupt = false;
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code4);
      }
      effects.enter("tableDelimiterRow");
      seen = false;
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code4);
      }
      return headDelimiterBefore(code4);
    }
    function headDelimiterBefore(code4) {
      if (code4 === 45 || code4 === 58) {
        return headDelimiterValueBefore(code4);
      }
      if (code4 === 124) {
        seen = true;
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        return headDelimiterCellBefore;
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterCellBefore(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code4);
      }
      return headDelimiterValueBefore(code4);
    }
    function headDelimiterValueBefore(code4) {
      if (code4 === 58) {
        sizeB += 1;
        seen = true;
        effects.enter("tableDelimiterMarker");
        effects.consume(code4);
        effects.exit("tableDelimiterMarker");
        return headDelimiterLeftAlignmentAfter;
      }
      if (code4 === 45) {
        sizeB += 1;
        return headDelimiterLeftAlignmentAfter(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        return headDelimiterCellAfter(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterLeftAlignmentAfter(code4) {
      if (code4 === 45) {
        effects.enter("tableDelimiterFiller");
        return headDelimiterFiller(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterFiller(code4) {
      if (code4 === 45) {
        effects.consume(code4);
        return headDelimiterFiller;
      }
      if (code4 === 58) {
        seen = true;
        effects.exit("tableDelimiterFiller");
        effects.enter("tableDelimiterMarker");
        effects.consume(code4);
        effects.exit("tableDelimiterMarker");
        return headDelimiterRightAlignmentAfter;
      }
      effects.exit("tableDelimiterFiller");
      return headDelimiterRightAlignmentAfter(code4);
    }
    function headDelimiterRightAlignmentAfter(code4) {
      if (markdownSpace(code4)) {
        return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code4);
      }
      return headDelimiterCellAfter(code4);
    }
    function headDelimiterCellAfter(code4) {
      if (code4 === 124) {
        return headDelimiterBefore(code4);
      }
      if (code4 === null || markdownLineEnding(code4)) {
        if (!seen || size !== sizeB) {
          return headDelimiterNok(code4);
        }
        effects.exit("tableDelimiterRow");
        effects.exit("tableHead");
        return ok3(code4);
      }
      return headDelimiterNok(code4);
    }
    function headDelimiterNok(code4) {
      return nok(code4);
    }
    function bodyRowStart(code4) {
      effects.enter("tableRow");
      return bodyRowBreak(code4);
    }
    function bodyRowBreak(code4) {
      if (code4 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code4);
        effects.exit("tableCellDivider");
        return bodyRowBreak;
      }
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("tableRow");
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return factorySpace(effects, bodyRowBreak, "whitespace")(code4);
      }
      effects.enter("data");
      return bodyRowData(code4);
    }
    function bodyRowData(code4) {
      if (code4 === null || code4 === 124 || markdownLineEndingOrSpace(code4)) {
        effects.exit("data");
        return bodyRowBreak(code4);
      }
      effects.consume(code4);
      return code4 === 92 ? bodyRowEscape : bodyRowData;
    }
    function bodyRowEscape(code4) {
      if (code4 === 92 || code4 === 124) {
        effects.consume(code4);
        return bodyRowData;
      }
      return bodyRowData(code4);
    }
  }
  function resolveTable(events, context) {
    let index2 = -1;
    let inFirstCellAwaitingPipe = true;
    let rowKind = 0;
    let lastCell = [0, 0, 0, 0];
    let cell2 = [0, 0, 0, 0];
    let afterHeadAwaitingFirstBodyRow = false;
    let lastTableEnd = 0;
    let currentTable;
    let currentBody;
    let currentCell;
    const map3 = new EditMap();
    while (++index2 < events.length) {
      const event = events[index2];
      const token = event[1];
      if (event[0] === "enter") {
        if (token.type === "tableHead") {
          afterHeadAwaitingFirstBodyRow = false;
          if (lastTableEnd !== 0) {
            flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
            currentBody = void 0;
            lastTableEnd = 0;
          }
          currentTable = {
            type: "table",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map3.add(index2, 0, [["enter", currentTable, context]]);
        } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
          inFirstCellAwaitingPipe = true;
          currentCell = void 0;
          lastCell = [0, 0, 0, 0];
          cell2 = [0, index2 + 1, 0, 0];
          if (afterHeadAwaitingFirstBodyRow) {
            afterHeadAwaitingFirstBodyRow = false;
            currentBody = {
              type: "tableBody",
              start: Object.assign({}, token.start),
              // Note: correct end is set later.
              end: Object.assign({}, token.end)
            };
            map3.add(index2, 0, [["enter", currentBody, context]]);
          }
          rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
        } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
          inFirstCellAwaitingPipe = false;
          if (cell2[2] === 0) {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(map3, context, lastCell, rowKind, void 0, currentCell);
              lastCell = [0, 0, 0, 0];
            }
            cell2[2] = index2;
          }
        } else if (token.type === "tableCellDivider") {
          if (inFirstCellAwaitingPipe) {
            inFirstCellAwaitingPipe = false;
          } else {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(map3, context, lastCell, rowKind, void 0, currentCell);
            }
            lastCell = cell2;
            cell2 = [lastCell[1], index2, 0, 0];
          }
        }
      } else if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = true;
        lastTableEnd = index2;
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        lastTableEnd = index2;
        if (lastCell[1] !== 0) {
          cell2[0] = cell2[1];
          currentCell = flushCell(map3, context, lastCell, rowKind, index2, currentCell);
        } else if (cell2[1] !== 0) {
          currentCell = flushCell(map3, context, cell2, rowKind, index2, currentCell);
        }
        rowKind = 0;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        cell2[3] = index2;
      }
    }
    if (lastTableEnd !== 0) {
      flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
    }
    map3.consume(context.events);
    index2 = -1;
    while (++index2 < context.events.length) {
      const event = context.events[index2];
      if (event[0] === "enter" && event[1].type === "table") {
        event[1]._align = gfmTableAlign(context.events, index2);
      }
    }
    return events;
  }
  function flushCell(map3, context, range, rowKind, rowEnd, previousCell) {
    const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
    const valueName = "tableContent";
    if (range[0] !== 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
      map3.add(range[0], 0, [["exit", previousCell, context]]);
    }
    const now = getPoint(context.events, range[1]);
    previousCell = {
      type: groupName,
      start: Object.assign({}, now),
      // Note: correct end is set later.
      end: Object.assign({}, now)
    };
    map3.add(range[1], 0, [["enter", previousCell, context]]);
    if (range[2] !== 0) {
      const relatedStart = getPoint(context.events, range[2]);
      const relatedEnd = getPoint(context.events, range[3]);
      const valueToken = {
        type: valueName,
        start: Object.assign({}, relatedStart),
        end: Object.assign({}, relatedEnd)
      };
      map3.add(range[2], 0, [["enter", valueToken, context]]);
      if (rowKind !== 2) {
        const start = context.events[range[2]];
        const end = context.events[range[3]];
        start[1].end = Object.assign({}, end[1].end);
        start[1].type = "chunkText";
        start[1].contentType = "text";
        if (range[3] > range[2] + 1) {
          const a = range[2] + 1;
          const b = range[3] - range[2] - 1;
          map3.add(a, b, []);
        }
      }
      map3.add(range[3] + 1, 0, [["exit", valueToken, context]]);
    }
    if (rowEnd !== void 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
      map3.add(rowEnd, 0, [["exit", previousCell, context]]);
      previousCell = void 0;
    }
    return previousCell;
  }
  function flushTableEnd(map3, context, index2, table2, tableBody) {
    const exits = [];
    const related = getPoint(context.events, index2);
    if (tableBody) {
      tableBody.end = Object.assign({}, related);
      exits.push(["exit", tableBody, context]);
    }
    table2.end = Object.assign({}, related);
    exits.push(["exit", table2, context]);
    map3.add(index2 + 1, 0, exits);
  }
  function getPoint(events, index2) {
    const event = events[index2];
    const side = event[0] === "enter" ? "start" : "end";
    return event[1][side];
  }
  var init_syntax4 = __esm({
    "node_modules/micromark-extension-gfm-table/lib/syntax.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_edit_map();
      init_infer();
    }
  });

  // node_modules/micromark-extension-gfm-table/index.js
  var init_micromark_extension_gfm_table = __esm({
    "node_modules/micromark-extension-gfm-table/index.js"() {
      init_syntax4();
    }
  });

  // node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
  function gfmTaskListItem() {
    return {
      text: {
        [91]: tasklistCheck
      }
    };
  }
  function tokenizeTasklistCheck(effects, ok3, nok) {
    const self2 = this;
    return open2;
    function open2(code4) {
      if (
        // Exit if thereâ€™s stuff before.
        self2.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !self2._gfmTasklistFirstContentOfListItem
      ) {
        return nok(code4);
      }
      effects.enter("taskListCheck");
      effects.enter("taskListCheckMarker");
      effects.consume(code4);
      effects.exit("taskListCheckMarker");
      return inside;
    }
    function inside(code4) {
      if (markdownLineEndingOrSpace(code4)) {
        effects.enter("taskListCheckValueUnchecked");
        effects.consume(code4);
        effects.exit("taskListCheckValueUnchecked");
        return close2;
      }
      if (code4 === 88 || code4 === 120) {
        effects.enter("taskListCheckValueChecked");
        effects.consume(code4);
        effects.exit("taskListCheckValueChecked");
        return close2;
      }
      return nok(code4);
    }
    function close2(code4) {
      if (code4 === 93) {
        effects.enter("taskListCheckMarker");
        effects.consume(code4);
        effects.exit("taskListCheckMarker");
        effects.exit("taskListCheck");
        return after;
      }
      return nok(code4);
    }
    function after(code4) {
      if (markdownLineEnding(code4)) {
        return ok3(code4);
      }
      if (markdownSpace(code4)) {
        return effects.check({
          tokenize: spaceThenNonSpace
        }, ok3, nok)(code4);
      }
      return nok(code4);
    }
  }
  function spaceThenNonSpace(effects, ok3, nok) {
    return factorySpace(effects, after, "whitespace");
    function after(code4) {
      return code4 === null ? nok(code4) : ok3(code4);
    }
  }
  var tasklistCheck;
  var init_syntax5 = __esm({
    "node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      tasklistCheck = {
        name: "tasklistCheck",
        tokenize: tokenizeTasklistCheck
      };
    }
  });

  // node_modules/micromark-extension-gfm-task-list-item/index.js
  var init_micromark_extension_gfm_task_list_item = __esm({
    "node_modules/micromark-extension-gfm-task-list-item/index.js"() {
      init_syntax5();
    }
  });

  // node_modules/micromark-extension-gfm/index.js
  function gfm(options) {
    return combineExtensions([
      gfmAutolinkLiteral(),
      gfmFootnote(),
      gfmStrikethrough(options),
      gfmTable(),
      gfmTaskListItem()
    ]);
  }
  var init_micromark_extension_gfm = __esm({
    "node_modules/micromark-extension-gfm/index.js"() {
      init_micromark_util_combine_extensions();
      init_micromark_extension_gfm_autolink_literal();
      init_micromark_extension_gfm_footnote();
      init_micromark_extension_gfm_strikethrough();
      init_micromark_extension_gfm_table();
      init_micromark_extension_gfm_task_list_item();
    }
  });

  // node_modules/remark-gfm/lib/index.js
  function remarkGfm(options) {
    const self2 = (
      /** @type {Processor<Root>} */
      this
    );
    const settings = options || emptyOptions2;
    const data = self2.data();
    const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
    const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
    const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
    micromarkExtensions.push(gfm(settings));
    fromMarkdownExtensions.push(gfmFromMarkdown());
    toMarkdownExtensions.push(gfmToMarkdown(settings));
  }
  var emptyOptions2;
  var init_lib20 = __esm({
    "node_modules/remark-gfm/lib/index.js"() {
      init_mdast_util_gfm();
      init_micromark_extension_gfm();
      emptyOptions2 = {};
    }
  });

  // node_modules/remark-gfm/index.js
  var init_remark_gfm = __esm({
    "node_modules/remark-gfm/index.js"() {
      init_lib20();
    }
  });

  // node_modules/mdast-util-math/lib/index.js
  function mathFromMarkdown() {
    return {
      enter: {
        mathFlow: enterMathFlow,
        mathFlowFenceMeta: enterMathFlowMeta,
        mathText: enterMathText
      },
      exit: {
        mathFlow: exitMathFlow,
        mathFlowFence: exitMathFlowFence,
        mathFlowFenceMeta: exitMathFlowMeta,
        mathFlowValue: exitMathData,
        mathText: exitMathText,
        mathTextData: exitMathData
      }
    };
    function enterMathFlow(token) {
      const code4 = {
        type: "element",
        tagName: "code",
        properties: { className: ["language-math", "math-display"] },
        children: []
      };
      this.enter(
        {
          type: "math",
          meta: null,
          value: "",
          data: { hName: "pre", hChildren: [code4] }
        },
        token
      );
    }
    function enterMathFlowMeta() {
      this.buffer();
    }
    function exitMathFlowMeta() {
      const data = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      ok(node2.type === "math");
      node2.meta = data;
    }
    function exitMathFlowFence() {
      if (this.data.mathFlowInside) return;
      this.buffer();
      this.data.mathFlowInside = true;
    }
    function exitMathFlow(token) {
      const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      const node2 = this.stack[this.stack.length - 1];
      ok(node2.type === "math");
      this.exit(token);
      node2.value = data;
      const code4 = (
        /** @type {HastElement} */
        node2.data.hChildren[0]
      );
      ok(code4.type === "element");
      ok(code4.tagName === "code");
      code4.children.push({ type: "text", value: data });
      this.data.mathFlowInside = void 0;
    }
    function enterMathText(token) {
      this.enter(
        {
          type: "inlineMath",
          value: "",
          data: {
            hName: "code",
            hProperties: { className: ["language-math", "math-inline"] },
            hChildren: []
          }
        },
        token
      );
      this.buffer();
    }
    function exitMathText(token) {
      const data = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      ok(node2.type === "inlineMath");
      this.exit(token);
      node2.value = data;
      const children2 = (
        /** @type {Array<HastElementContent>} */
        // @ts-expect-error: we defined it in `enterMathFlow`.
        node2.data.hChildren
      );
      children2.push({ type: "text", value: data });
    }
    function exitMathData(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
  }
  function mathToMarkdown(options) {
    let single = (options || {}).singleDollarTextMath;
    if (single === null || single === void 0) {
      single = true;
    }
    inlineMath.peek = inlineMathPeek;
    return {
      unsafe: [
        { character: "\r", inConstruct: "mathFlowMeta" },
        { character: "\n", inConstruct: "mathFlowMeta" },
        {
          character: "$",
          after: single ? void 0 : "\\$",
          inConstruct: "phrasing"
        },
        { character: "$", inConstruct: "mathFlowMeta" },
        { atBreak: true, character: "$", after: "\\$" }
      ],
      handlers: { math: math3, inlineMath }
    };
    function math3(node2, _, state, info) {
      const raw2 = node2.value || "";
      const tracker = state.createTracker(info);
      const sequence = "$".repeat(Math.max(longestStreak(raw2, "$") + 1, 2));
      const exit3 = state.enter("mathFlow");
      let value = tracker.move(sequence);
      if (node2.meta) {
        const subexit = state.enter("mathFlowMeta");
        value += tracker.move(
          state.safe(node2.meta, {
            after: "\n",
            before: value,
            encode: ["$"],
            ...tracker.current()
          })
        );
        subexit();
      }
      value += tracker.move("\n");
      if (raw2) {
        value += tracker.move(raw2 + "\n");
      }
      value += tracker.move(sequence);
      exit3();
      return value;
    }
    function inlineMath(node2, _, state) {
      let value = node2.value || "";
      let size = 1;
      if (!single) size++;
      while (new RegExp("(^|[^$])" + "\\$".repeat(size) + "([^$]|$)").test(value)) {
        size++;
      }
      const sequence = "$".repeat(size);
      if (
        // Contains non-space.
        /[^ \r\n]/.test(value) && // Starts with space and ends with space.
        (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || // Starts or ends with dollar.
        /^\$|\$$/.test(value))
      ) {
        value = " " + value + " ";
      }
      let index2 = -1;
      while (++index2 < state.unsafe.length) {
        const pattern = state.unsafe[index2];
        if (!pattern.atBreak) continue;
        const expression = state.compilePattern(pattern);
        let match;
        while (match = expression.exec(value)) {
          let position3 = match.index;
          if (value.codePointAt(position3) === 10 && value.codePointAt(position3 - 1) === 13) {
            position3--;
          }
          value = value.slice(0, position3) + " " + value.slice(match.index + 1);
        }
      }
      return sequence + value + sequence;
    }
    function inlineMathPeek() {
      return "$";
    }
  }
  var init_lib21 = __esm({
    "node_modules/mdast-util-math/lib/index.js"() {
      init_default();
      init_longest_streak();
    }
  });

  // node_modules/mdast-util-math/index.js
  var init_mdast_util_math = __esm({
    "node_modules/mdast-util-math/index.js"() {
      init_lib21();
    }
  });

  // node_modules/micromark-extension-math/lib/math-flow.js
  function tokenizeMathFenced(effects, ok3, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    const initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let sizeOpen = 0;
    return start;
    function start(code4) {
      effects.enter("mathFlow");
      effects.enter("mathFlowFence");
      effects.enter("mathFlowFenceSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === 36) {
        effects.consume(code4);
        sizeOpen++;
        return sequenceOpen;
      }
      if (sizeOpen < 2) {
        return nok(code4);
      }
      effects.exit("mathFlowFenceSequence");
      return factorySpace(effects, metaBefore, "whitespace")(code4);
    }
    function metaBefore(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        return metaAfter(code4);
      }
      effects.enter("mathFlowFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta(code4);
    }
    function meta(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("chunkString");
        effects.exit("mathFlowFenceMeta");
        return metaAfter(code4);
      }
      if (code4 === 36) {
        return nok(code4);
      }
      effects.consume(code4);
      return meta;
    }
    function metaAfter(code4) {
      effects.exit("mathFlowFence");
      if (self2.interrupt) {
        return ok3(code4);
      }
      return effects.attempt(nonLazyContinuation2, beforeNonLazyContinuation, after)(code4);
    }
    function beforeNonLazyContinuation(code4) {
      return effects.attempt({
        tokenize: tokenizeClosingFence,
        partial: true
      }, after, contentStart)(code4);
    }
    function contentStart(code4) {
      return (initialSize ? factorySpace(effects, beforeContentChunk, "linePrefix", initialSize + 1) : beforeContentChunk)(code4);
    }
    function beforeContentChunk(code4) {
      if (code4 === null) {
        return after(code4);
      }
      if (markdownLineEnding(code4)) {
        return effects.attempt(nonLazyContinuation2, beforeNonLazyContinuation, after)(code4);
      }
      effects.enter("mathFlowValue");
      return contentChunk(code4);
    }
    function contentChunk(code4) {
      if (code4 === null || markdownLineEnding(code4)) {
        effects.exit("mathFlowValue");
        return beforeContentChunk(code4);
      }
      effects.consume(code4);
      return contentChunk;
    }
    function after(code4) {
      effects.exit("mathFlow");
      return ok3(code4);
    }
    function tokenizeClosingFence(effects2, ok4, nok2) {
      let size = 0;
      return factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
      function beforeSequenceClose(code4) {
        effects2.enter("mathFlowFence");
        effects2.enter("mathFlowFenceSequence");
        return sequenceClose(code4);
      }
      function sequenceClose(code4) {
        if (code4 === 36) {
          size++;
          effects2.consume(code4);
          return sequenceClose;
        }
        if (size < sizeOpen) {
          return nok2(code4);
        }
        effects2.exit("mathFlowFenceSequence");
        return factorySpace(effects2, afterSequenceClose, "whitespace")(code4);
      }
      function afterSequenceClose(code4) {
        if (code4 === null || markdownLineEnding(code4)) {
          effects2.exit("mathFlowFence");
          return ok4(code4);
        }
        return nok2(code4);
      }
    }
  }
  function tokenizeNonLazyContinuation2(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code4) {
      if (code4 === null) {
        return ok3(code4);
      }
      effects.enter("lineEnding");
      effects.consume(code4);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code4) {
      return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
    }
  }
  var mathFlow, nonLazyContinuation2;
  var init_math_flow = __esm({
    "node_modules/micromark-extension-math/lib/math-flow.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      mathFlow = {
        tokenize: tokenizeMathFenced,
        concrete: true,
        name: "mathFlow"
      };
      nonLazyContinuation2 = {
        tokenize: tokenizeNonLazyContinuation2,
        partial: true
      };
    }
  });

  // node_modules/micromark-extension-math/lib/math-text.js
  function mathText(options) {
    const options_ = options || {};
    let single = options_.singleDollarTextMath;
    if (single === null || single === void 0) {
      single = true;
    }
    return {
      tokenize: tokenizeMathText,
      resolve: resolveMathText,
      previous: previous3,
      name: "mathText"
    };
    function tokenizeMathText(effects, ok3, nok) {
      const self2 = this;
      let sizeOpen = 0;
      let size;
      let token;
      return start;
      function start(code4) {
        effects.enter("mathText");
        effects.enter("mathTextSequence");
        return sequenceOpen(code4);
      }
      function sequenceOpen(code4) {
        if (code4 === 36) {
          effects.consume(code4);
          sizeOpen++;
          return sequenceOpen;
        }
        if (sizeOpen < 2 && !single) {
          return nok(code4);
        }
        effects.exit("mathTextSequence");
        return between(code4);
      }
      function between(code4) {
        if (code4 === null) {
          return nok(code4);
        }
        if (code4 === 36) {
          token = effects.enter("mathTextSequence");
          size = 0;
          return sequenceClose(code4);
        }
        if (code4 === 32) {
          effects.enter("space");
          effects.consume(code4);
          effects.exit("space");
          return between;
        }
        if (markdownLineEnding(code4)) {
          effects.enter("lineEnding");
          effects.consume(code4);
          effects.exit("lineEnding");
          return between;
        }
        effects.enter("mathTextData");
        return data(code4);
      }
      function data(code4) {
        if (code4 === null || code4 === 32 || code4 === 36 || markdownLineEnding(code4)) {
          effects.exit("mathTextData");
          return between(code4);
        }
        effects.consume(code4);
        return data;
      }
      function sequenceClose(code4) {
        if (code4 === 36) {
          effects.consume(code4);
          size++;
          return sequenceClose;
        }
        if (size === sizeOpen) {
          effects.exit("mathTextSequence");
          effects.exit("mathText");
          return ok3(code4);
        }
        token.type = "mathTextData";
        return data(code4);
      }
    }
  }
  function resolveMathText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index2;
    let enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index2 = headEnterIndex;
      while (++index2 < tailExitIndex) {
        if (events[index2][1].type === "mathTextData") {
          events[tailExitIndex][1].type = "mathTextPadding";
          events[headEnterIndex][1].type = "mathTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index2 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index2 <= tailExitIndex) {
      if (enter === void 0) {
        if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
          enter = index2;
        }
      } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
        events[enter][1].type = "mathTextData";
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          tailExitIndex -= index2 - enter - 2;
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return events;
  }
  function previous3(code4) {
    return code4 !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  var init_math_text = __esm({
    "node_modules/micromark-extension-math/lib/math-text.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-extension-math/lib/syntax.js
  function math(options) {
    return {
      flow: {
        [36]: mathFlow
      },
      text: {
        [36]: mathText(options)
      }
    };
  }
  var init_syntax6 = __esm({
    "node_modules/micromark-extension-math/lib/syntax.js"() {
      init_math_flow();
      init_math_text();
    }
  });

  // node_modules/katex/dist/katex.mjs
  function escape(text10) {
    return String(text10).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
  }
  function getDefaultValue(schema) {
    if (schema.default) {
      return schema.default;
    }
    var type = schema.type;
    var defaultType = Array.isArray(type) ? type[0] : type;
    if (typeof defaultType !== "string") {
      return defaultType.enum[0];
    }
    switch (defaultType) {
      case "boolean":
        return false;
      case "string":
        return "";
      case "number":
        return 0;
      case "object":
        return {};
    }
  }
  function scriptFromCodepoint(codepoint) {
    for (var i = 0; i < scriptData.length; i++) {
      var script = scriptData[i];
      for (var _i = 0; _i < script.blocks.length; _i++) {
        var block = script.blocks[_i];
        if (codepoint >= block[0] && codepoint <= block[1]) {
          return script.name;
        }
      }
    }
    return null;
  }
  function supportedCodepoint(codepoint) {
    for (var i = 0; i < allBlocks.length; i += 2) {
      if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
        return true;
      }
    }
    return false;
  }
  function setFontMetrics(fontName, metrics) {
    fontMetricsData[fontName] = metrics;
  }
  function getCharacterMetrics(character, font, mode) {
    if (!fontMetricsData[font]) {
      throw new Error("Font metrics not found for font: " + font + ".");
    }
    var ch = character.charCodeAt(0);
    var metrics = fontMetricsData[font][ch];
    if (!metrics && character[0] in extraCharacterMap) {
      ch = extraCharacterMap[character[0]].charCodeAt(0);
      metrics = fontMetricsData[font][ch];
    }
    if (!metrics && mode === "text") {
      if (supportedCodepoint(ch)) {
        metrics = fontMetricsData[font][77];
      }
    }
    if (metrics) {
      return {
        depth: metrics[0],
        height: metrics[1],
        italic: metrics[2],
        skew: metrics[3],
        width: metrics[4]
      };
    }
  }
  function getGlobalMetrics(size) {
    var sizeIndex;
    if (size >= 5) {
      sizeIndex = 0;
    } else if (size >= 3) {
      sizeIndex = 1;
    } else {
      sizeIndex = 2;
    }
    if (!fontMetricsBySizeIndex[sizeIndex]) {
      var metrics = fontMetricsBySizeIndex[sizeIndex] = {
        cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
      };
      for (var key2 in sigmasAndXis) {
        if (sigmasAndXis.hasOwnProperty(key2)) {
          metrics[key2] = sigmasAndXis[key2][sizeIndex];
        }
      }
    }
    return fontMetricsBySizeIndex[sizeIndex];
  }
  function assertSymbolDomNode(group) {
    if (group instanceof SymbolNode) {
      return group;
    } else {
      throw new Error("Expected symbolNode but got " + String(group) + ".");
    }
  }
  function assertSpan(group) {
    if (group instanceof Span) {
      return group;
    } else {
      throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
    }
  }
  function defineSymbol(mode, font, group, replace2, name, acceptUnicodeChar) {
    symbols[mode][name] = {
      font,
      group,
      replace: replace2
    };
    if (acceptUnicodeChar && replace2) {
      symbols[mode][replace2] = symbols[mode][name];
    }
  }
  function defineFunction(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs,
      argTypes: props.argTypes,
      allowedInArgument: !!props.allowedInArgument,
      allowedInText: !!props.allowedInText,
      allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
      numOptionalArgs: props.numOptionalArgs || 0,
      infix: !!props.infix,
      primitive: !!props.primitive,
      handler
    };
    for (var i = 0; i < names.length; ++i) {
      _functions[names[i]] = data;
    }
    if (type) {
      if (htmlBuilder3) {
        _htmlGroupBuilders[type] = htmlBuilder3;
      }
      if (mathmlBuilder3) {
        _mathmlGroupBuilders[type] = mathmlBuilder3;
      }
    }
  }
  function defineFunctionBuilders(_ref2) {
    var {
      type,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref2;
    defineFunction({
      type,
      names: [],
      props: {
        numArgs: 0
      },
      handler() {
        throw new Error("Should never be called.");
      },
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    });
  }
  function buildHTMLUnbreakable(children2, options) {
    var body3 = makeSpan$1(["base"], children2, options);
    var strut = makeSpan$1(["strut"]);
    strut.style.height = makeEm(body3.height + body3.depth);
    if (body3.depth) {
      strut.style.verticalAlign = makeEm(-body3.depth);
    }
    body3.children.unshift(strut);
    return body3;
  }
  function buildHTML(tree, options) {
    var tag = null;
    if (tree.length === 1 && tree[0].type === "tag") {
      tag = tree[0].tag;
      tree = tree[0].body;
    }
    var expression = buildExpression$1(tree, options, "root");
    var eqnNum;
    if (expression.length === 2 && expression[1].hasClass("tag")) {
      eqnNum = expression.pop();
    }
    var children2 = [];
    var parts = [];
    for (var i = 0; i < expression.length; i++) {
      parts.push(expression[i]);
      if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
        var nobreak = false;
        while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
          i++;
          parts.push(expression[i]);
          if (expression[i].hasClass("nobreak")) {
            nobreak = true;
          }
        }
        if (!nobreak) {
          children2.push(buildHTMLUnbreakable(parts, options));
          parts = [];
        }
      } else if (expression[i].hasClass("newline")) {
        parts.pop();
        if (parts.length > 0) {
          children2.push(buildHTMLUnbreakable(parts, options));
          parts = [];
        }
        children2.push(expression[i]);
      }
    }
    if (parts.length > 0) {
      children2.push(buildHTMLUnbreakable(parts, options));
    }
    var tagChild;
    if (tag) {
      tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
      tagChild.classes = ["tag"];
      children2.push(tagChild);
    } else if (eqnNum) {
      children2.push(eqnNum);
    }
    var htmlNode = makeSpan$1(["katex-html"], children2);
    htmlNode.setAttribute("aria-hidden", "true");
    if (tagChild) {
      var strut = tagChild.children[0];
      strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
      if (htmlNode.depth) {
        strut.style.verticalAlign = makeEm(-htmlNode.depth);
      }
    }
    return htmlNode;
  }
  function newDocumentFragment(children2) {
    return new DocumentFragment(children2);
  }
  function isNumberPunctuation(group) {
    if (!group) {
      return false;
    }
    if (group.type === "mi" && group.children.length === 1) {
      var child = group.children[0];
      return child instanceof TextNode && child.text === ".";
    } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
      var _child = group.children[0];
      return _child instanceof TextNode && _child.text === ",";
    } else {
      return false;
    }
  }
  function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
    var expression = buildExpression2(tree, options);
    var wrapper;
    if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
      wrapper = expression[0];
    } else {
      wrapper = new mathMLTree.MathNode("mrow", expression);
    }
    var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
    var math3 = new mathMLTree.MathNode("math", [semantics]);
    math3.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
    if (isDisplayMode) {
      math3.setAttribute("display", "block");
    }
    var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
    return buildCommon.makeSpan([wrapperClass], [math3]);
  }
  function assertNodeType(node2, type) {
    if (!node2 || node2.type !== type) {
      throw new Error("Expected node of type " + type + ", but got " + (node2 ? "node of type " + node2.type : String(node2)));
    }
    return node2;
  }
  function assertSymbolNodeType(node2) {
    var typedNode = checkSymbolNodeType(node2);
    if (!typedNode) {
      throw new Error("Expected node of symbol group type, but got " + (node2 ? "node of type " + node2.type : String(node2)));
    }
    return typedNode;
  }
  function checkSymbolNodeType(node2) {
    if (node2 && (node2.type === "atom" || NON_ATOMS.hasOwnProperty(node2.type))) {
      return node2;
    }
    return null;
  }
  function htmlBuilder$9(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    return makeSpan2([group.mclass], elements, options);
  }
  function mathmlBuilder$8(group, options) {
    var node2;
    var inner2 = buildExpression2(group.body, options);
    if (group.mclass === "minner") {
      node2 = new mathMLTree.MathNode("mpadded", inner2);
    } else if (group.mclass === "mord") {
      if (group.isCharacterBox) {
        node2 = inner2[0];
        node2.type = "mi";
      } else {
        node2 = new mathMLTree.MathNode("mi", inner2);
      }
    } else {
      if (group.isCharacterBox) {
        node2 = inner2[0];
        node2.type = "mo";
      } else {
        node2 = new mathMLTree.MathNode("mo", inner2);
      }
      if (group.mclass === "mbin") {
        node2.attributes.lspace = "0.22em";
        node2.attributes.rspace = "0.22em";
      } else if (group.mclass === "mpunct") {
        node2.attributes.lspace = "0em";
        node2.attributes.rspace = "0.17em";
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node2.attributes.lspace = "0em";
        node2.attributes.rspace = "0em";
      } else if (group.mclass === "minner") {
        node2.attributes.lspace = "0.0556em";
        node2.attributes.width = "+0.1111em";
      }
    }
    return node2;
  }
  function cdArrow(arrowChar, labels, parser2) {
    var funcName = cdArrowFunctionName[arrowChar];
    switch (funcName) {
      case "\\\\cdrightarrow":
      case "\\\\cdleftarrow":
        return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
      case "\\uparrow":
      case "\\downarrow": {
        var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
        var bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
        var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
        var arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
      }
      case "\\\\cdlongequal":
        return parser2.callFunction("\\\\cdlongequal", [], []);
      case "\\Vert": {
        var arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser2.callFunction("\\Big", [arrow], []);
      }
      default:
        return {
          type: "textord",
          text: " ",
          mode: "math"
        };
    }
  }
  function parseCD(parser2) {
    var parsedRows = [];
    parser2.gullet.beginGroup();
    parser2.gullet.macros.set("\\cr", "\\\\\\relax");
    parser2.gullet.beginGroup();
    while (true) {
      parsedRows.push(parser2.parseExpression(false, "\\\\"));
      parser2.gullet.endGroup();
      parser2.gullet.beginGroup();
      var next = parser2.fetch().text;
      if (next === "&" || next === "\\\\") {
        parser2.consume();
      } else if (next === "\\end") {
        if (parsedRows[parsedRows.length - 1].length === 0) {
          parsedRows.pop();
        }
        break;
      } else {
        throw new ParseError("Expected \\\\ or \\cr or \\end", parser2.nextToken);
      }
    }
    var row2 = [];
    var body3 = [row2];
    for (var i = 0; i < parsedRows.length; i++) {
      var rowNodes = parsedRows[i];
      var cell2 = newCell();
      for (var j = 0; j < rowNodes.length; j++) {
        if (!isStartOfArrow(rowNodes[j])) {
          cell2.body.push(rowNodes[j]);
        } else {
          row2.push(cell2);
          j += 1;
          var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
          var labels = new Array(2);
          labels[0] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          labels[1] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          if ("=|.".indexOf(arrowChar) > -1) ;
          else if ("<>AV".indexOf(arrowChar) > -1) {
            for (var labelNum = 0; labelNum < 2; labelNum++) {
              var inLabel = true;
              for (var k = j + 1; k < rowNodes.length; k++) {
                if (isLabelEnd(rowNodes[k], arrowChar)) {
                  inLabel = false;
                  j = k;
                  break;
                }
                if (isStartOfArrow(rowNodes[k])) {
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                }
                labels[labelNum].body.push(rowNodes[k]);
              }
              if (inLabel) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
              }
            }
          } else {
            throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
          }
          var arrow = cdArrow(arrowChar, labels, parser2);
          var wrappedArrow = {
            type: "styling",
            body: [arrow],
            mode: "math",
            style: "display"
            // CD is always displaystyle.
          };
          row2.push(wrappedArrow);
          cell2 = newCell();
        }
      }
      if (i % 2 === 0) {
        row2.push(cell2);
      } else {
        row2.shift();
      }
      row2 = [];
      body3.push(row2);
    }
    parser2.gullet.endGroup();
    parser2.gullet.endGroup();
    var cols = new Array(body3[0].length).fill({
      type: "align",
      align: "c",
      pregap: 0.25,
      // CD package sets \enskip between columns.
      postgap: 0.25
      // So pre and post each get half an \enskip, i.e. 0.25em.
    });
    return {
      type: "array",
      mode: "math",
      body: body3,
      arraystretch: 1,
      addJot: true,
      rowGaps: [null],
      cols,
      colSeparationType: "CD",
      hLinesBeforeRow: new Array(body3.length + 1).fill([])
    };
  }
  function checkDelimiter(delim, context) {
    var symDelim = checkSymbolNodeType(delim);
    if (symDelim && utils.contains(delimiters, symDelim.text)) {
      return symDelim;
    } else if (symDelim) {
      throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
    } else {
      throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
    }
  }
  function assertParsed(group) {
    if (!group.body) {
      throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
    }
  }
  function defineEnvironment(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs || 0,
      allowedInText: false,
      numOptionalArgs: 0,
      handler
    };
    for (var i = 0; i < names.length; ++i) {
      _environments[names[i]] = data;
    }
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
  function defineMacro(name, body3) {
    _macros[name] = body3;
  }
  function getHLines(parser2) {
    var hlineInfo = [];
    parser2.consumeSpaces();
    var nxt = parser2.fetch().text;
    if (nxt === "\\relax") {
      parser2.consume();
      parser2.consumeSpaces();
      nxt = parser2.fetch().text;
    }
    while (nxt === "\\hline" || nxt === "\\hdashline") {
      parser2.consume();
      hlineInfo.push(nxt === "\\hdashline");
      parser2.consumeSpaces();
      nxt = parser2.fetch().text;
    }
    return hlineInfo;
  }
  function getAutoTag(name) {
    if (name.indexOf("ed") === -1) {
      return name.indexOf("*") === -1;
    }
  }
  function parseArray(parser2, _ref, style2) {
    var {
      hskipBeforeAndAfter,
      addJot,
      cols,
      arraystretch,
      colSeparationType,
      autoTag,
      singleRow,
      emptySingleRow,
      maxNumCols,
      leqno
    } = _ref;
    parser2.gullet.beginGroup();
    if (!singleRow) {
      parser2.gullet.macros.set("\\cr", "\\\\\\relax");
    }
    if (!arraystretch) {
      var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
      if (stretch == null) {
        arraystretch = 1;
      } else {
        arraystretch = parseFloat(stretch);
        if (!arraystretch || arraystretch < 0) {
          throw new ParseError("Invalid \\arraystretch: " + stretch);
        }
      }
    }
    parser2.gullet.beginGroup();
    var row2 = [];
    var body3 = [row2];
    var rowGaps = [];
    var hLinesBeforeRow = [];
    var tags = autoTag != null ? [] : void 0;
    function beginRow() {
      if (autoTag) {
        parser2.gullet.macros.set("\\@eqnsw", "1", true);
      }
    }
    function endRow() {
      if (tags) {
        if (parser2.gullet.macros.get("\\df@tag")) {
          tags.push(parser2.subparse([new Token("\\df@tag")]));
          parser2.gullet.macros.set("\\df@tag", void 0, true);
        } else {
          tags.push(Boolean(autoTag) && parser2.gullet.macros.get("\\@eqnsw") === "1");
        }
      }
    }
    beginRow();
    hLinesBeforeRow.push(getHLines(parser2));
    while (true) {
      var cell2 = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
      parser2.gullet.endGroup();
      parser2.gullet.beginGroup();
      cell2 = {
        type: "ordgroup",
        mode: parser2.mode,
        body: cell2
      };
      if (style2) {
        cell2 = {
          type: "styling",
          mode: parser2.mode,
          style: style2,
          body: [cell2]
        };
      }
      row2.push(cell2);
      var next = parser2.fetch().text;
      if (next === "&") {
        if (maxNumCols && row2.length === maxNumCols) {
          if (singleRow || colSeparationType) {
            throw new ParseError("Too many tab characters: &", parser2.nextToken);
          } else {
            parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
          }
        }
        parser2.consume();
      } else if (next === "\\end") {
        endRow();
        if (row2.length === 1 && cell2.type === "styling" && cell2.body[0].body.length === 0 && (body3.length > 1 || !emptySingleRow)) {
          body3.pop();
        }
        if (hLinesBeforeRow.length < body3.length + 1) {
          hLinesBeforeRow.push([]);
        }
        break;
      } else if (next === "\\\\") {
        parser2.consume();
        var size = void 0;
        if (parser2.gullet.future().text !== " ") {
          size = parser2.parseSizeGroup(true);
        }
        rowGaps.push(size ? size.value : null);
        endRow();
        hLinesBeforeRow.push(getHLines(parser2));
        row2 = [];
        body3.push(row2);
        beginRow();
      } else {
        throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
      }
    }
    parser2.gullet.endGroup();
    parser2.gullet.endGroup();
    return {
      type: "array",
      mode: parser2.mode,
      addJot,
      arraystretch,
      body: body3,
      cols,
      rowGaps,
      hskipBeforeAndAfter,
      hLinesBeforeRow,
      colSeparationType,
      tags,
      leqno
    };
  }
  function dCellStyle(envName) {
    if (envName.slice(0, 1) === "d") {
      return "display";
    } else {
      return "text";
    }
  }
  function sizingGroup(value, options, baseOptions) {
    var inner2 = buildExpression$1(value, options, false);
    var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
    for (var i = 0; i < inner2.length; i++) {
      var pos = inner2[i].classes.indexOf("sizing");
      if (pos < 0) {
        Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
      } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
        inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
      }
      inner2[i].height *= multiplier;
      inner2[i].depth *= multiplier;
    }
    return buildCommon.makeFragment(inner2);
  }
  var SourceLocation, Token, ParseError, contains, deflt, uppercase, hyphenate, ESCAPE_LOOKUP, ESCAPE_REGEX, getBaseElem, isCharacterBox, assert, protocolFromUrl, utils, SETTINGS_SCHEMA, Settings, Style, D, Dc, T, Tc, S, Sc, SS, SSc, styles, sup, sub, fracNum, fracDen, cramp, text$1, Style$1, scriptData, allBlocks, hLinePad, sqrtMain, sqrtSize1, sqrtSize2, sqrtSize3, sqrtSize4, phasePath, sqrtTall, sqrtPath, innerPath, path2, tallDelim, DocumentFragment, fontMetricsData, sigmasAndXis, extraCharacterMap, fontMetricsBySizeIndex, sizeStyleMap, sizeMultipliers, sizeAtStyle, Options, ptPerUnit, relativeUnit, validUnit, calculateSize, makeEm, createClass, initNode, toNode, invalidAttributeNameRegex, toMarkup, Span, Anchor, Img, iCombinations, SymbolNode, SvgNode, PathNode, LineNode, ATOMS, NON_ATOMS, symbols, math2, text5, main, ams, accent, bin, close, inner, mathord, op, open, punct, rel, spacing, textord, ligatures, mathTextSymbols, ch, i, textSymbols, _ch, _i, letters, _ch2, _i2, wideChar, _ch3, _i3, _ch4, _i4, extraLatin, _ch5, _i5, wideLatinLetterData, wideNumeralData, wideCharacterFont, lookupSymbol, makeSymbol, mathsym, boldsymbol, makeOrd, canCombine, tryCombineChars, sizeElementFromChildren, makeSpan$2, makeSvgSpan, makeLineSpan, makeAnchor, makeFragment, wrapFragment, getVListChildrenAndDepth, makeVList, makeGlue, retrieveTextFontName, fontMap, svgData, staticSvg, buildCommon, thinspace, mediumspace, thickspace, spacings, tightSpacings, _functions, _htmlGroupBuilders, _mathmlGroupBuilders, normalizeArgument, ordargument, makeSpan$1, binLeftCanceller, binRightCanceller, styleMap$1, DomEnum, buildExpression$1, traverseNonSpaceNodes, checkPartialGroup, getOutermostNode, getTypeOfDomTree, makeNullDelimiter, buildGroup$1, MathNode, TextNode, SpaceNode, mathMLTree, makeText, makeRow, getVariant, buildExpression2, buildExpressionRow, buildGroup2, optionsFromSettings, displayWrap, buildTree, buildHTMLTree, stretchyCodePoint, mathMLnode, katexImagesData, groupLength, svgSpan, encloseSpan, stretchy, htmlBuilder$a, mathmlBuilder$9, NON_STRETCHY_ACCENT_REGEX, paddedNode, makeSpan2, binrelClass, cdArrowFunctionName, newCell, isStartOfArrow, isLabelEnd, htmlBuilder$8, mathmlBuilder$7, globalMap, checkControlSequence, getRHS, letCommand, getMetrics, styleWrap, centerSpan, makeSmallDelim, mathrmSize, makeLargeDelim, makeGlyphSpan, makeInner, lapInEms, lap, verts, doubleVerts, makeStackedDelim, vbPad, emPad, sqrtSvg, makeSqrtImage, stackLargeDelimiters, stackAlwaysDelimiters, stackNeverDelimiters, sizeToMaxHeight, makeSizedDelim, stackNeverDelimiterSequence, stackAlwaysDelimiterSequence, stackLargeDelimiterSequence, delimTypeToFont, traverseSequence, makeCustomSizedDelim, makeLeftRightDelim, delimiter, delimiterSizes, delimiters, htmlBuilder$7, mathmlBuilder$6, _environments, _macros, validateAmsEnvironmentContext, htmlBuilder$6, alignMap, mathmlBuilder$5, alignedHandler, environments, htmlBuilder$5, mathmlBuilder$4, fontAliases, adjustStyle, htmlBuilder$4, mathmlBuilder$3, stylArray, delimFromValue, htmlBuilder$3, mathmlBuilder$2, sizeData, chooseMathStyle, assembleSupSub, noSuccessor, htmlBuilder$2, mathmlBuilder$1, singleCharBigOps, singleCharIntegrals, htmlBuilder$1, mathmlBuilder2, sizeFuncs, htmlBuilder2, styleMap, htmlBuilderDelegate, defaultVariant, cssSpace, regularSpace, pad, textFontFamilies, textFontWeights, textFontShapes, optionsWithFont, makeVerb, functions, spaceRegexString, controlWordRegexString, controlSymbolRegexString, controlWordWhitespaceRegexString, controlSpaceRegexString, combiningDiacriticalMarkString, combiningDiacriticalMarksEndRegex, tokenRegexString, Lexer, Namespace, macros, digitToNumber, newcommand, dotsByToken, spaceAfterDots, latexRaiseA, braketHelper, implicitCommands, MacroExpander, unicodeSubRegEx, uSubsAndSups, unicodeAccents, unicodeSymbols, Parser, parseTree, render, renderToString, generateParseTree, renderError, renderToDomTree, renderToHTMLTree, version, __domTree, katex;
  var init_katex = __esm({
    "node_modules/katex/dist/katex.mjs"() {
      SourceLocation = class _SourceLocation {
        // The + prefix indicates that these fields aren't writeable
        // Lexer holding the input string.
        // Start offset, zero-based inclusive.
        // End offset, zero-based exclusive.
        constructor(lexer, start, end) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer;
          this.start = start;
          this.end = end;
        }
        /**
         * Merges two `SourceLocation`s from location providers, given they are
         * provided in order of appearance.
         * - Returns the first one's location if only the first is provided.
         * - Returns a merged range of the first and the last if both are provided
         *   and their lexers match.
         * - Otherwise, returns null.
         */
        static range(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new _SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
          }
        }
      };
      Token = class _Token {
        // don't expand the token
        // used in \noexpand
        constructor(text10, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text10;
          this.loc = loc;
        }
        /**
         * Given a pair of tokens (this and endToken), compute a `Token` encompassing
         * the whole input range enclosed by these two.
         */
        range(endToken, text10) {
          return new _Token(text10, SourceLocation.range(this, endToken));
        }
      };
      ParseError = class _ParseError {
        // Error start position based on passed-in Token or ParseNode.
        // Length of affected text based on passed-in Token or ParseNode.
        // The underlying error message without any context added.
        constructor(message, token) {
          this.name = void 0;
          this.position = void 0;
          this.length = void 0;
          this.rawMessage = void 0;
          var error = "KaTeX parse error: " + message;
          var start;
          var end;
          var loc = token && token.loc;
          if (loc && loc.start <= loc.end) {
            var input = loc.lexer.input;
            start = loc.start;
            end = loc.end;
            if (start === input.length) {
              error += " at end of input: ";
            } else {
              error += " at position " + (start + 1) + ": ";
            }
            var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
            var left;
            if (start > 15) {
              left = "\u2026" + input.slice(start - 15, start);
            } else {
              left = input.slice(0, start);
            }
            var right;
            if (end + 15 < input.length) {
              right = input.slice(end, end + 15) + "\u2026";
            } else {
              right = input.slice(end);
            }
            error += left + underlined + right;
          }
          var self2 = new Error(error);
          self2.name = "ParseError";
          self2.__proto__ = _ParseError.prototype;
          self2.position = start;
          if (start != null && end != null) {
            self2.length = end - start;
          }
          self2.rawMessage = message;
          return self2;
        }
      };
      ParseError.prototype.__proto__ = Error.prototype;
      contains = function contains2(list4, elem) {
        return list4.indexOf(elem) !== -1;
      };
      deflt = function deflt2(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      };
      uppercase = /([A-Z])/g;
      hyphenate = function hyphenate2(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      };
      ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      ESCAPE_REGEX = /[&><"']/g;
      getBaseElem = function getBaseElem2(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem2(group.body);
        } else {
          return group;
        }
      };
      isCharacterBox = function isCharacterBox2(group) {
        var baseElem = getBaseElem(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      assert = function assert2(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      protocolFromUrl = function protocolFromUrl2(url) {
        var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
        if (!protocol) {
          return "_relative";
        }
        if (protocol[2] !== ":") {
          return null;
        }
        if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
          return null;
        }
        return protocol[1].toLowerCase();
      };
      utils = {
        contains,
        deflt,
        escape,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      SETTINGS_SCHEMA = {
        displayMode: {
          type: "boolean",
          description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
          cli: "-d, --display-mode"
        },
        output: {
          type: {
            enum: ["htmlAndMathml", "html", "mathml"]
          },
          description: "Determines the markup language of the output.",
          cli: "-F, --format <type>"
        },
        leqno: {
          type: "boolean",
          description: "Render display math in leqno style (left-justified tags)."
        },
        fleqn: {
          type: "boolean",
          description: "Render display math flush left."
        },
        throwOnError: {
          type: "boolean",
          default: true,
          cli: "-t, --no-throw-on-error",
          cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
        },
        errorColor: {
          type: "string",
          default: "#cc0000",
          cli: "-c, --error-color <color>",
          cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
          cliProcessor: (color2) => "#" + color2
        },
        macros: {
          type: "object",
          cli: "-m, --macro <def>",
          cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
          cliDefault: [],
          cliProcessor: (def, defs) => {
            defs.push(def);
            return defs;
          }
        },
        minRuleThickness: {
          type: "number",
          description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
          processor: (t) => Math.max(0, t),
          cli: "--min-rule-thickness <size>",
          cliProcessor: parseFloat
        },
        colorIsTextColor: {
          type: "boolean",
          description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
          cli: "-b, --color-is-text-color"
        },
        strict: {
          type: [{
            enum: ["warn", "ignore", "error"]
          }, "boolean", "function"],
          description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
          cli: "-S, --strict",
          cliDefault: false
        },
        trust: {
          type: ["boolean", "function"],
          description: "Trust the input, enabling all HTML features such as \\url.",
          cli: "-T, --trust"
        },
        maxSize: {
          type: "number",
          default: Infinity,
          description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
          processor: (s2) => Math.max(0, s2),
          cli: "-s, --max-size <n>",
          cliProcessor: parseInt
        },
        maxExpand: {
          type: "number",
          default: 1e3,
          description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
          processor: (n) => Math.max(0, n),
          cli: "-e, --max-expand <n>",
          cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
        },
        globalGroup: {
          type: "boolean",
          cli: false
        }
      };
      Settings = class {
        constructor(options) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options = options || {};
          for (var prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              var schema = SETTINGS_SCHEMA[prop];
              this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
            }
          }
        }
        /**
         * Report nonstrict (non-LaTeX-compatible) input.
         * Can safely not be called if `this.strict` is false in JavaScript.
         */
        reportNonstrict(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        }
        /**
         * Check whether to apply strict (LaTeX-adhering) behavior for unusual
         * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
         * instead, "error" translates to a return value of `true`, while "ignore"
         * translates to a return value of `false`.  May still print a warning:
         * "warn" prints a warning and returns `false`.
         * This is for the second category of `errorCode`s listed in the README.
         */
        useStrictBehavior(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        }
        /**
         * Check whether to test potentially dangerous input, and return
         * `true` (trusted) or `false` (untrusted).  The sole argument `context`
         * should be an object with `command` field specifying the relevant LaTeX
         * command (as a string starting with `\`), and any other arguments, etc.
         * If `context` has a `url` field, a `protocol` field will automatically
         * get added by this function (changing the specified object).
         */
        isTrusted(context) {
          if (context.url && !context.protocol) {
            var protocol = utils.protocolFromUrl(context.url);
            if (protocol == null) {
              return false;
            }
            context.protocol = protocol;
          }
          var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        }
      };
      Style = class {
        constructor(id, size, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        /**
         * Get the style of a superscript given a base in the current style.
         */
        sup() {
          return styles[sup[this.id]];
        }
        /**
         * Get the style of a subscript given a base in the current style.
         */
        sub() {
          return styles[sub[this.id]];
        }
        /**
         * Get the style of a fraction numerator given the fraction in the current
         * style.
         */
        fracNum() {
          return styles[fracNum[this.id]];
        }
        /**
         * Get the style of a fraction denominator given the fraction in the current
         * style.
         */
        fracDen() {
          return styles[fracDen[this.id]];
        }
        /**
         * Get the cramped version of a style (in particular, cramping a cramped style
         * doesn't change the style).
         */
        cramp() {
          return styles[cramp[this.id]];
        }
        /**
         * Get a text or display version of this style.
         */
        text() {
          return styles[text$1[this.id]];
        }
        /**
         * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
         */
        isTight() {
          return this.size >= 2;
        }
      };
      D = 0;
      Dc = 1;
      T = 2;
      Tc = 3;
      S = 4;
      Sc = 5;
      SS = 6;
      SSc = 7;
      styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
      sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
      fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
      Style$1 = {
        DISPLAY: styles[D],
        TEXT: styles[T],
        SCRIPT: styles[S],
        SCRIPTSCRIPT: styles[SS]
      };
      scriptData = [{
        // Latin characters beyond the Latin-1 characters we have metrics for.
        // Needed for Czech, Hungarian and Turkish text, for example.
        name: "latin",
        blocks: [
          [256, 591],
          // Latin Extended-A and Latin Extended-B
          [768, 879]
          // Combining Diacritical marks
        ]
      }, {
        // The Cyrillic script used by Russian and related languages.
        // A Cyrillic subset used to be supported as explicitly defined
        // symbols in symbols.js
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        // Armenian
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        // The Brahmic scripts of South and Southeast Asia
        // Devanagari (0900â€“097F)
        // Bengali (0980â€“09FF)
        // Gurmukhi (0A00â€“0A7F)
        // Gujarati (0A80â€“0AFF)
        // Oriya (0B00â€“0B7F)
        // Tamil (0B80â€“0BFF)
        // Telugu (0C00â€“0C7F)
        // Kannada (0C80â€“0CFF)
        // Malayalam (0D00â€“0D7F)
        // Sinhala (0D80â€“0DFF)
        // Thai (0E00â€“0E7F)
        // Lao (0E80â€“0EFF)
        // Tibetan (0F00â€“0FFF)
        // Myanmar (1000â€“109F)
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        // Chinese and Japanese.
        // The "k" in cjk is for Korean, but we've separated Korean out
        name: "cjk",
        blocks: [
          [12288, 12543],
          // CJK symbols and punctuation, Hiragana, Katakana
          [19968, 40879],
          // CJK ideograms
          [65280, 65376]
          // Fullwidth punctuation
          // TODO: add halfwidth Katakana and Romanji glyphs
        ]
      }, {
        // Korean
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      allBlocks = [];
      scriptData.forEach((s2) => s2.blocks.forEach((b) => allBlocks.push(...b)));
      hLinePad = 80;
      sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
        return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
        return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
        return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
        return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
        return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
      };
      phasePath = function phasePath2(y) {
        var x = y / 2;
        return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
      };
      sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
        return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
      };
      sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
        extraVinculum = 1e3 * extraVinculum;
        var path3 = "";
        switch (size) {
          case "sqrtMain":
            path3 = sqrtMain(extraVinculum, hLinePad);
            break;
          case "sqrtSize1":
            path3 = sqrtSize1(extraVinculum, hLinePad);
            break;
          case "sqrtSize2":
            path3 = sqrtSize2(extraVinculum, hLinePad);
            break;
          case "sqrtSize3":
            path3 = sqrtSize3(extraVinculum, hLinePad);
            break;
          case "sqrtSize4":
            path3 = sqrtSize4(extraVinculum, hLinePad);
            break;
          case "sqrtTall":
            path3 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
        }
        return path3;
      };
      innerPath = function innerPath2(name, height) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      path2 = {
        // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        // doublerightarrow is from glyph U+21D2 in font KaTeX Main
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        // leftarrow is from glyph U+2190 in font KaTeX Main
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        // overgroup is from the MnSymbol package (public domain)
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        // Harpoons are from glyph U+21BD in font KaTeX Main
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        // hook is from glyph U+21A9 in font KaTeX Main
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        // tilde1 is a modified version of a glyph from the MnSymbol package
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        // ditto tilde2, tilde3, & tilde4
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        // vec is from glyph U+20D7 in font KaTeX Main
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        // widehat1 is a modified version of a glyph from the MnSymbol package
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        // ditto widehat2, widehat3, & widehat4
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        // widecheck paths are all inverted versions of widehat
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        // The next ten paths support reaction arrows from the mhchem package.
        // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
        // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
        // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      tallDelim = function tallDelim2(label, midHeight) {
        switch (label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
          case "lparen":
            return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
          case "rparen":
            return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
          default:
            throw new Error("Unknown stretchy delimiter.");
        }
      };
      DocumentFragment = class {
        // HtmlDomNode
        // Never used; needed for satisfying interface.
        constructor(children2) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children2;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /** Convert the fragment into a node. */
        toNode() {
          var frag = document.createDocumentFragment();
          for (var i = 0; i < this.children.length; i++) {
            frag.appendChild(this.children[i].toNode());
          }
          return frag;
        }
        /** Convert the fragment into HTML markup. */
        toMarkup() {
          var markup = "";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText. Applies to
         * MathDomNode's only.
         */
        toText() {
          var toText2 = (child) => child.toText();
          return this.children.map(toText2).join("");
        }
      };
      fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        // sigma1
        space: [0, 0, 0],
        // sigma2
        stretch: [0, 0, 0],
        // sigma3
        shrink: [0, 0, 0],
        // sigma4
        xHeight: [0.431, 0.431, 0.431],
        // sigma5
        quad: [1, 1.171, 1.472],
        // sigma6
        extraSpace: [0, 0, 0],
        // sigma7
        num1: [0.677, 0.732, 0.925],
        // sigma8
        num2: [0.394, 0.384, 0.387],
        // sigma9
        num3: [0.444, 0.471, 0.504],
        // sigma10
        denom1: [0.686, 0.752, 1.025],
        // sigma11
        denom2: [0.345, 0.344, 0.532],
        // sigma12
        sup1: [0.413, 0.503, 0.504],
        // sigma13
        sup2: [0.363, 0.431, 0.404],
        // sigma14
        sup3: [0.289, 0.286, 0.294],
        // sigma15
        sub1: [0.15, 0.143, 0.2],
        // sigma16
        sub2: [0.247, 0.286, 0.4],
        // sigma17
        supDrop: [0.386, 0.353, 0.494],
        // sigma18
        subDrop: [0.05, 0.071, 0.1],
        // sigma19
        delim1: [2.39, 1.7, 1.98],
        // sigma20
        delim2: [1.01, 1.157, 1.42],
        // sigma21
        axisHeight: [0.25, 0.25, 0.25],
        // sigma22
        // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
        // they correspond to the font parameters of the extension fonts (family 3).
        // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
        // match cmex7, we'd use cmex7.tfm values for script and scriptscript
        // values.
        defaultRuleThickness: [0.04, 0.049, 0.049],
        // xi8; cmex7: 0.049
        bigOpSpacing1: [0.111, 0.111, 0.111],
        // xi9
        bigOpSpacing2: [0.166, 0.166, 0.166],
        // xi10
        bigOpSpacing3: [0.2, 0.2, 0.2],
        // xi11
        bigOpSpacing4: [0.6, 0.611, 0.611],
        // xi12; cmex7: 0.611
        bigOpSpacing5: [0.1, 0.143, 0.143],
        // xi13; cmex7: 0.143
        // The \sqrt rule width is taken from the height of the surd character.
        // Since we use the same font at all sizes, this thickness doesn't scale.
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        // This value determines how large a pt is, for metrics which are defined
        // in terms of pts.
        // This value is also used in katex.scss; if you change it make sure the
        // values match.
        ptPerEm: [10, 10, 10],
        // The space between adjacent `|` columns in an array definition. From
        // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
        doubleRuleSep: [0.2, 0.2, 0.2],
        // The width of separator lines in {array} environments. From
        // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
        arrayRuleWidth: [0.04, 0.04, 0.04],
        // Two values from LaTeX source2e:
        fboxsep: [0.3, 0.3, 0.3],
        //        3 pt / ptPerEm
        fboxrule: [0.04, 0.04, 0.04]
        // 0.4 pt / ptPerEm
      };
      extraCharacterMap = {
        // Latin-1
        "\xC5": "A",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xF0": "d",
        "\xFE": "o",
        // Cyrillic
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      fontMetricsBySizeIndex = {};
      sizeStyleMap = [
        // Each element contains [textsize, scriptsize, scriptscriptsize].
        // The size mappings are taken from TeX with \normalsize=10pt.
        [1, 1, 1],
        // size1: [5, 5, 5]              \tiny
        [2, 1, 1],
        // size2: [6, 5, 5]
        [3, 1, 1],
        // size3: [7, 5, 5]              \scriptsize
        [4, 2, 1],
        // size4: [8, 6, 5]              \footnotesize
        [5, 2, 1],
        // size5: [9, 6, 5]              \small
        [6, 3, 1],
        // size6: [10, 7, 5]             \normalsize
        [7, 4, 2],
        // size7: [12, 8, 6]             \large
        [8, 6, 3],
        // size8: [14.4, 10, 7]          \Large
        [9, 7, 6],
        // size9: [17.28, 12, 10]        \LARGE
        [10, 8, 7],
        // size10: [20.74, 14.4, 12]     \huge
        [11, 10, 9]
        // size11: [24.88, 20.74, 17.28] \HUGE
      ];
      sizeMultipliers = [
        // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
        // you change size indexes, change that function.
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      sizeAtStyle = function sizeAtStyle2(size, style2) {
        return style2.size < 2 ? size : sizeStyleMap[size - 1][style2.size - 1];
      };
      Options = class _Options {
        // A font family applies to a group of fonts (i.e. SansSerif), while a font
        // represents a specific font (i.e. SansSerif Bold).
        // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
        /**
         * The base size index.
         */
        constructor(data) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || _Options.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = void 0;
        }
        /**
         * Returns a new options object with the same properties as "this".  Properties
         * from "extension" will be copied to the new options object.
         */
        extend(extension2) {
          var data = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key2 in extension2) {
            if (extension2.hasOwnProperty(key2)) {
              data[key2] = extension2[key2];
            }
          }
          return new _Options(data);
        }
        /**
         * Return an options object with the given style. If `this.style === style`,
         * returns `this`.
         */
        havingStyle(style2) {
          if (this.style === style2) {
            return this;
          } else {
            return this.extend({
              style: style2,
              size: sizeAtStyle(this.textSize, style2)
            });
          }
        }
        /**
         * Return an options object with a cramped version of the current style. If
         * the current style is cramped, returns `this`.
         */
        havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        }
        /**
         * Return an options object with the given size and in at least `\textstyle`.
         * Returns `this` if appropriate.
         */
        havingSize(size) {
          if (this.size === size && this.textSize === size) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size,
              textSize: size,
              sizeMultiplier: sizeMultipliers[size - 1]
            });
          }
        }
        /**
         * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
         * changes to at least `\textstyle`.
         */
        havingBaseStyle(style2) {
          style2 = style2 || this.style.text();
          var wantSize = sizeAtStyle(_Options.BASESIZE, style2);
          if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style2) {
            return this;
          } else {
            return this.extend({
              style: style2,
              size: wantSize
            });
          }
        }
        /**
         * Remove the effect of sizing changes such as \Huge.
         * Keep the effect of the current style, such as \scriptstyle.
         */
        havingBaseSizing() {
          var size;
          switch (this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({
            style: this.style.text(),
            size
          });
        }
        /**
         * Create a new options object with the given color.
         */
        withColor(color2) {
          return this.extend({
            color: color2
          });
        }
        /**
         * Create a new options object with "phantom" set to true.
         */
        withPhantom() {
          return this.extend({
            phantom: true
          });
        }
        /**
         * Creates a new options object with the given math font or old text font.
         * @type {[type]}
         */
        withFont(font) {
          return this.extend({
            font
          });
        }
        /**
         * Create a new options objects with the given fontFamily.
         */
        withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        }
        /**
         * Return the CSS sizing classes required to switch from enclosing options
         * `oldOptions` to `this`. Returns an array of classes.
         */
        sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        }
        /**
         * Return the CSS sizing classes required to switch to the base size. Like
         * `this.havingSize(BASESIZE).sizingClasses(this)`.
         */
        baseSizingClasses() {
          if (this.size !== _Options.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
          } else {
            return [];
          }
        }
        /**
         * Return the font metrics for this size.
         */
        fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        }
        /**
         * Gets the CSS color of the current options object
         */
        getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        }
      };
      Options.BASESIZE = 6;
      ptPerUnit = {
        // https://en.wikibooks.org/wiki/LaTeX/Lengths and
        // https://tex.stackexchange.com/a/8263
        "pt": 1,
        // TeX point
        "mm": 7227 / 2540,
        // millimeter
        "cm": 7227 / 254,
        // centimeter
        "in": 72.27,
        // inch
        "bp": 803 / 800,
        // big (PostScript) points
        "pc": 12,
        // pica
        "dd": 1238 / 1157,
        // didot
        "cc": 14856 / 1157,
        // cicero (12 didot)
        "nd": 685 / 642,
        // new didot
        "nc": 1370 / 107,
        // new cicero (12 new didot)
        "sp": 1 / 65536,
        // scaled point (TeX's internal smallest unit)
        // https://tex.stackexchange.com/a/41371
        "px": 803 / 800
        // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
      };
      relativeUnit = {
        "ex": true,
        "em": true,
        "mu": true
      };
      validUnit = function validUnit2(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
      };
      calculateSize = function calculateSize2(sizeValue, options) {
        var scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options.style.isTight()) {
            unitOptions = options.havingStyle(options.style.text());
          } else {
            unitOptions = options;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options) {
            scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options.maxSize);
      };
      makeEm = function makeEm2(n) {
        return +n.toFixed(4) + "em";
      };
      createClass = function createClass2(classes) {
        return classes.filter((cls) => cls).join(" ");
      };
      initNode = function initNode2(classes, options, style2) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style2 || {};
        if (options) {
          if (options.style.isTight()) {
            this.classes.push("mtight");
          }
          var color2 = options.getColor();
          if (color2) {
            this.style.color = color2;
          }
        }
      };
      toNode = function toNode2(tagName) {
        var node2 = document.createElement(tagName);
        node2.className = createClass(this.classes);
        for (var style2 in this.style) {
          if (this.style.hasOwnProperty(style2)) {
            node2.style[style2] = this.style[style2];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node2.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i = 0; i < this.children.length; i++) {
          node2.appendChild(this.children[i].toNode());
        }
        return node2;
      };
      invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
      toMarkup = function toMarkup2(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        var styles2 = "";
        for (var style2 in this.style) {
          if (this.style.hasOwnProperty(style2)) {
            styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
          }
        }
        if (styles2) {
          markup += ' style="' + utils.escape(styles2) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            if (invalidAttributeNameRegex.test(attr)) {
              throw new ParseError("Invalid attribute name '" + attr + "'");
            }
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };
      Span = class {
        constructor(classes, children2, options, style2) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options, style2);
          this.children = children2 || [];
        }
        /**
         * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
         * all browsers support attributes the same, and having too many custom
         * attributes is probably bad.
         */
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "span");
        }
        toMarkup() {
          return toMarkup.call(this, "span");
        }
      };
      Anchor = class {
        constructor(href, classes, children2, options) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options);
          this.children = children2 || [];
          this.setAttribute("href", href);
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "a");
        }
        toMarkup() {
          return toMarkup.call(this, "a");
        }
      };
      Img = class {
        constructor(src, alt, style2) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style2;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          var node2 = document.createElement("img");
          node2.src = this.src;
          node2.alt = this.alt;
          node2.className = "mord";
          for (var style2 in this.style) {
            if (this.style.hasOwnProperty(style2)) {
              node2.style[style2] = this.style[style2];
            }
          }
          return node2;
        }
        toMarkup() {
          var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
          var styles2 = "";
          for (var style2 in this.style) {
            if (this.style.hasOwnProperty(style2)) {
              styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          markup += "'/>";
          return markup;
        }
      };
      iCombinations = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        // 'Ä«': '\u0131\u0304', // enable when we add Extended Latin
        "\xEC": "\u0131\u0300"
      };
      SymbolNode = class {
        constructor(text10, height, depth, italic, skew, width, classes, style2) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text10;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style2 || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[Ã®Ã¯Ã­Ã¬]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /**
         * Creates a text node or span from a symbol node. Note that a span is only
         * created if it is needed.
         */
        toNode() {
          var node2 = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (var style2 in this.style) {
            if (this.style.hasOwnProperty(style2)) {
              span = span || document.createElement("span");
              span.style[style2] = this.style[style2];
            }
          }
          if (span) {
            span.appendChild(node2);
            return span;
          } else {
            return node2;
          }
        }
        /**
         * Creates markup for a symbol node.
         */
        toMarkup() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          var styles2 = "";
          if (this.italic > 0) {
            styles2 += "margin-right:" + this.italic + "em;";
          }
          for (var style2 in this.style) {
            if (this.style.hasOwnProperty(style2)) {
              styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
            }
          }
          if (styles2) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          var escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        }
      };
      SvgNode = class {
        constructor(children2, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children2 || [];
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i = 0; i < this.children.length; i++) {
            node2.appendChild(this.children[i].toNode());
          }
          return node2;
        }
        toMarkup() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</svg>";
          return markup;
        }
      };
      PathNode = class {
        constructor(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node2.setAttribute("d", this.alternate);
          } else {
            node2.setAttribute("d", path2[this.pathName]);
          }
          return node2;
        }
        toMarkup() {
          if (this.alternate) {
            return '<path d="' + utils.escape(this.alternate) + '"/>';
          } else {
            return '<path d="' + utils.escape(path2[this.pathName]) + '"/>';
          }
        }
      };
      LineNode = class {
        constructor(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node2;
        }
        toMarkup() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += "/>";
          return markup;
        }
      };
      ATOMS = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      NON_ATOMS = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      symbols = {
        "math": {},
        "text": {}
      };
      math2 = "math";
      text5 = "text";
      main = "main";
      ams = "ams";
      accent = "accent-token";
      bin = "bin";
      close = "close";
      inner = "inner";
      mathord = "mathord";
      op = "op-token";
      open = "open";
      punct = "punct";
      rel = "rel";
      spacing = "spacing";
      textord = "textord";
      defineSymbol(math2, main, rel, "\u2261", "\\equiv", true);
      defineSymbol(math2, main, rel, "\u227A", "\\prec", true);
      defineSymbol(math2, main, rel, "\u227B", "\\succ", true);
      defineSymbol(math2, main, rel, "\u223C", "\\sim", true);
      defineSymbol(math2, main, rel, "\u22A5", "\\perp");
      defineSymbol(math2, main, rel, "\u2AAF", "\\preceq", true);
      defineSymbol(math2, main, rel, "\u2AB0", "\\succeq", true);
      defineSymbol(math2, main, rel, "\u2243", "\\simeq", true);
      defineSymbol(math2, main, rel, "\u2223", "\\mid", true);
      defineSymbol(math2, main, rel, "\u226A", "\\ll", true);
      defineSymbol(math2, main, rel, "\u226B", "\\gg", true);
      defineSymbol(math2, main, rel, "\u224D", "\\asymp", true);
      defineSymbol(math2, main, rel, "\u2225", "\\parallel");
      defineSymbol(math2, main, rel, "\u22C8", "\\bowtie", true);
      defineSymbol(math2, main, rel, "\u2323", "\\smile", true);
      defineSymbol(math2, main, rel, "\u2291", "\\sqsubseteq", true);
      defineSymbol(math2, main, rel, "\u2292", "\\sqsupseteq", true);
      defineSymbol(math2, main, rel, "\u2250", "\\doteq", true);
      defineSymbol(math2, main, rel, "\u2322", "\\frown", true);
      defineSymbol(math2, main, rel, "\u220B", "\\ni", true);
      defineSymbol(math2, main, rel, "\u221D", "\\propto", true);
      defineSymbol(math2, main, rel, "\u22A2", "\\vdash", true);
      defineSymbol(math2, main, rel, "\u22A3", "\\dashv", true);
      defineSymbol(math2, main, rel, "\u220B", "\\owns");
      defineSymbol(math2, main, punct, ".", "\\ldotp");
      defineSymbol(math2, main, punct, "\u22C5", "\\cdotp");
      defineSymbol(math2, main, textord, "#", "\\#");
      defineSymbol(text5, main, textord, "#", "\\#");
      defineSymbol(math2, main, textord, "&", "\\&");
      defineSymbol(text5, main, textord, "&", "\\&");
      defineSymbol(math2, main, textord, "\u2135", "\\aleph", true);
      defineSymbol(math2, main, textord, "\u2200", "\\forall", true);
      defineSymbol(math2, main, textord, "\u210F", "\\hbar", true);
      defineSymbol(math2, main, textord, "\u2203", "\\exists", true);
      defineSymbol(math2, main, textord, "\u2207", "\\nabla", true);
      defineSymbol(math2, main, textord, "\u266D", "\\flat", true);
      defineSymbol(math2, main, textord, "\u2113", "\\ell", true);
      defineSymbol(math2, main, textord, "\u266E", "\\natural", true);
      defineSymbol(math2, main, textord, "\u2663", "\\clubsuit", true);
      defineSymbol(math2, main, textord, "\u2118", "\\wp", true);
      defineSymbol(math2, main, textord, "\u266F", "\\sharp", true);
      defineSymbol(math2, main, textord, "\u2662", "\\diamondsuit", true);
      defineSymbol(math2, main, textord, "\u211C", "\\Re", true);
      defineSymbol(math2, main, textord, "\u2661", "\\heartsuit", true);
      defineSymbol(math2, main, textord, "\u2111", "\\Im", true);
      defineSymbol(math2, main, textord, "\u2660", "\\spadesuit", true);
      defineSymbol(math2, main, textord, "\xA7", "\\S", true);
      defineSymbol(text5, main, textord, "\xA7", "\\S");
      defineSymbol(math2, main, textord, "\xB6", "\\P", true);
      defineSymbol(text5, main, textord, "\xB6", "\\P");
      defineSymbol(math2, main, textord, "\u2020", "\\dag");
      defineSymbol(text5, main, textord, "\u2020", "\\dag");
      defineSymbol(text5, main, textord, "\u2020", "\\textdagger");
      defineSymbol(math2, main, textord, "\u2021", "\\ddag");
      defineSymbol(text5, main, textord, "\u2021", "\\ddag");
      defineSymbol(text5, main, textord, "\u2021", "\\textdaggerdbl");
      defineSymbol(math2, main, close, "\u23B1", "\\rmoustache", true);
      defineSymbol(math2, main, open, "\u23B0", "\\lmoustache", true);
      defineSymbol(math2, main, close, "\u27EF", "\\rgroup", true);
      defineSymbol(math2, main, open, "\u27EE", "\\lgroup", true);
      defineSymbol(math2, main, bin, "\u2213", "\\mp", true);
      defineSymbol(math2, main, bin, "\u2296", "\\ominus", true);
      defineSymbol(math2, main, bin, "\u228E", "\\uplus", true);
      defineSymbol(math2, main, bin, "\u2293", "\\sqcap", true);
      defineSymbol(math2, main, bin, "\u2217", "\\ast");
      defineSymbol(math2, main, bin, "\u2294", "\\sqcup", true);
      defineSymbol(math2, main, bin, "\u25EF", "\\bigcirc", true);
      defineSymbol(math2, main, bin, "\u2219", "\\bullet", true);
      defineSymbol(math2, main, bin, "\u2021", "\\ddagger");
      defineSymbol(math2, main, bin, "\u2240", "\\wr", true);
      defineSymbol(math2, main, bin, "\u2A3F", "\\amalg");
      defineSymbol(math2, main, bin, "&", "\\And");
      defineSymbol(math2, main, rel, "\u27F5", "\\longleftarrow", true);
      defineSymbol(math2, main, rel, "\u21D0", "\\Leftarrow", true);
      defineSymbol(math2, main, rel, "\u27F8", "\\Longleftarrow", true);
      defineSymbol(math2, main, rel, "\u27F6", "\\longrightarrow", true);
      defineSymbol(math2, main, rel, "\u21D2", "\\Rightarrow", true);
      defineSymbol(math2, main, rel, "\u27F9", "\\Longrightarrow", true);
      defineSymbol(math2, main, rel, "\u2194", "\\leftrightarrow", true);
      defineSymbol(math2, main, rel, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol(math2, main, rel, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol(math2, main, rel, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol(math2, main, rel, "\u21A6", "\\mapsto", true);
      defineSymbol(math2, main, rel, "\u27FC", "\\longmapsto", true);
      defineSymbol(math2, main, rel, "\u2197", "\\nearrow", true);
      defineSymbol(math2, main, rel, "\u21A9", "\\hookleftarrow", true);
      defineSymbol(math2, main, rel, "\u21AA", "\\hookrightarrow", true);
      defineSymbol(math2, main, rel, "\u2198", "\\searrow", true);
      defineSymbol(math2, main, rel, "\u21BC", "\\leftharpoonup", true);
      defineSymbol(math2, main, rel, "\u21C0", "\\rightharpoonup", true);
      defineSymbol(math2, main, rel, "\u2199", "\\swarrow", true);
      defineSymbol(math2, main, rel, "\u21BD", "\\leftharpoondown", true);
      defineSymbol(math2, main, rel, "\u21C1", "\\rightharpoondown", true);
      defineSymbol(math2, main, rel, "\u2196", "\\nwarrow", true);
      defineSymbol(math2, main, rel, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol(math2, ams, rel, "\u226E", "\\nless", true);
      defineSymbol(math2, ams, rel, "\uE010", "\\@nleqslant");
      defineSymbol(math2, ams, rel, "\uE011", "\\@nleqq");
      defineSymbol(math2, ams, rel, "\u2A87", "\\lneq", true);
      defineSymbol(math2, ams, rel, "\u2268", "\\lneqq", true);
      defineSymbol(math2, ams, rel, "\uE00C", "\\@lvertneqq");
      defineSymbol(math2, ams, rel, "\u22E6", "\\lnsim", true);
      defineSymbol(math2, ams, rel, "\u2A89", "\\lnapprox", true);
      defineSymbol(math2, ams, rel, "\u2280", "\\nprec", true);
      defineSymbol(math2, ams, rel, "\u22E0", "\\npreceq", true);
      defineSymbol(math2, ams, rel, "\u22E8", "\\precnsim", true);
      defineSymbol(math2, ams, rel, "\u2AB9", "\\precnapprox", true);
      defineSymbol(math2, ams, rel, "\u2241", "\\nsim", true);
      defineSymbol(math2, ams, rel, "\uE006", "\\@nshortmid");
      defineSymbol(math2, ams, rel, "\u2224", "\\nmid", true);
      defineSymbol(math2, ams, rel, "\u22AC", "\\nvdash", true);
      defineSymbol(math2, ams, rel, "\u22AD", "\\nvDash", true);
      defineSymbol(math2, ams, rel, "\u22EA", "\\ntriangleleft");
      defineSymbol(math2, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol(math2, ams, rel, "\u228A", "\\subsetneq", true);
      defineSymbol(math2, ams, rel, "\uE01A", "\\@varsubsetneq");
      defineSymbol(math2, ams, rel, "\u2ACB", "\\subsetneqq", true);
      defineSymbol(math2, ams, rel, "\uE017", "\\@varsubsetneqq");
      defineSymbol(math2, ams, rel, "\u226F", "\\ngtr", true);
      defineSymbol(math2, ams, rel, "\uE00F", "\\@ngeqslant");
      defineSymbol(math2, ams, rel, "\uE00E", "\\@ngeqq");
      defineSymbol(math2, ams, rel, "\u2A88", "\\gneq", true);
      defineSymbol(math2, ams, rel, "\u2269", "\\gneqq", true);
      defineSymbol(math2, ams, rel, "\uE00D", "\\@gvertneqq");
      defineSymbol(math2, ams, rel, "\u22E7", "\\gnsim", true);
      defineSymbol(math2, ams, rel, "\u2A8A", "\\gnapprox", true);
      defineSymbol(math2, ams, rel, "\u2281", "\\nsucc", true);
      defineSymbol(math2, ams, rel, "\u22E1", "\\nsucceq", true);
      defineSymbol(math2, ams, rel, "\u22E9", "\\succnsim", true);
      defineSymbol(math2, ams, rel, "\u2ABA", "\\succnapprox", true);
      defineSymbol(math2, ams, rel, "\u2246", "\\ncong", true);
      defineSymbol(math2, ams, rel, "\uE007", "\\@nshortparallel");
      defineSymbol(math2, ams, rel, "\u2226", "\\nparallel", true);
      defineSymbol(math2, ams, rel, "\u22AF", "\\nVDash", true);
      defineSymbol(math2, ams, rel, "\u22EB", "\\ntriangleright");
      defineSymbol(math2, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol(math2, ams, rel, "\uE018", "\\@nsupseteqq");
      defineSymbol(math2, ams, rel, "\u228B", "\\supsetneq", true);
      defineSymbol(math2, ams, rel, "\uE01B", "\\@varsupsetneq");
      defineSymbol(math2, ams, rel, "\u2ACC", "\\supsetneqq", true);
      defineSymbol(math2, ams, rel, "\uE019", "\\@varsupsetneqq");
      defineSymbol(math2, ams, rel, "\u22AE", "\\nVdash", true);
      defineSymbol(math2, ams, rel, "\u2AB5", "\\precneqq", true);
      defineSymbol(math2, ams, rel, "\u2AB6", "\\succneqq", true);
      defineSymbol(math2, ams, rel, "\uE016", "\\@nsubseteqq");
      defineSymbol(math2, ams, bin, "\u22B4", "\\unlhd");
      defineSymbol(math2, ams, bin, "\u22B5", "\\unrhd");
      defineSymbol(math2, ams, rel, "\u219A", "\\nleftarrow", true);
      defineSymbol(math2, ams, rel, "\u219B", "\\nrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21CD", "\\nLeftarrow", true);
      defineSymbol(math2, ams, rel, "\u21CF", "\\nRightarrow", true);
      defineSymbol(math2, ams, rel, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol(math2, ams, rel, "\u25B3", "\\vartriangle");
      defineSymbol(math2, ams, textord, "\u210F", "\\hslash");
      defineSymbol(math2, ams, textord, "\u25BD", "\\triangledown");
      defineSymbol(math2, ams, textord, "\u25CA", "\\lozenge");
      defineSymbol(math2, ams, textord, "\u24C8", "\\circledS");
      defineSymbol(math2, ams, textord, "\xAE", "\\circledR");
      defineSymbol(text5, ams, textord, "\xAE", "\\circledR");
      defineSymbol(math2, ams, textord, "\u2221", "\\measuredangle", true);
      defineSymbol(math2, ams, textord, "\u2204", "\\nexists");
      defineSymbol(math2, ams, textord, "\u2127", "\\mho");
      defineSymbol(math2, ams, textord, "\u2132", "\\Finv", true);
      defineSymbol(math2, ams, textord, "\u2141", "\\Game", true);
      defineSymbol(math2, ams, textord, "\u2035", "\\backprime");
      defineSymbol(math2, ams, textord, "\u25B2", "\\blacktriangle");
      defineSymbol(math2, ams, textord, "\u25BC", "\\blacktriangledown");
      defineSymbol(math2, ams, textord, "\u25A0", "\\blacksquare");
      defineSymbol(math2, ams, textord, "\u29EB", "\\blacklozenge");
      defineSymbol(math2, ams, textord, "\u2605", "\\bigstar");
      defineSymbol(math2, ams, textord, "\u2222", "\\sphericalangle", true);
      defineSymbol(math2, ams, textord, "\u2201", "\\complement", true);
      defineSymbol(math2, ams, textord, "\xF0", "\\eth", true);
      defineSymbol(text5, main, textord, "\xF0", "\xF0");
      defineSymbol(math2, ams, textord, "\u2571", "\\diagup");
      defineSymbol(math2, ams, textord, "\u2572", "\\diagdown");
      defineSymbol(math2, ams, textord, "\u25A1", "\\square");
      defineSymbol(math2, ams, textord, "\u25A1", "\\Box");
      defineSymbol(math2, ams, textord, "\u25CA", "\\Diamond");
      defineSymbol(math2, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(text5, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(math2, ams, textord, "\u2713", "\\checkmark", true);
      defineSymbol(text5, ams, textord, "\u2713", "\\checkmark");
      defineSymbol(math2, ams, textord, "\u2136", "\\beth", true);
      defineSymbol(math2, ams, textord, "\u2138", "\\daleth", true);
      defineSymbol(math2, ams, textord, "\u2137", "\\gimel", true);
      defineSymbol(math2, ams, textord, "\u03DD", "\\digamma", true);
      defineSymbol(math2, ams, textord, "\u03F0", "\\varkappa");
      defineSymbol(math2, ams, open, "\u250C", "\\@ulcorner", true);
      defineSymbol(math2, ams, close, "\u2510", "\\@urcorner", true);
      defineSymbol(math2, ams, open, "\u2514", "\\@llcorner", true);
      defineSymbol(math2, ams, close, "\u2518", "\\@lrcorner", true);
      defineSymbol(math2, ams, rel, "\u2266", "\\leqq", true);
      defineSymbol(math2, ams, rel, "\u2A7D", "\\leqslant", true);
      defineSymbol(math2, ams, rel, "\u2A95", "\\eqslantless", true);
      defineSymbol(math2, ams, rel, "\u2272", "\\lesssim", true);
      defineSymbol(math2, ams, rel, "\u2A85", "\\lessapprox", true);
      defineSymbol(math2, ams, rel, "\u224A", "\\approxeq", true);
      defineSymbol(math2, ams, bin, "\u22D6", "\\lessdot");
      defineSymbol(math2, ams, rel, "\u22D8", "\\lll", true);
      defineSymbol(math2, ams, rel, "\u2276", "\\lessgtr", true);
      defineSymbol(math2, ams, rel, "\u22DA", "\\lesseqgtr", true);
      defineSymbol(math2, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol(math2, ams, rel, "\u2251", "\\doteqdot");
      defineSymbol(math2, ams, rel, "\u2253", "\\risingdotseq", true);
      defineSymbol(math2, ams, rel, "\u2252", "\\fallingdotseq", true);
      defineSymbol(math2, ams, rel, "\u223D", "\\backsim", true);
      defineSymbol(math2, ams, rel, "\u22CD", "\\backsimeq", true);
      defineSymbol(math2, ams, rel, "\u2AC5", "\\subseteqq", true);
      defineSymbol(math2, ams, rel, "\u22D0", "\\Subset", true);
      defineSymbol(math2, ams, rel, "\u228F", "\\sqsubset", true);
      defineSymbol(math2, ams, rel, "\u227C", "\\preccurlyeq", true);
      defineSymbol(math2, ams, rel, "\u22DE", "\\curlyeqprec", true);
      defineSymbol(math2, ams, rel, "\u227E", "\\precsim", true);
      defineSymbol(math2, ams, rel, "\u2AB7", "\\precapprox", true);
      defineSymbol(math2, ams, rel, "\u22B2", "\\vartriangleleft");
      defineSymbol(math2, ams, rel, "\u22B4", "\\trianglelefteq");
      defineSymbol(math2, ams, rel, "\u22A8", "\\vDash", true);
      defineSymbol(math2, ams, rel, "\u22AA", "\\Vvdash", true);
      defineSymbol(math2, ams, rel, "\u2323", "\\smallsmile");
      defineSymbol(math2, ams, rel, "\u2322", "\\smallfrown");
      defineSymbol(math2, ams, rel, "\u224F", "\\bumpeq", true);
      defineSymbol(math2, ams, rel, "\u224E", "\\Bumpeq", true);
      defineSymbol(math2, ams, rel, "\u2267", "\\geqq", true);
      defineSymbol(math2, ams, rel, "\u2A7E", "\\geqslant", true);
      defineSymbol(math2, ams, rel, "\u2A96", "\\eqslantgtr", true);
      defineSymbol(math2, ams, rel, "\u2273", "\\gtrsim", true);
      defineSymbol(math2, ams, rel, "\u2A86", "\\gtrapprox", true);
      defineSymbol(math2, ams, bin, "\u22D7", "\\gtrdot");
      defineSymbol(math2, ams, rel, "\u22D9", "\\ggg", true);
      defineSymbol(math2, ams, rel, "\u2277", "\\gtrless", true);
      defineSymbol(math2, ams, rel, "\u22DB", "\\gtreqless", true);
      defineSymbol(math2, ams, rel, "\u2A8C", "\\gtreqqless", true);
      defineSymbol(math2, ams, rel, "\u2256", "\\eqcirc", true);
      defineSymbol(math2, ams, rel, "\u2257", "\\circeq", true);
      defineSymbol(math2, ams, rel, "\u225C", "\\triangleq", true);
      defineSymbol(math2, ams, rel, "\u223C", "\\thicksim");
      defineSymbol(math2, ams, rel, "\u2248", "\\thickapprox");
      defineSymbol(math2, ams, rel, "\u2AC6", "\\supseteqq", true);
      defineSymbol(math2, ams, rel, "\u22D1", "\\Supset", true);
      defineSymbol(math2, ams, rel, "\u2290", "\\sqsupset", true);
      defineSymbol(math2, ams, rel, "\u227D", "\\succcurlyeq", true);
      defineSymbol(math2, ams, rel, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol(math2, ams, rel, "\u227F", "\\succsim", true);
      defineSymbol(math2, ams, rel, "\u2AB8", "\\succapprox", true);
      defineSymbol(math2, ams, rel, "\u22B3", "\\vartriangleright");
      defineSymbol(math2, ams, rel, "\u22B5", "\\trianglerighteq");
      defineSymbol(math2, ams, rel, "\u22A9", "\\Vdash", true);
      defineSymbol(math2, ams, rel, "\u2223", "\\shortmid");
      defineSymbol(math2, ams, rel, "\u2225", "\\shortparallel");
      defineSymbol(math2, ams, rel, "\u226C", "\\between", true);
      defineSymbol(math2, ams, rel, "\u22D4", "\\pitchfork", true);
      defineSymbol(math2, ams, rel, "\u221D", "\\varpropto");
      defineSymbol(math2, ams, rel, "\u25C0", "\\blacktriangleleft");
      defineSymbol(math2, ams, rel, "\u2234", "\\therefore", true);
      defineSymbol(math2, ams, rel, "\u220D", "\\backepsilon");
      defineSymbol(math2, ams, rel, "\u25B6", "\\blacktriangleright");
      defineSymbol(math2, ams, rel, "\u2235", "\\because", true);
      defineSymbol(math2, ams, rel, "\u22D8", "\\llless");
      defineSymbol(math2, ams, rel, "\u22D9", "\\gggtr");
      defineSymbol(math2, ams, bin, "\u22B2", "\\lhd");
      defineSymbol(math2, ams, bin, "\u22B3", "\\rhd");
      defineSymbol(math2, ams, rel, "\u2242", "\\eqsim", true);
      defineSymbol(math2, main, rel, "\u22C8", "\\Join");
      defineSymbol(math2, ams, rel, "\u2251", "\\Doteq", true);
      defineSymbol(math2, ams, bin, "\u2214", "\\dotplus", true);
      defineSymbol(math2, ams, bin, "\u2216", "\\smallsetminus");
      defineSymbol(math2, ams, bin, "\u22D2", "\\Cap", true);
      defineSymbol(math2, ams, bin, "\u22D3", "\\Cup", true);
      defineSymbol(math2, ams, bin, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol(math2, ams, bin, "\u229F", "\\boxminus", true);
      defineSymbol(math2, ams, bin, "\u229E", "\\boxplus", true);
      defineSymbol(math2, ams, bin, "\u22C7", "\\divideontimes", true);
      defineSymbol(math2, ams, bin, "\u22C9", "\\ltimes", true);
      defineSymbol(math2, ams, bin, "\u22CA", "\\rtimes", true);
      defineSymbol(math2, ams, bin, "\u22CB", "\\leftthreetimes", true);
      defineSymbol(math2, ams, bin, "\u22CC", "\\rightthreetimes", true);
      defineSymbol(math2, ams, bin, "\u22CF", "\\curlywedge", true);
      defineSymbol(math2, ams, bin, "\u22CE", "\\curlyvee", true);
      defineSymbol(math2, ams, bin, "\u229D", "\\circleddash", true);
      defineSymbol(math2, ams, bin, "\u229B", "\\circledast", true);
      defineSymbol(math2, ams, bin, "\u22C5", "\\centerdot");
      defineSymbol(math2, ams, bin, "\u22BA", "\\intercal", true);
      defineSymbol(math2, ams, bin, "\u22D2", "\\doublecap");
      defineSymbol(math2, ams, bin, "\u22D3", "\\doublecup");
      defineSymbol(math2, ams, bin, "\u22A0", "\\boxtimes", true);
      defineSymbol(math2, ams, rel, "\u21E2", "\\dashrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21E0", "\\dashleftarrow", true);
      defineSymbol(math2, ams, rel, "\u21C7", "\\leftleftarrows", true);
      defineSymbol(math2, ams, rel, "\u21C6", "\\leftrightarrows", true);
      defineSymbol(math2, ams, rel, "\u21DA", "\\Lleftarrow", true);
      defineSymbol(math2, ams, rel, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol(math2, ams, rel, "\u21A2", "\\leftarrowtail", true);
      defineSymbol(math2, ams, rel, "\u21AB", "\\looparrowleft", true);
      defineSymbol(math2, ams, rel, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol(math2, ams, rel, "\u21B6", "\\curvearrowleft", true);
      defineSymbol(math2, ams, rel, "\u21BA", "\\circlearrowleft", true);
      defineSymbol(math2, ams, rel, "\u21B0", "\\Lsh", true);
      defineSymbol(math2, ams, rel, "\u21C8", "\\upuparrows", true);
      defineSymbol(math2, ams, rel, "\u21BF", "\\upharpoonleft", true);
      defineSymbol(math2, ams, rel, "\u21C3", "\\downharpoonleft", true);
      defineSymbol(math2, main, rel, "\u22B6", "\\origof", true);
      defineSymbol(math2, main, rel, "\u22B7", "\\imageof", true);
      defineSymbol(math2, ams, rel, "\u22B8", "\\multimap", true);
      defineSymbol(math2, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol(math2, ams, rel, "\u21C9", "\\rightrightarrows", true);
      defineSymbol(math2, ams, rel, "\u21C4", "\\rightleftarrows", true);
      defineSymbol(math2, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21A3", "\\rightarrowtail", true);
      defineSymbol(math2, ams, rel, "\u21AC", "\\looparrowright", true);
      defineSymbol(math2, ams, rel, "\u21B7", "\\curvearrowright", true);
      defineSymbol(math2, ams, rel, "\u21BB", "\\circlearrowright", true);
      defineSymbol(math2, ams, rel, "\u21B1", "\\Rsh", true);
      defineSymbol(math2, ams, rel, "\u21CA", "\\downdownarrows", true);
      defineSymbol(math2, ams, rel, "\u21BE", "\\upharpoonright", true);
      defineSymbol(math2, ams, rel, "\u21C2", "\\downharpoonright", true);
      defineSymbol(math2, ams, rel, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol(math2, ams, rel, "\u21DD", "\\leadsto");
      defineSymbol(math2, ams, rel, "\u21DB", "\\Rrightarrow", true);
      defineSymbol(math2, ams, rel, "\u21BE", "\\restriction");
      defineSymbol(math2, main, textord, "\u2018", "`");
      defineSymbol(math2, main, textord, "$", "\\$");
      defineSymbol(text5, main, textord, "$", "\\$");
      defineSymbol(text5, main, textord, "$", "\\textdollar");
      defineSymbol(math2, main, textord, "%", "\\%");
      defineSymbol(text5, main, textord, "%", "\\%");
      defineSymbol(math2, main, textord, "_", "\\_");
      defineSymbol(text5, main, textord, "_", "\\_");
      defineSymbol(text5, main, textord, "_", "\\textunderscore");
      defineSymbol(math2, main, textord, "\u2220", "\\angle", true);
      defineSymbol(math2, main, textord, "\u221E", "\\infty", true);
      defineSymbol(math2, main, textord, "\u2032", "\\prime");
      defineSymbol(math2, main, textord, "\u25B3", "\\triangle");
      defineSymbol(math2, main, textord, "\u0393", "\\Gamma", true);
      defineSymbol(math2, main, textord, "\u0394", "\\Delta", true);
      defineSymbol(math2, main, textord, "\u0398", "\\Theta", true);
      defineSymbol(math2, main, textord, "\u039B", "\\Lambda", true);
      defineSymbol(math2, main, textord, "\u039E", "\\Xi", true);
      defineSymbol(math2, main, textord, "\u03A0", "\\Pi", true);
      defineSymbol(math2, main, textord, "\u03A3", "\\Sigma", true);
      defineSymbol(math2, main, textord, "\u03A5", "\\Upsilon", true);
      defineSymbol(math2, main, textord, "\u03A6", "\\Phi", true);
      defineSymbol(math2, main, textord, "\u03A8", "\\Psi", true);
      defineSymbol(math2, main, textord, "\u03A9", "\\Omega", true);
      defineSymbol(math2, main, textord, "A", "\u0391");
      defineSymbol(math2, main, textord, "B", "\u0392");
      defineSymbol(math2, main, textord, "E", "\u0395");
      defineSymbol(math2, main, textord, "Z", "\u0396");
      defineSymbol(math2, main, textord, "H", "\u0397");
      defineSymbol(math2, main, textord, "I", "\u0399");
      defineSymbol(math2, main, textord, "K", "\u039A");
      defineSymbol(math2, main, textord, "M", "\u039C");
      defineSymbol(math2, main, textord, "N", "\u039D");
      defineSymbol(math2, main, textord, "O", "\u039F");
      defineSymbol(math2, main, textord, "P", "\u03A1");
      defineSymbol(math2, main, textord, "T", "\u03A4");
      defineSymbol(math2, main, textord, "X", "\u03A7");
      defineSymbol(math2, main, textord, "\xAC", "\\neg", true);
      defineSymbol(math2, main, textord, "\xAC", "\\lnot");
      defineSymbol(math2, main, textord, "\u22A4", "\\top");
      defineSymbol(math2, main, textord, "\u22A5", "\\bot");
      defineSymbol(math2, main, textord, "\u2205", "\\emptyset");
      defineSymbol(math2, ams, textord, "\u2205", "\\varnothing");
      defineSymbol(math2, main, mathord, "\u03B1", "\\alpha", true);
      defineSymbol(math2, main, mathord, "\u03B2", "\\beta", true);
      defineSymbol(math2, main, mathord, "\u03B3", "\\gamma", true);
      defineSymbol(math2, main, mathord, "\u03B4", "\\delta", true);
      defineSymbol(math2, main, mathord, "\u03F5", "\\epsilon", true);
      defineSymbol(math2, main, mathord, "\u03B6", "\\zeta", true);
      defineSymbol(math2, main, mathord, "\u03B7", "\\eta", true);
      defineSymbol(math2, main, mathord, "\u03B8", "\\theta", true);
      defineSymbol(math2, main, mathord, "\u03B9", "\\iota", true);
      defineSymbol(math2, main, mathord, "\u03BA", "\\kappa", true);
      defineSymbol(math2, main, mathord, "\u03BB", "\\lambda", true);
      defineSymbol(math2, main, mathord, "\u03BC", "\\mu", true);
      defineSymbol(math2, main, mathord, "\u03BD", "\\nu", true);
      defineSymbol(math2, main, mathord, "\u03BE", "\\xi", true);
      defineSymbol(math2, main, mathord, "\u03BF", "\\omicron", true);
      defineSymbol(math2, main, mathord, "\u03C0", "\\pi", true);
      defineSymbol(math2, main, mathord, "\u03C1", "\\rho", true);
      defineSymbol(math2, main, mathord, "\u03C3", "\\sigma", true);
      defineSymbol(math2, main, mathord, "\u03C4", "\\tau", true);
      defineSymbol(math2, main, mathord, "\u03C5", "\\upsilon", true);
      defineSymbol(math2, main, mathord, "\u03D5", "\\phi", true);
      defineSymbol(math2, main, mathord, "\u03C7", "\\chi", true);
      defineSymbol(math2, main, mathord, "\u03C8", "\\psi", true);
      defineSymbol(math2, main, mathord, "\u03C9", "\\omega", true);
      defineSymbol(math2, main, mathord, "\u03B5", "\\varepsilon", true);
      defineSymbol(math2, main, mathord, "\u03D1", "\\vartheta", true);
      defineSymbol(math2, main, mathord, "\u03D6", "\\varpi", true);
      defineSymbol(math2, main, mathord, "\u03F1", "\\varrho", true);
      defineSymbol(math2, main, mathord, "\u03C2", "\\varsigma", true);
      defineSymbol(math2, main, mathord, "\u03C6", "\\varphi", true);
      defineSymbol(math2, main, bin, "\u2217", "*", true);
      defineSymbol(math2, main, bin, "+", "+");
      defineSymbol(math2, main, bin, "\u2212", "-", true);
      defineSymbol(math2, main, bin, "\u22C5", "\\cdot", true);
      defineSymbol(math2, main, bin, "\u2218", "\\circ", true);
      defineSymbol(math2, main, bin, "\xF7", "\\div", true);
      defineSymbol(math2, main, bin, "\xB1", "\\pm", true);
      defineSymbol(math2, main, bin, "\xD7", "\\times", true);
      defineSymbol(math2, main, bin, "\u2229", "\\cap", true);
      defineSymbol(math2, main, bin, "\u222A", "\\cup", true);
      defineSymbol(math2, main, bin, "\u2216", "\\setminus", true);
      defineSymbol(math2, main, bin, "\u2227", "\\land");
      defineSymbol(math2, main, bin, "\u2228", "\\lor");
      defineSymbol(math2, main, bin, "\u2227", "\\wedge", true);
      defineSymbol(math2, main, bin, "\u2228", "\\vee", true);
      defineSymbol(math2, main, textord, "\u221A", "\\surd");
      defineSymbol(math2, main, open, "\u27E8", "\\langle", true);
      defineSymbol(math2, main, open, "\u2223", "\\lvert");
      defineSymbol(math2, main, open, "\u2225", "\\lVert");
      defineSymbol(math2, main, close, "?", "?");
      defineSymbol(math2, main, close, "!", "!");
      defineSymbol(math2, main, close, "\u27E9", "\\rangle", true);
      defineSymbol(math2, main, close, "\u2223", "\\rvert");
      defineSymbol(math2, main, close, "\u2225", "\\rVert");
      defineSymbol(math2, main, rel, "=", "=");
      defineSymbol(math2, main, rel, ":", ":");
      defineSymbol(math2, main, rel, "\u2248", "\\approx", true);
      defineSymbol(math2, main, rel, "\u2245", "\\cong", true);
      defineSymbol(math2, main, rel, "\u2265", "\\ge");
      defineSymbol(math2, main, rel, "\u2265", "\\geq", true);
      defineSymbol(math2, main, rel, "\u2190", "\\gets");
      defineSymbol(math2, main, rel, ">", "\\gt", true);
      defineSymbol(math2, main, rel, "\u2208", "\\in", true);
      defineSymbol(math2, main, rel, "\uE020", "\\@not");
      defineSymbol(math2, main, rel, "\u2282", "\\subset", true);
      defineSymbol(math2, main, rel, "\u2283", "\\supset", true);
      defineSymbol(math2, main, rel, "\u2286", "\\subseteq", true);
      defineSymbol(math2, main, rel, "\u2287", "\\supseteq", true);
      defineSymbol(math2, ams, rel, "\u2288", "\\nsubseteq", true);
      defineSymbol(math2, ams, rel, "\u2289", "\\nsupseteq", true);
      defineSymbol(math2, main, rel, "\u22A8", "\\models");
      defineSymbol(math2, main, rel, "\u2190", "\\leftarrow", true);
      defineSymbol(math2, main, rel, "\u2264", "\\le");
      defineSymbol(math2, main, rel, "\u2264", "\\leq", true);
      defineSymbol(math2, main, rel, "<", "\\lt", true);
      defineSymbol(math2, main, rel, "\u2192", "\\rightarrow", true);
      defineSymbol(math2, main, rel, "\u2192", "\\to");
      defineSymbol(math2, ams, rel, "\u2271", "\\ngeq", true);
      defineSymbol(math2, ams, rel, "\u2270", "\\nleq", true);
      defineSymbol(math2, main, spacing, "\xA0", "\\ ");
      defineSymbol(math2, main, spacing, "\xA0", "\\space");
      defineSymbol(math2, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(text5, main, spacing, "\xA0", "\\ ");
      defineSymbol(text5, main, spacing, "\xA0", " ");
      defineSymbol(text5, main, spacing, "\xA0", "\\space");
      defineSymbol(text5, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(math2, main, spacing, null, "\\nobreak");
      defineSymbol(math2, main, spacing, null, "\\allowbreak");
      defineSymbol(math2, main, punct, ",", ",");
      defineSymbol(math2, main, punct, ";", ";");
      defineSymbol(math2, ams, bin, "\u22BC", "\\barwedge", true);
      defineSymbol(math2, ams, bin, "\u22BB", "\\veebar", true);
      defineSymbol(math2, main, bin, "\u2299", "\\odot", true);
      defineSymbol(math2, main, bin, "\u2295", "\\oplus", true);
      defineSymbol(math2, main, bin, "\u2297", "\\otimes", true);
      defineSymbol(math2, main, textord, "\u2202", "\\partial", true);
      defineSymbol(math2, main, bin, "\u2298", "\\oslash", true);
      defineSymbol(math2, ams, bin, "\u229A", "\\circledcirc", true);
      defineSymbol(math2, ams, bin, "\u22A1", "\\boxdot", true);
      defineSymbol(math2, main, bin, "\u25B3", "\\bigtriangleup");
      defineSymbol(math2, main, bin, "\u25BD", "\\bigtriangledown");
      defineSymbol(math2, main, bin, "\u2020", "\\dagger");
      defineSymbol(math2, main, bin, "\u22C4", "\\diamond");
      defineSymbol(math2, main, bin, "\u22C6", "\\star");
      defineSymbol(math2, main, bin, "\u25C3", "\\triangleleft");
      defineSymbol(math2, main, bin, "\u25B9", "\\triangleright");
      defineSymbol(math2, main, open, "{", "\\{");
      defineSymbol(text5, main, textord, "{", "\\{");
      defineSymbol(text5, main, textord, "{", "\\textbraceleft");
      defineSymbol(math2, main, close, "}", "\\}");
      defineSymbol(text5, main, textord, "}", "\\}");
      defineSymbol(text5, main, textord, "}", "\\textbraceright");
      defineSymbol(math2, main, open, "{", "\\lbrace");
      defineSymbol(math2, main, close, "}", "\\rbrace");
      defineSymbol(math2, main, open, "[", "\\lbrack", true);
      defineSymbol(text5, main, textord, "[", "\\lbrack", true);
      defineSymbol(math2, main, close, "]", "\\rbrack", true);
      defineSymbol(text5, main, textord, "]", "\\rbrack", true);
      defineSymbol(math2, main, open, "(", "\\lparen", true);
      defineSymbol(math2, main, close, ")", "\\rparen", true);
      defineSymbol(text5, main, textord, "<", "\\textless", true);
      defineSymbol(text5, main, textord, ">", "\\textgreater", true);
      defineSymbol(math2, main, open, "\u230A", "\\lfloor", true);
      defineSymbol(math2, main, close, "\u230B", "\\rfloor", true);
      defineSymbol(math2, main, open, "\u2308", "\\lceil", true);
      defineSymbol(math2, main, close, "\u2309", "\\rceil", true);
      defineSymbol(math2, main, textord, "\\", "\\backslash");
      defineSymbol(math2, main, textord, "\u2223", "|");
      defineSymbol(math2, main, textord, "\u2223", "\\vert");
      defineSymbol(text5, main, textord, "|", "\\textbar", true);
      defineSymbol(math2, main, textord, "\u2225", "\\|");
      defineSymbol(math2, main, textord, "\u2225", "\\Vert");
      defineSymbol(text5, main, textord, "\u2225", "\\textbardbl");
      defineSymbol(text5, main, textord, "~", "\\textasciitilde");
      defineSymbol(text5, main, textord, "\\", "\\textbackslash");
      defineSymbol(text5, main, textord, "^", "\\textasciicircum");
      defineSymbol(math2, main, rel, "\u2191", "\\uparrow", true);
      defineSymbol(math2, main, rel, "\u21D1", "\\Uparrow", true);
      defineSymbol(math2, main, rel, "\u2193", "\\downarrow", true);
      defineSymbol(math2, main, rel, "\u21D3", "\\Downarrow", true);
      defineSymbol(math2, main, rel, "\u2195", "\\updownarrow", true);
      defineSymbol(math2, main, rel, "\u21D5", "\\Updownarrow", true);
      defineSymbol(math2, main, op, "\u2210", "\\coprod");
      defineSymbol(math2, main, op, "\u22C1", "\\bigvee");
      defineSymbol(math2, main, op, "\u22C0", "\\bigwedge");
      defineSymbol(math2, main, op, "\u2A04", "\\biguplus");
      defineSymbol(math2, main, op, "\u22C2", "\\bigcap");
      defineSymbol(math2, main, op, "\u22C3", "\\bigcup");
      defineSymbol(math2, main, op, "\u222B", "\\int");
      defineSymbol(math2, main, op, "\u222B", "\\intop");
      defineSymbol(math2, main, op, "\u222C", "\\iint");
      defineSymbol(math2, main, op, "\u222D", "\\iiint");
      defineSymbol(math2, main, op, "\u220F", "\\prod");
      defineSymbol(math2, main, op, "\u2211", "\\sum");
      defineSymbol(math2, main, op, "\u2A02", "\\bigotimes");
      defineSymbol(math2, main, op, "\u2A01", "\\bigoplus");
      defineSymbol(math2, main, op, "\u2A00", "\\bigodot");
      defineSymbol(math2, main, op, "\u222E", "\\oint");
      defineSymbol(math2, main, op, "\u222F", "\\oiint");
      defineSymbol(math2, main, op, "\u2230", "\\oiiint");
      defineSymbol(math2, main, op, "\u2A06", "\\bigsqcup");
      defineSymbol(math2, main, op, "\u222B", "\\smallint");
      defineSymbol(text5, main, inner, "\u2026", "\\textellipsis");
      defineSymbol(math2, main, inner, "\u2026", "\\mathellipsis");
      defineSymbol(text5, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math2, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math2, main, inner, "\u22EF", "\\@cdots", true);
      defineSymbol(math2, main, inner, "\u22F1", "\\ddots", true);
      defineSymbol(math2, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(text5, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(math2, main, accent, "\u02CA", "\\acute");
      defineSymbol(math2, main, accent, "\u02CB", "\\grave");
      defineSymbol(math2, main, accent, "\xA8", "\\ddot");
      defineSymbol(math2, main, accent, "~", "\\tilde");
      defineSymbol(math2, main, accent, "\u02C9", "\\bar");
      defineSymbol(math2, main, accent, "\u02D8", "\\breve");
      defineSymbol(math2, main, accent, "\u02C7", "\\check");
      defineSymbol(math2, main, accent, "^", "\\hat");
      defineSymbol(math2, main, accent, "\u20D7", "\\vec");
      defineSymbol(math2, main, accent, "\u02D9", "\\dot");
      defineSymbol(math2, main, accent, "\u02DA", "\\mathring");
      defineSymbol(math2, main, mathord, "\uE131", "\\@imath");
      defineSymbol(math2, main, mathord, "\uE237", "\\@jmath");
      defineSymbol(math2, main, textord, "\u0131", "\u0131");
      defineSymbol(math2, main, textord, "\u0237", "\u0237");
      defineSymbol(text5, main, textord, "\u0131", "\\i", true);
      defineSymbol(text5, main, textord, "\u0237", "\\j", true);
      defineSymbol(text5, main, textord, "\xDF", "\\ss", true);
      defineSymbol(text5, main, textord, "\xE6", "\\ae", true);
      defineSymbol(text5, main, textord, "\u0153", "\\oe", true);
      defineSymbol(text5, main, textord, "\xF8", "\\o", true);
      defineSymbol(text5, main, textord, "\xC6", "\\AE", true);
      defineSymbol(text5, main, textord, "\u0152", "\\OE", true);
      defineSymbol(text5, main, textord, "\xD8", "\\O", true);
      defineSymbol(text5, main, accent, "\u02CA", "\\'");
      defineSymbol(text5, main, accent, "\u02CB", "\\`");
      defineSymbol(text5, main, accent, "\u02C6", "\\^");
      defineSymbol(text5, main, accent, "\u02DC", "\\~");
      defineSymbol(text5, main, accent, "\u02C9", "\\=");
      defineSymbol(text5, main, accent, "\u02D8", "\\u");
      defineSymbol(text5, main, accent, "\u02D9", "\\.");
      defineSymbol(text5, main, accent, "\xB8", "\\c");
      defineSymbol(text5, main, accent, "\u02DA", "\\r");
      defineSymbol(text5, main, accent, "\u02C7", "\\v");
      defineSymbol(text5, main, accent, "\xA8", '\\"');
      defineSymbol(text5, main, accent, "\u02DD", "\\H");
      defineSymbol(text5, main, accent, "\u25EF", "\\textcircled");
      ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(text5, main, textord, "\u2013", "--", true);
      defineSymbol(text5, main, textord, "\u2013", "\\textendash");
      defineSymbol(text5, main, textord, "\u2014", "---", true);
      defineSymbol(text5, main, textord, "\u2014", "\\textemdash");
      defineSymbol(text5, main, textord, "\u2018", "`", true);
      defineSymbol(text5, main, textord, "\u2018", "\\textquoteleft");
      defineSymbol(text5, main, textord, "\u2019", "'", true);
      defineSymbol(text5, main, textord, "\u2019", "\\textquoteright");
      defineSymbol(text5, main, textord, "\u201C", "``", true);
      defineSymbol(text5, main, textord, "\u201C", "\\textquotedblleft");
      defineSymbol(text5, main, textord, "\u201D", "''", true);
      defineSymbol(text5, main, textord, "\u201D", "\\textquotedblright");
      defineSymbol(math2, main, textord, "\xB0", "\\degree", true);
      defineSymbol(text5, main, textord, "\xB0", "\\degree");
      defineSymbol(text5, main, textord, "\xB0", "\\textdegree", true);
      defineSymbol(math2, main, textord, "\xA3", "\\pounds");
      defineSymbol(math2, main, textord, "\xA3", "\\mathsterling", true);
      defineSymbol(text5, main, textord, "\xA3", "\\pounds");
      defineSymbol(text5, main, textord, "\xA3", "\\textsterling", true);
      defineSymbol(math2, ams, textord, "\u2720", "\\maltese");
      defineSymbol(text5, ams, textord, "\u2720", "\\maltese");
      mathTextSymbols = '0123456789/@."';
      for (i = 0; i < mathTextSymbols.length; i++) {
        ch = mathTextSymbols.charAt(i);
        defineSymbol(math2, main, textord, ch, ch);
      }
      textSymbols = '0123456789!@*()-=+";:?/.,';
      for (_i = 0; _i < textSymbols.length; _i++) {
        _ch = textSymbols.charAt(_i);
        defineSymbol(text5, main, textord, _ch, _ch);
      }
      letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (_i2 = 0; _i2 < letters.length; _i2++) {
        _ch2 = letters.charAt(_i2);
        defineSymbol(math2, main, mathord, _ch2, _ch2);
        defineSymbol(text5, main, textord, _ch2, _ch2);
      }
      defineSymbol(math2, ams, textord, "C", "\u2102");
      defineSymbol(text5, ams, textord, "C", "\u2102");
      defineSymbol(math2, ams, textord, "H", "\u210D");
      defineSymbol(text5, ams, textord, "H", "\u210D");
      defineSymbol(math2, ams, textord, "N", "\u2115");
      defineSymbol(text5, ams, textord, "N", "\u2115");
      defineSymbol(math2, ams, textord, "P", "\u2119");
      defineSymbol(text5, ams, textord, "P", "\u2119");
      defineSymbol(math2, ams, textord, "Q", "\u211A");
      defineSymbol(text5, ams, textord, "Q", "\u211A");
      defineSymbol(math2, ams, textord, "R", "\u211D");
      defineSymbol(text5, ams, textord, "R", "\u211D");
      defineSymbol(math2, ams, textord, "Z", "\u2124");
      defineSymbol(text5, ams, textord, "Z", "\u2124");
      defineSymbol(math2, main, mathord, "h", "\u210E");
      defineSymbol(text5, main, mathord, "h", "\u210E");
      wideChar = "";
      for (_i3 = 0; _i3 < letters.length; _i3++) {
        _ch3 = letters.charAt(_i3);
        wideChar = String.fromCharCode(55349, 56320 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56684 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + _i3);
        defineSymbol(math2, main, mathord, _ch3, wideChar);
        defineSymbol(text5, main, textord, _ch3, wideChar);
        if (_i3 < 26) {
          wideChar = String.fromCharCode(55349, 56632 + _i3);
          defineSymbol(math2, main, mathord, _ch3, wideChar);
          defineSymbol(text5, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + _i3);
          defineSymbol(math2, main, mathord, _ch3, wideChar);
          defineSymbol(text5, main, textord, _ch3, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math2, main, mathord, "k", wideChar);
      defineSymbol(text5, main, textord, "k", wideChar);
      for (_i4 = 0; _i4 < 10; _i4++) {
        _ch4 = _i4.toString();
        wideChar = String.fromCharCode(55349, 57294 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(text5, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(text5, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(text5, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + _i4);
        defineSymbol(math2, main, mathord, _ch4, wideChar);
        defineSymbol(text5, main, textord, _ch4, wideChar);
      }
      extraLatin = "\xD0\xDE\xFE";
      for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
        _ch5 = extraLatin.charAt(_i5);
        defineSymbol(math2, main, mathord, _ch5, _ch5);
        defineSymbol(text5, main, textord, _ch5, _ch5);
      }
      wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        // A-Z bold upright
        ["mathbf", "textbf", "Main-Bold"],
        // a-z bold upright
        ["mathnormal", "textit", "Math-Italic"],
        // A-Z italic
        ["mathnormal", "textit", "Math-Italic"],
        // a-z italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // A-Z bold italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // a-z bold italic
        // Map fancy A-Z letters to script, not calligraphic.
        // This aligns with unicode-math and math fonts (except Cambria Math).
        ["mathscr", "textscr", "Script-Regular"],
        // A-Z script
        ["", "", ""],
        // a-z script.  No font
        ["", "", ""],
        // A-Z bold script. No font
        ["", "", ""],
        // a-z bold script. No font
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // A-Z Fraktur
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // a-z Fraktur
        ["mathbb", "textbb", "AMS-Regular"],
        // A-Z double-struck
        ["mathbb", "textbb", "AMS-Regular"],
        // k double-struck
        // Note that we are using a bold font, but font metrics for regular Fraktur.
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // A-Z bold Fraktur
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // a-z bold Fraktur
        ["mathsf", "textsf", "SansSerif-Regular"],
        // A-Z sans-serif
        ["mathsf", "textsf", "SansSerif-Regular"],
        // a-z sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // A-Z bold sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // a-z bold sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // A-Z italic sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // a-z italic sans-serif
        ["", "", ""],
        // A-Z bold italic sans. No font
        ["", "", ""],
        // a-z bold italic sans. No font
        ["mathtt", "texttt", "Typewriter-Regular"],
        // A-Z monospace
        ["mathtt", "texttt", "Typewriter-Regular"]
        // a-z monospace
      ];
      wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        // 0-9 bold
        ["", "", ""],
        // 0-9 double-struck. No KaTeX font.
        ["mathsf", "textsf", "SansSerif-Regular"],
        // 0-9 sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // 0-9 bold sans-serif
        ["mathtt", "texttt", "Typewriter-Regular"]
        // 0-9 monospace
      ];
      wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
        var H = wideChar2.charCodeAt(0);
        var L = wideChar2.charCodeAt(1);
        var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
        var j = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new ParseError("Unsupported character: " + wideChar2);
        }
      };
      lookupSymbol = function lookupSymbol2(value, fontName, mode) {
        if (symbols[mode][value] && symbols[mode][value].replace) {
          value = symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics(value, fontName, mode)
        };
      };
      makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
        var lookup = lookupSymbol(value, fontName, mode);
        var metrics = lookup.metrics;
        value = lookup.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options && options.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        if (options) {
          symbolNode.maxFontSize = options.sizeMultiplier;
          if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color2 = options.getColor();
          if (color2) {
            symbolNode.style.color = color2;
          }
        }
        return symbolNode;
      };
      mathsym = function mathsym2(value, mode, options, classes) {
        if (classes === void 0) {
          classes = [];
        }
        if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
          return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
        } else if (value === "\\" || symbols[mode][value].font === "main") {
          return makeSymbol(value, "Main-Regular", mode, options, classes);
        } else {
          return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
        }
      };
      boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
        if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      makeOrd = function makeOrd2(group, options, type) {
        var mode = group.mode;
        var text10 = group.text;
        var classes = ["mord"];
        var isFont = mode === "math" || mode === "text" && options.font;
        var fontOrFamily = isFont ? options.font : options.fontFamily;
        var wideFontName = "";
        var wideFontClass = "";
        if (text10.charCodeAt(0) === 55349) {
          [wideFontName, wideFontClass] = wideCharacterFont(text10, mode);
        }
        if (wideFontName.length > 0) {
          return makeSymbol(text10, wideFontName, mode, options, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol(text10, mode, options, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
            fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
          }
          if (lookupSymbol(text10, fontName, mode).metrics) {
            return makeSymbol(text10, fontName, mode, options, classes.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text10) && fontName.slice(0, 10) === "Typewriter") {
            var parts = [];
            for (var i = 0; i < text10.length; i++) {
              parts.push(makeSymbol(text10[i], fontName, mode, options, classes.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol(text10, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          var font = symbols[mode][text10] && symbols[mode][text10].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
            return makeSymbol(text10, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
            return makeSymbol(text10, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
            return makeSymbol(text10, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      canCombine = (prev, next) => {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          var cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style2 in prev.style) {
          if (prev.style.hasOwnProperty(style2) && prev.style[style2] !== next.style[style2]) {
            return false;
          }
        }
        for (var _style in next.style) {
          if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
            return false;
          }
        }
        return true;
      };
      tryCombineChars = (chars) => {
        for (var i = 0; i < chars.length - 1; i++) {
          var prev = chars[i];
          var next = chars[i + 1];
          if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i + 1, 1);
            i--;
          }
        }
        return chars;
      };
      sizeElementFromChildren = function sizeElementFromChildren2(elem) {
        var height = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i = 0; i < elem.children.length; i++) {
          var child = elem.children[i];
          if (child.height > height) {
            height = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      makeSpan$2 = function makeSpan(classes, children2, options, style2) {
        var span = new Span(classes, children2, options, style2);
        sizeElementFromChildren(span);
        return span;
      };
      makeSvgSpan = (classes, children2, options, style2) => new Span(classes, children2, options, style2);
      makeLineSpan = function makeLineSpan2(className, options, thickness) {
        var line = makeSpan$2([className], [], options);
        line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
        line.style.borderBottomWidth = makeEm(line.height);
        line.maxFontSize = 1;
        return line;
      };
      makeAnchor = function makeAnchor2(href, classes, children2, options) {
        var anchor = new Anchor(href, classes, children2, options);
        sizeElementFromChildren(anchor);
        return anchor;
      };
      makeFragment = function makeFragment2(children2) {
        var fragment = new DocumentFragment(children2);
        sizeElementFromChildren(fragment);
        return fragment;
      };
      wrapFragment = function wrapFragment2(group, options) {
        if (group instanceof DocumentFragment) {
          return makeSpan$2([], [group], options);
        }
        return group;
      };
      getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children2 = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
            var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
            currPos = currPos + diff;
            children2.push({
              type: "kern",
              size
            });
            children2.push(oldChildren[i]);
          }
          return {
            children: children2,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom = params.positionData;
          for (var _i = 0; _i < params.children.length; _i++) {
            var child = params.children[_i];
            bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      makeVList = function makeVList2(params, options) {
        var {
          children: children2,
          depth
        } = getVListChildrenAndDepth(params);
        var pstrutSize = 0;
        for (var i = 0; i < children2.length; i++) {
          var child = children2[i];
          if (child.type === "elem") {
            var elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan$2(["pstrut"], []);
        pstrut.style.height = makeEm(pstrutSize);
        var realChildren = [];
        var minPos = depth;
        var maxPos = depth;
        var currPos = depth;
        for (var _i2 = 0; _i2 < children2.length; _i2++) {
          var _child = children2[_i2];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes = _child.wrapperClasses || [];
            var style2 = _child.wrapperStyle || {};
            var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style2);
            childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        var vlist = makeSpan$2(["vlist"], realChildren);
        vlist.style.height = makeEm(maxPos);
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan$2([], []);
          var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm(-minPos);
          var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
          rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan$2(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan$2(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      makeGlue = (measurement, options) => {
        var rule = makeSpan$2(["mspace"], [], options);
        var size = calculateSize(measurement, options);
        rule.style.marginRight = makeEm(size);
        return rule;
      };
      retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      fontMap = {
        // styles
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        "mathsfit": {
          variant: "sans-serif-italic",
          fontName: "SansSerif-Italic"
        },
        // "boldsymbol" is missing because they require the use of multiple fonts:
        // Math-BoldItalic and Main-Bold.  This is handled by a special case in
        // makeOrd which ends up calling boldsymbol.
        // families
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      svgData = {
        //   path, width, height
        vec: ["vec", 0.471, 0.714],
        // values from the font glyph
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        // oval to overlay the integrand
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      staticSvg = function staticSvg2(value, options) {
        var [pathName, width, height] = svgData[value];
        var path3 = new PathNode(pathName);
        var svgNode = new SvgNode([path3], {
          "width": makeEm(width),
          "height": makeEm(height),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan(["overlay"], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return span;
      };
      buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan: makeSpan$2,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      thinspace = {
        number: 3,
        unit: "mu"
      };
      mediumspace = {
        number: 4,
        unit: "mu"
      };
      thickspace = {
        number: 5,
        unit: "mu"
      };
      spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      _functions = {};
      _htmlGroupBuilders = {};
      _mathmlGroupBuilders = {};
      normalizeArgument = function normalizeArgument2(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      ordargument = function ordargument2(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      makeSpan$1 = buildCommon.makeSpan;
      binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      styleMap$1 = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i = 0; i < expression.length; i++) {
          var output = buildGroup$1(expression[i], options);
          if (output instanceof DocumentFragment) {
            var children2 = output.children;
            groups.push(...children2);
          } else {
            groups.push(output);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options;
        if (expression.length === 1) {
          var node2 = expression[0];
          if (node2.type === "sizing") {
            glueOptions = options.havingSize(node2.size);
          } else if (node2.type === "styling") {
            glueOptions = options.havingStyle(styleMap$1[node2.style]);
          }
        }
        var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
        var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, (node3, prev) => {
          var prevType = prev.classes[0];
          var type = node3.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node3.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, (node3, prev) => {
          var prevType = getTypeOfDomTree(prev);
          var type = getTypeOfDomTree(node3);
          var space2 = prevType && type ? node3.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
          if (space2) {
            return buildCommon.makeGlue(space2, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
        if (next) {
          nodes.push(next);
        }
        var i = 0;
        for (; i < nodes.length; i++) {
          var node2 = nodes[i];
          var partialGroup = checkPartialGroup(node2);
          if (partialGroup) {
            traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          var nonspace = !node2.hasClass("mspace");
          if (nonspace) {
            var result = callback(node2, prev.node);
            if (result) {
              if (prev.insertAfter) {
                prev.insertAfter(result);
              } else {
                nodes.unshift(result);
                i++;
              }
            }
          }
          if (nonspace) {
            prev.node = node2;
          } else if (isRoot && node2.hasClass("newline")) {
            prev.node = makeSpan$1(["leftmost"]);
          }
          prev.insertAfter = /* @__PURE__ */ ((index2) => (n) => {
            nodes.splice(index2 + 1, 0, n);
            i++;
          })(i);
        }
        if (next) {
          nodes.pop();
        }
      };
      checkPartialGroup = function checkPartialGroup2(node2) {
        if (node2 instanceof DocumentFragment || node2 instanceof Anchor || node2 instanceof Span && node2.hasClass("enclosing")) {
          return node2;
        }
        return null;
      };
      getOutermostNode = function getOutermostNode2(node2, side) {
        var partialGroup = checkPartialGroup(node2);
        if (partialGroup) {
          var children2 = partialGroup.children;
          if (children2.length) {
            if (side === "right") {
              return getOutermostNode2(children2[children2.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode2(children2[0], "left");
            }
          }
        }
        return node2;
      };
      getTypeOfDomTree = function getTypeOfDomTree2(node2, side) {
        if (!node2) {
          return null;
        }
        if (side) {
          node2 = getOutermostNode(node2, side);
        }
        return DomEnum[node2.classes[0]] || null;
      };
      makeNullDelimiter = function makeNullDelimiter2(options, classes) {
        var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
        return makeSpan$1(classes.concat(moreClasses));
      };
      buildGroup$1 = function buildGroup(group, options, baseOptions) {
        if (!group) {
          return makeSpan$1();
        }
        if (_htmlGroupBuilders[group.type]) {
          var groupNode = _htmlGroupBuilders[group.type](group, options);
          if (baseOptions && options.size !== baseOptions.size) {
            groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
            var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      MathNode = class {
        constructor(type, children2, classes) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children2 || [];
          this.classes = classes || [];
        }
        /**
         * Sets an attribute on a MathML node. MathML depends on attributes to convey a
         * semantic content, so this is used heavily.
         */
        setAttribute(name, value) {
          this.attributes[name] = value;
        }
        /**
         * Gets an attribute on a MathML node.
         */
        getAttribute(name) {
          return this.attributes[name];
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node2.className = createClass(this.classes);
          }
          for (var i = 0; i < this.children.length; i++) {
            if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
              var text10 = this.children[i].toText() + this.children[++i].toText();
              while (this.children[i + 1] instanceof TextNode) {
                text10 += this.children[++i].toText();
              }
              node2.appendChild(new TextNode(text10).toNode());
            } else {
              node2.appendChild(this.children[i].toNode());
            }
          }
          return node2;
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText, but escaped.
         */
        toText() {
          return this.children.map((child) => child.toText()).join("");
        }
      };
      TextNode = class {
        constructor(text10) {
          this.text = void 0;
          this.text = text10;
        }
        /**
         * Converts the text node into a DOM text node.
         */
        toNode() {
          return document.createTextNode(this.text);
        }
        /**
         * Converts the text node into escaped HTML markup
         * (representing the text itself).
         */
        toMarkup() {
          return utils.escape(this.toText());
        }
        /**
         * Converts the text node into a string
         * (representing the text itself).
         */
        toText() {
          return this.text;
        }
      };
      SpaceNode = class {
        /**
         * Create a Space node with width given in CSS ems.
         */
        constructor(width) {
          this.width = void 0;
          this.character = void 0;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = "\u200A";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = "\u2009";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = "\u2005";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node2.setAttribute("width", makeEm(this.width));
            return node2;
          }
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm(this.width) + '"/>';
          }
        }
        /**
         * Converts the math node into a string, similar to innerText.
         */
        toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        }
      };
      mathMLTree = {
        MathNode,
        TextNode,
        SpaceNode,
        newDocumentFragment
      };
      makeText = function makeText2(text10, mode, options) {
        if (symbols[mode][text10] && symbols[mode][text10].replace && text10.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text10) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
          text10 = symbols[mode][text10].replace;
        }
        return new mathMLTree.TextNode(text10);
      };
      makeRow = function makeRow2(body3) {
        if (body3.length === 1) {
          return body3[0];
        } else {
          return new mathMLTree.MathNode("mrow", body3);
        }
      };
      getVariant = function getVariant2(group, options) {
        if (options.fontFamily === "texttt") {
          return "monospace";
        } else if (options.fontFamily === "textsf") {
          if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options.fontShape === "textit") {
          return "italic";
        } else if (options.fontWeight === "textbf") {
          return "bold";
        }
        var font = options.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathsfit") {
          return "sans-serif-italic";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text10 = group.text;
        if (utils.contains(["\\imath", "\\jmath"], text10)) {
          return null;
        }
        if (symbols[mode][text10] && symbols[mode][text10].replace) {
          text10 = symbols[mode][text10].replace;
        }
        var fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text10, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      };
      buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
        if (expression.length === 1) {
          var group = buildGroup2(expression[0], options);
          if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        var groups = [];
        var lastGroup;
        for (var i = 0; i < expression.length; i++) {
          var _group = buildGroup2(expression[i], options);
          if (_group instanceof MathNode && lastGroup instanceof MathNode) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (isNumberPunctuation(_group) && lastGroup.type === "mn") {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mn" && isNumberPunctuation(lastGroup)) {
              _group.children = [...lastGroup.children, ..._group.children];
              groups.pop();
            } else if ((_group.type === "msup" || _group.type === "msub") && _group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
              var base = _group.children[0];
              if (base instanceof MathNode && base.type === "mn") {
                base.children = [...lastGroup.children, ...base.children];
                groups.pop();
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var child = _group.children[0];
                if (child instanceof TextNode && child.text.length > 0) {
                  child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      };
      buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
        return makeRow(buildExpression2(expression, options, isOrdgroup));
      };
      buildGroup2 = function buildGroup3(group, options) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          var result = _mathmlGroupBuilders[group.type](group, options);
          return result;
        } else {
          throw new ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      optionsFromSettings = function optionsFromSettings2(settings) {
        return new Options({
          style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      displayWrap = function displayWrap2(node2, settings) {
        if (settings.displayMode) {
          var classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node2 = buildCommon.makeSpan(classes, [node2]);
        }
        return node2;
      };
      buildTree = function buildTree2(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
          var _htmlNode = buildHTML(tree, options);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap(katexNode, settings);
      };
      buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
        var options = optionsFromSettings(settings);
        var htmlNode = buildHTML(tree, options);
        var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      };
      stretchyCodePoint = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        // Not a perfect match.
        xleftequilibrium: "\u21CB",
        // None better available.
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      mathMLnode = function mathMLnode2(label) {
        var node2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        node2.setAttribute("stretchy", "true");
        return node2;
      };
      katexImagesData = {
        //   path(s), minWidth, height, align
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        // CD minwwidth2.5pc
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        // The next three arrows are from the mhchem package.
        // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
        // document as \xrightarrow or \xrightleftharpoons. Those have
        // min-length = 1.75em, so we set min-length on these next three to match.
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      groupLength = function groupLength2(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      svgSpan = function svgSpan2(group, options) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label = group.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            var grp = group;
            var numChars = groupLength(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path3 = new PathNode(pathName);
            var svgNode = new SvgNode([path3], {
              "width": "100%",
              "height": makeEm(_height),
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode], options),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data = katexImagesData[label];
            var [paths, _minWidth, _viewBoxHeight] = data;
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i = 0; i < numSvgChildren; i++) {
              var _path = new PathNode(paths[i]);
              var _svgNode = new SvgNode([_path], {
                "width": "400em",
                "height": makeEm(_height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i] + " slice"
              });
              var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = makeEm(_height2);
                spans.push(_span);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        var {
          span,
          minWidth,
          height
        } = buildSvgSpan_();
        span.height = height;
        span.style.height = makeEm(height);
        if (minWidth > 0) {
          span.style.minWidth = makeEm(minWidth);
        }
        return span;
      };
      encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
        var img;
        var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon.makeSpan(["stretchy", label], [], options);
          if (label === "fbox") {
            var color2 = options.color && options.getColor();
            if (color2) {
              img.style.borderColor = color2;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode = new SvgNode(lines, {
            "width": "100%",
            "height": makeEm(totalHeight)
          });
          img = buildCommon.makeSvgSpan([], [svgNode], options);
        }
        img.height = totalHeight;
        img.style.height = makeEm(totalHeight);
        return img;
      };
      stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      htmlBuilder$a = (grp, options) => {
        var base;
        var group;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType(grp.base, "accent");
          base = group.base;
          grp.base = base;
          supSubGroup = assertSpan(buildGroup$1(grp, options));
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent");
          base = group.base;
        }
        var body3 = buildGroup$1(base, options.havingCrampedStyle());
        var mustShift = group.isShifty && utils.isCharacterBox(base);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils.getBaseElem(base);
          var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        var accentBelow = group.label === "\\c";
        var clearance = accentBelow ? body3.height + body3.depth : Math.min(body3.height, options.fontMetrics().xHeight);
        var accentBody;
        if (!group.isStretchy) {
          var accent2;
          var width;
          if (group.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options);
            width = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group.mode,
              text: group.label
            }, options, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width = accent2.width;
            if (accentBelow) {
              clearance += accent2.depth;
            }
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          var accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body3.height;
          }
          var left = skew;
          if (!accentFull) {
            left -= width / 2;
          }
          accentBody.style.left = makeEm(left);
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body3
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options);
        } else {
          accentBody = stretchy.svgSpan(group, options);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body3
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm(2 * skew) + ")",
                marginLeft: makeEm(2 * skew)
              } : void 0
            }]
          }, options);
        }
        var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      mathmlBuilder$9 = (group, options) => {
        var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
        node2.setAttribute("accent", "true");
        return node2;
      };
      NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: (context, args) => {
          var base = normalizeArgument(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base
          };
        },
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          // unless in strict mode
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          var base = args[0];
          var mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base
          };
        },
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var base = args[0];
          return {
            type: "accentUnder",
            mode: parser2.mode,
            label: funcName,
            base
          };
        },
        htmlBuilder: (group, options) => {
          var innerGroup = buildGroup$1(group.base, options);
          var accentBody = stretchy.svgSpan(group, options);
          var kern = group.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
        },
        mathmlBuilder: (group, options) => {
          var accentNode = stretchy.mathMLnode(group.label);
          var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
          node2.setAttribute("accentunder", "true");
          return node2;
        }
      });
      paddedNode = (group) => {
        var node2 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        node2.setAttribute("width", "+0.6em");
        node2.setAttribute("lspace", "0.3em");
        return node2;
      };
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          // The next 3 functions are here to support the mhchem extension.
          // Direct use of these functions is discouraged and may break someday.
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          // The next 3 functions are here only to support the {CD} environment.
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "xArrow",
            mode: parser2.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        // Flow is unable to correctly infer the type of `group`, even though it's
        // unambiguously determined from the passed-in `type` above.
        htmlBuilder(group, options) {
          var style2 = options.style;
          var newOptions = options.havingStyle(style2.sup());
          var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
          var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group.below) {
            newOptions = options.havingStyle(style2.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy.svgSpan(group, options);
          var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          var arrowNode = stretchy.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node2;
          if (group.body) {
            var upperNode = paddedNode(buildGroup2(group.body, options));
            if (group.below) {
              var lowerNode = paddedNode(buildGroup2(group.below, options));
              node2 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node2 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            var _lowerNode = paddedNode(buildGroup2(group.below, options));
            node2 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node2 = paddedNode();
            node2 = new mathMLTree.MathNode("mover", [arrowNode, node2]);
          }
          return node2;
        }
      });
      makeSpan2 = buildCommon.makeSpan;
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body3 = args[0];
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: "m" + funcName.slice(5),
            // TODO(kevinb): don't prefix with 'm'
            body: ordargument(body3),
            isCharacterBox: utils.isCharacterBox(body3)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      binrelClass = (arg) => {
        var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler(_ref2, args) {
          var {
            parser: parser2
          } = _ref2;
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler(_ref3, args) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      defineFunction({
        type: "pmb",
        names: ["\\pmb"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "pmb",
            mode: parser2.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options) {
          var elements = buildExpression$1(group.body, options, true);
          var node2 = buildCommon.makeSpan([group.mclass], elements, options);
          node2.style.textShadow = "0.02em 0.01em 0.04px";
          return node2;
        },
        mathmlBuilder(group, style2) {
          var inner2 = buildExpression2(group.body, style2);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          node2.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
          return node2;
        }
      });
      cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      newCell = () => {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      isStartOfArrow = (node2) => {
        return node2.type === "textord" && node2.text === "@";
      };
      isLabelEnd = (node2, endChar) => {
        return (node2.type === "mathord" || node2.type === "atom") && node2.text === endChar;
      };
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "cdlabel",
            mode: parser2.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder(group, options) {
          var newOptions = options.havingStyle(options.style.sup());
          var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
          label.classes.push("cd-label-" + group.side);
          label.style.bottom = makeEm(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder(group, options) {
          var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
          label = new mathMLTree.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler(_ref2, args) {
          var {
            parser: parser2
          } = _ref2;
          return {
            type: "cdlabelparent",
            mode: parser2.mode,
            fragment: args[0]
          };
        },
        htmlBuilder(group, options) {
          var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var arg = assertNodeType(args[0], "ordgroup");
          var group = arg.body;
          var number2 = "";
          for (var i = 0; i < group.length; i++) {
            var node2 = assertNodeType(group[i], "textord");
            number2 += node2.text;
          }
          var code4 = parseInt(number2);
          var text10;
          if (isNaN(code4)) {
            throw new ParseError("\\@char has non-numeric argument " + number2);
          } else if (code4 < 0 || code4 >= 1114111) {
            throw new ParseError("\\@char with invalid code point " + number2);
          } else if (code4 <= 65535) {
            text10 = String.fromCharCode(code4);
          } else {
            code4 -= 65536;
            text10 = String.fromCharCode((code4 >> 10) + 55296, (code4 & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser2.mode,
            text: text10
          };
        }
      });
      htmlBuilder$8 = (group, options) => {
        var elements = buildExpression$1(group.body, options.withColor(group.color), false);
        return buildCommon.makeFragment(elements);
      };
      mathmlBuilder$7 = (group, options) => {
        var inner2 = buildExpression2(group.body, options.withColor(group.color));
        var node2 = new mathMLTree.MathNode("mstyle", inner2);
        node2.setAttribute("mathcolor", group.color);
        return node2;
      };
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body3 = args[1];
          return {
            type: "color",
            mode: parser2.mode,
            color: color2,
            body: ordargument(body3)
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler(_ref2, args) {
          var {
            parser: parser2,
            breakOnTokenText
          } = _ref2;
          var color2 = assertNodeType(args[0], "color-token").color;
          parser2.gullet.macros.set("\\current@color", color2);
          var body3 = parser2.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser2.mode,
            color: color2,
            body: body3
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 0,
          allowedInText: true
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var size = parser2.gullet.future().text === "[" ? parser2.parseSizeGroup(true) : null;
          var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser2.mode,
            newLine,
            size: size && assertNodeType(size, "size").value
          };
        },
        // The following builders are called only at the top level,
        // not within tabular/array environments.
        htmlBuilder(group, options) {
          var span = buildCommon.makeSpan(["mspace"], [], options);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = makeEm(calculateSize(group.size, options));
            }
          }
          return span;
        },
        mathmlBuilder(group, options) {
          var node2 = new mathMLTree.MathNode("mspace");
          if (group.newLine) {
            node2.setAttribute("linebreak", "newline");
            if (group.size) {
              node2.setAttribute("height", makeEm(calculateSize(group.size, options)));
            }
          }
          return node2;
        }
      });
      globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      checkControlSequence = (tok) => {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      getRHS = (parser2) => {
        var tok = parser2.gullet.popToken();
        if (tok.text === "=") {
          tok = parser2.gullet.popToken();
          if (tok.text === " ") {
            tok = parser2.gullet.popToken();
          }
        }
        return tok;
      };
      letCommand = (parser2, name, tok, global) => {
        var macro = parser2.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            // reproduce the same behavior in expansion
            unexpandable: !parser2.gullet.isExpandable(tok.text)
          };
        }
        parser2.gullet.macros.set(name, macro, global);
      };
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
          // canâ€™t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          parser2.consumeSpaces();
          var token = parser2.fetch();
          if (globalMap[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap[token.text];
            }
            return assertNodeType(parser2.parseFunction(), "internal");
          }
          throw new ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref2) {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var tok = parser2.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters2 = [[]];
          while (parser2.gullet.future().text !== "{") {
            tok = parser2.gullet.popToken();
            if (tok.text === "#") {
              if (parser2.gullet.future().text === "{") {
                insert = parser2.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser2.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          var {
            tokens
          } = parser2.gullet.consumeArg();
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser2.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser2.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
          // canâ€™t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          var name = checkControlSequence(parser2.gullet.popToken());
          parser2.gullet.consumeSpaces();
          var tok = getRHS(parser2);
          letCommand(parser2, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
          // canâ€™t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref4) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          var name = checkControlSequence(parser2.gullet.popToken());
          var middle = parser2.gullet.popToken();
          var tok = parser2.gullet.popToken();
          letCommand(parser2, name, tok, funcName === "\\\\globalfuture");
          parser2.gullet.pushToken(tok);
          parser2.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      getMetrics = function getMetrics2(symbol, font, mode) {
        var replace2 = symbols.math[symbol] && symbols.math[symbol].replace;
        var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      styleWrap = function styleWrap2(delim, toStyle, options, classes) {
        var newOptions = options.havingBaseStyle(toStyle);
        var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      centerSpan = function centerSpan2(span, options, style2) {
        var newOptions = options.havingBaseStyle(style2);
        var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(shift);
        span.height -= shift;
        span.depth += shift;
      };
      makeSmallDelim = function makeSmallDelim2(delim, style2, center, options, mode, classes) {
        var text10 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
        var span = styleWrap(text10, style2, options, classes);
        if (center) {
          centerSpan(span, options, style2);
        }
        return span;
      };
      mathrmSize = function mathrmSize2(value, size, mode, options) {
        return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
      };
      makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
        var inner2 = mathrmSize(delim, size, mode, options);
        var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), Style$1.TEXT, options, classes);
        if (center) {
          centerSpan(span, options, Style$1.TEXT);
        }
        return span;
      };
      makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      makeInner = function makeInner2(ch, height, options) {
        var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
        var path3 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
        var svgNode = new SvgNode([path3], {
          "width": makeEm(width),
          "height": makeEm(height),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon.makeSvgSpan([], [svgNode], options);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return {
          type: "elem",
          elem: span
        };
      };
      lapInEms = 8e-3;
      lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
        var top;
        var middle;
        var repeat;
        var bottom;
        var svgLabel = "";
        var viewBoxWidth = 0;
        top = repeat = bottom = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat = bottom = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat = bottom = "\u2016";
        } else if (delim === "\\downarrow") {
          top = repeat = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top = repeat = "\u2016";
        } else if (delim === "\\updownarrow") {
          top = "\\uparrow";
          repeat = "\u23D0";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top = "\\Uparrow";
          repeat = "\u2016";
          bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat = "\u2223";
          svgLabel = "vert";
          viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat = "\u2225";
          svgLabel = "doublevert";
          viewBoxWidth = 556;
        } else if (delim === "[" || delim === "\\lbrack") {
          top = "\u23A1";
          repeat = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lbrack";
          viewBoxWidth = 667;
        } else if (delim === "]" || delim === "\\rbrack") {
          top = "\u23A4";
          repeat = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rbrack";
          viewBoxWidth = 667;
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat = top = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top = "\u23A1";
          repeat = bottom = "\u23A2";
          font = "Size4-Regular";
          svgLabel = "lceil";
          viewBoxWidth = 667;
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat = top = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top = "\u23A4";
          repeat = bottom = "\u23A5";
          font = "Size4-Regular";
          svgLabel = "rceil";
          viewBoxWidth = 667;
        } else if (delim === "(" || delim === "\\lparen") {
          top = "\u239B";
          repeat = "\u239C";
          bottom = "\u239D";
          font = "Size4-Regular";
          svgLabel = "lparen";
          viewBoxWidth = 875;
        } else if (delim === ")" || delim === "\\rparen") {
          top = "\u239E";
          repeat = "\u239F";
          bottom = "\u23A0";
          font = "Size4-Regular";
          svgLabel = "rparen";
          viewBoxWidth = 875;
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top = "\u23A7";
          middle = "\u23A8";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top = "\u23AB";
          middle = "\u23AC";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top = "\u23A7";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top = "\u23AB";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top = "\u23A7";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top = "\u23AB";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics(top, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics(repeat, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics(bottom, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        if (svgLabel.length > 0) {
          var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
          var viewBoxHeight = Math.round(realHeightTotal * 1e3);
          var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
          var path3 = new PathNode(svgLabel, pathStr);
          var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
          var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
          var svg3 = new SvgNode([path3], {
            "width": width,
            "height": height,
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
          });
          var wrapper = buildCommon.makeSvgSpan([], [svg3], options);
          wrapper.height = viewBoxHeight / 1e3;
          wrapper.style.width = width;
          wrapper.style.height = height;
          stack.push({
            type: "elem",
            elem: wrapper
          });
        } else {
          stack.push(makeGlyphSpan(bottom, font, mode));
          stack.push(lap);
          if (middle === null) {
            var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight, options));
          } else {
            var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat, _innerHeight, options));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat, _innerHeight, options));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top, font, mode));
        }
        var newOptions = options.havingBaseStyle(Style$1.TEXT);
        var inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes);
      };
      vbPad = 80;
      emPad = 0.08;
      sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
        var path3 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
        var pathNode = new PathNode(sqrtName, path3);
        var svg3 = new SvgNode([pathNode], {
          // Note: 1000:1 ratio of viewBox to document em width.
          "width": "400em",
          "height": makeEm(height),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg3], options);
      };
      makeSqrtImage = function makeSqrtImage2(height, options) {
        var newOptions = options.havingBaseSizing();
        var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraVinculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraVinculum + emPad;
          texHeight = height + extraVinculum;
          viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm(spanHeight);
        return {
          span,
          advanceWidth,
          // Calculate the actual line width.
          // This actually should depend on the chosen font -- e.g. \boldmath
          // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
          // have thicker rules.
          ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
        };
      };
      stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size, false, options, mode, classes);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
        } else {
          throw new ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      stackNeverDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      stackAlwaysDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "stack"
      }];
      stackLargeDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      delimTypeToFont = function delimTypeToFont2(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      traverseSequence = function traverseSequence2(delim, height, sequence, options) {
        var start = Math.min(2, 3 - options.style.size);
        for (var i = start; i < sequence.length; i++) {
          if (sequence[i].type === "stack") {
            break;
          }
          var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i].type === "small") {
            var newOptions = options.havingBaseStyle(sequence[i].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i];
          }
        }
        return sequence[sequence.length - 1];
      };
      makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        var delimType = traverseSequence(delim, height, sequence, options);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
        } else {
          return makeStackedDelim(delim, height, center, options, mode, classes);
        }
      };
      makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
        var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(
          // In real TeX, calculations are done using integral values which are
          // 65536 per pt, or 655360 per em. So, the division here truncates in
          // TeX but doesn't here, producing different results. If we wanted to
          // exactly match TeX's calculation, we could do
          //   Math.floor(655360 * maxDistFromAxis / 500) *
          //    delimiterFactor / 655360
          // (To see the difference, compare
          //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
          // in TeX and KaTeX)
          maxDistFromAxis / 500 * delimiterFactor,
          2 * maxDistFromAxis - delimiterExtend
        );
        return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
      };
      delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options) => {
          if (group.delim === ".") {
            return buildCommon.makeSpan([group.mclass]);
          }
          return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
        },
        mathmlBuilder: (group) => {
          var children2 = [];
          if (group.delim !== ".") {
            children2.push(makeText(group.delim, group.mode));
          }
          var node2 = new mathMLTree.MathNode("mo", children2);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node2.setAttribute("fence", "true");
          } else {
            node2.setAttribute("fence", "false");
          }
          node2.setAttribute("stretchy", "true");
          var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
          node2.setAttribute("minsize", size);
          node2.setAttribute("maxsize", size);
          return node2;
        }
      });
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var color2 = context.parser.gullet.macros.get("\\current@color");
          if (color2 && typeof color2 !== "string") {
            throw new ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color: color2
            // undefined if not set via \color
          };
        }
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          var parser2 = context.parser;
          ++parser2.leftrightDepth;
          var body3 = parser2.parseExpression(false);
          --parser2.leftrightDepth;
          parser2.expect("\\right", false);
          var right = assertNodeType(parser2.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser2.mode,
            body: body3,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: (group, options) => {
          assertParsed(group);
          var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
          var innerHeight = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i = 0; i < inner2.length; i++) {
            if (inner2[i].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner2[i].height, innerHeight);
              innerDepth = Math.max(inner2[i].depth, innerDepth);
            }
          }
          innerHeight *= options.sizeMultiplier;
          innerDepth *= options.sizeMultiplier;
          var leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i = 1; _i < inner2.length; _i++) {
              var middleDelim = inner2[_i];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          var rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
            rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options);
        },
        mathmlBuilder: (group, options) => {
          assertParsed(group);
          var inner2 = buildExpression2(group.body, options);
          if (group.left !== ".") {
            var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group.right !== ".") {
            var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options) => {
          var middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter(options, []);
          } else {
            middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
            var isMiddle = {
              delim: group.delim,
              options
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: (group, options) => {
          var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
          var middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      htmlBuilder$7 = (group, options) => {
        var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
        var label = group.label.slice(1);
        var scale = options.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils.isCharacterBox(group.body);
        if (label === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options.fontMetrics().xHeight;
        } else if (label === "phase") {
          var lineWeight = calculateSize({
            number: 0.6,
            unit: "pt"
          }, options);
          var clearance = calculateSize({
            number: 0.35,
            unit: "ex"
          }, options);
          var newOptions = options.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path3 = phasePath(viewBoxHeight);
          var svgNode = new SvgNode([new PathNode("phase", path3)], {
            "width": "400em",
            "height": makeEm(viewBoxHeight / 1e3),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
          img.style.height = makeEm(angleHeight);
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(
              options.fontMetrics().fboxrule,
              // default
              options.minRuleThickness
              // User override.
            );
            topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm(ruleThickness);
            img.style.borderRightWidth = makeEm(ruleThickness);
          }
          imgShift = inner2.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        var vlist;
        if (group.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Put the color background behind inner;
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options);
        } else {
          var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Write the \cancel stroke on top of inner.
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options);
        }
      };
      mathmlBuilder$6 = (group, options) => {
        var fboxsep = 0;
        var node2 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
        switch (group.label) {
          case "\\cancel":
            node2.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node2.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node2.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node2.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node2.setAttribute("notation", "box");
            break;
          case "\\angl":
            node2.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
            node2.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node2.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node2.setAttribute("lspace", fboxsep + "pt");
            node2.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              var thk = Math.max(
                options.fontMetrics().fboxrule,
                // default
                options.minRuleThickness
                // user override
              );
              node2.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node2.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node2.setAttribute("mathbackground", group.backgroundColor);
        }
        return node2;
      };
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body3 = args[1];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor: color2,
            body: body3
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler(_ref2, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var borderColor = assertNodeType(args[0], "color-token").color;
          var backgroundColor = assertNodeType(args[1], "color-token").color;
          var body3 = args[2];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body: body3
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler(_ref3, args) {
          var {
            parser: parser2
          } = _ref3;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler(_ref4, args) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          var body3 = args[0];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            body: body3
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler(_ref5, args) {
          var {
            parser: parser2
          } = _ref5;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      _environments = {};
      _macros = {};
      validateAmsEnvironmentContext = (context) => {
        var settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      };
      htmlBuilder$6 = function htmlBuilder(group, options) {
        var r;
        var c;
        var nr = group.body.length;
        var hLinesBeforeRow = group.hLinesBeforeRow;
        var nc = 0;
        var body3 = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(
          // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
          options.fontMetrics().arrayRuleWidth,
          options.minRuleThickness
          // User override.
        );
        var pt = 1 / options.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group.colSeparationType && group.colSeparationType === "small") {
          var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
        }
        var baselineskip = group.colSeparationType === "CD" ? calculateSize({
          number: 3,
          unit: "ex"
        }, options) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i = 0; i < hlinesInGap.length; ++i) {
            if (i > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r = 0; r < group.body.length; ++r) {
          var inrow = group.body[r];
          var height = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup$1(inrow[c], options);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c] = elt;
          }
          var rowGap = group.rowGaps[r];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize(rowGap, options);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body3[r] = outrow;
          setHLinePos(hLinesBeforeRow[r + 1]);
        }
        var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
        var colDescriptions = group.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var tagSpans = [];
        if (group.tags && group.tags.some((tag2) => tag2)) {
          for (r = 0; r < nr; ++r) {
            var rw = body3[r];
            var shift = rw.pos - offset;
            var tag = group.tags[r];
            var tagSpan = void 0;
            if (tag === true) {
              tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
            } else if (tag === false) {
              tagSpan = buildCommon.makeSpan([], [], options);
            } else {
              tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
            }
            tagSpan.depth = rw.depth;
            tagSpan.height = rw.height;
            tagSpans.push({
              type: "elem",
              elem: tagSpan,
              shift
            });
          }
        }
        for (
          c = 0, colDescrNum = 0;
          // Continue while either there are more columns or more column
          // descriptions, so trailing separators don't get lost.
          c < nc || colDescrNum < colDescriptions.length;
          ++c, ++colDescrNum
        ) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
              separator.style.height = makeEm(totalHeight);
              separator.style.borderRightWidth = makeEm(ruleThickness);
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
              var _shift = totalHeight - offset;
              if (_shift) {
                separator.style.verticalAlign = makeEm(-_shift);
              }
              cols.push(separator);
            } else {
              throw new ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
          var col = [];
          for (r = 0; r < nr; ++r) {
            var row2 = body3[r];
            var elem = row2[c];
            if (!elem) {
              continue;
            }
            var _shift2 = row2.pos - offset;
            elem.depth = row2.depth;
            elem.height = row2.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift2
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body3 = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
          var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body3,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body3 = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options);
        }
        if (tagSpans.length === 0) {
          return buildCommon.makeSpan(["mord"], [body3], options);
        } else {
          var eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: tagSpans
          }, options);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
          return buildCommon.makeFragment([body3, eqnNumCol]);
        }
      };
      alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      mathmlBuilder$5 = function mathmlBuilder(group, options) {
        var tbl = [];
        var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i = 0; i < group.body.length; i++) {
          var rw = group.body[i];
          var row2 = [];
          for (var j = 0; j < rw.length; j++) {
            row2.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options)]));
          }
          if (group.tags && group.tags[i]) {
            row2.unshift(glue);
            row2.push(glue);
            if (group.leqno) {
              row2.unshift(tag);
            } else {
              row2.push(tag);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row2));
        }
        var table2 = new mathMLTree.MathNode("mtable", tbl);
        var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table2.setAttribute("rowspacing", makeEm(gap));
        var menclose = "";
        var align = "";
        if (group.cols && group.cols.length > 0) {
          var cols = group.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i = iStart; _i < iEnd; _i++) {
            if (cols[_i].type === "align") {
              align += alignMap[cols[_i].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table2.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table2.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          var _cols = group.cols || [];
          var spacing2 = "";
          for (var _i2 = 1; _i2 < _cols.length; _i2++) {
            spacing2 += _i2 % 2 ? "0em " : "1em ";
          }
          table2.setAttribute("columnspacing", spacing2.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table2.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table2.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table2.setAttribute("columnspacing", "0.5em");
        } else {
          table2.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
          rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table2.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table2 = new mathMLTree.MathNode("menclose", [table2]);
          table2.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table2 = new mathMLTree.MathNode("mstyle", [table2]);
          table2.setAttribute("scriptlevel", "1");
        }
        return table2;
      };
      alignedHandler = function alignedHandler2(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        var cols = [];
        var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        var isSplit = context.envName === "split";
        var res = parseArray(context.parser, {
          cols,
          addJot: true,
          autoTag: isSplit ? void 0 : getAutoTag(context.envName),
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: isSplit ? 2 : void 0,
          leqno: context.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i = 0; i < args[0].body.length; i++) {
            var textord2 = assertNodeType(args[0].body[i], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res.body.forEach(function(row2) {
          for (var _i4 = 1; _i4 < row2.length; _i4 += 2) {
            var styling = assertNodeType(row2[_i4], "styling");
            var ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row2.length / 2;
            if (numMaths < curMaths) {
              throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row2[0]);
            }
          } else if (numCols < row2.length) {
            numCols = row2.length;
          }
        });
        for (var _i5 = 0; _i5 < numCols; ++_i5) {
          var align = "r";
          var pregap = 0;
          if (_i5 % 2 === 1) {
            align = "l";
          } else if (_i5 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i5] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      };
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node2 = assertSymbolNodeType(nde);
            var ca = node2.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          var res = {
            cols,
            hskipBeforeAndAfter: true,
            // \@preamble in lttab.dtx
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res, dCellStyle(context.envName));
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var delimiters2 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            var parser2 = context.parser;
            parser2.consumeSpaces();
            if (parser2.fetch().text === "[") {
              parser2.consume();
              parser2.consumeSpaces();
              colAlign = parser2.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new ParseError("Expected l or c or r", parser2.nextToken);
              }
              parser2.consume();
              parser2.consumeSpaces();
              parser2.expect("]");
              parser2.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          var numCols = Math.max(0, ...res.body.map((row2) => row2.length));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: void 0
            // \right uninfluenced by \color in array
          } : res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 0.5
          };
          var res = parseArray(context.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node2 = assertSymbolNodeType(nde);
            var ca = node2.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          var res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray(context.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              // TODO(kevinb) get the current style.
              // For now we use the metrics for TEXT style which is what we were
              // doing before.  Before attempting to get the current style we
              // should look at TeX's behavior especially for \over and matrices.
              postgap: 1
              /* 1em quad */
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          var res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          var res = {
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
      defineMacro("\\notag", "\\nonumber");
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler(context, args) {
          throw new ParseError(context.funcName + " valid only within array environment");
        }
      });
      environments = _environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i = 0; i < nameGroup.body.length; ++i) {
            envName += assertNodeType(nameGroup.body[i], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!environments.hasOwnProperty(envName)) {
              throw new ParseError("No such environment: " + envName, nameGroup);
            }
            var env2 = environments[envName];
            var {
              args: _args,
              optArgs
            } = parser2.parseArguments("\\begin{" + envName + "}", env2);
            var context = {
              mode: parser2.mode,
              envName,
              parser: parser2
            };
            var result = env2.handler(context, _args, optArgs);
            parser2.expect("\\end", false);
            var endNameToken = parser2.nextToken;
            var end = assertNodeType(parser2.parseFunction(), "environment");
            if (end.name !== envName) {
              throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
            }
            return result;
          }
          return {
            type: "environment",
            mode: parser2.mode,
            name: envName,
            nameGroup
          };
        }
      });
      htmlBuilder$5 = (group, options) => {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildGroup$1(group.body, newOptions);
      };
      mathmlBuilder$4 = (group, options) => {
        var font = group.font;
        var newOptions = options.withFont(font);
        return buildGroup2(group.body, newOptions);
      };
      fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          // styles, except \boldsymbol defined below
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathsfit",
          // families
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          // aliases, except \bm defined below
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body3 = normalizeArgument(args[0]);
          var func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser2.mode,
            font: func.slice(1),
            body: body3
          };
        },
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body3 = args[0];
          var isCharacterBox3 = utils.isCharacterBox(body3);
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(body3),
            body: [{
              type: "font",
              mode: parser2.mode,
              font: "boldsymbol",
              body: body3
            }],
            isCharacterBox: isCharacterBox3
          };
        }
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          var {
            parser: parser2,
            funcName,
            breakOnTokenText
          } = _ref3;
          var {
            mode
          } = parser2;
          var body3 = parser2.parseExpression(true, breakOnTokenText);
          var style2 = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style2,
            body: {
              type: "ordgroup",
              mode: parser2.mode,
              body: body3
            }
          };
        },
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      adjustStyle = (size, originalStyle) => {
        var style2 = originalStyle;
        if (size === "display") {
          style2 = style2.id >= Style$1.SCRIPT.id ? style2.text() : Style$1.DISPLAY;
        } else if (size === "text" && style2.size === Style$1.DISPLAY.size) {
          style2 = Style$1.TEXT;
        } else if (size === "script") {
          style2 = Style$1.SCRIPT;
        } else if (size === "scriptscript") {
          style2 = Style$1.SCRIPTSCRIPT;
        }
        return style2;
      };
      htmlBuilder$4 = (group, options) => {
        var style2 = adjustStyle(group.size, options.style);
        var nstyle = style2.fracNum();
        var dstyle = style2.fracDen();
        var newOptions;
        newOptions = options.havingStyle(nstyle);
        var numerm = buildGroup$1(group.numer, newOptions, options);
        if (group.continued) {
          var hStrut = 8.5 / options.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options.havingStyle(dstyle);
        var denomm = buildGroup$1(group.denom, newOptions, options);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize(group.barSize, options);
            rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style2.size === Style$1.DISPLAY.size || group.size === "display") {
          numShift = options.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        } else {
          var axisHeight = options.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options);
        }
        newOptions = options.havingStyle(style2);
        frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
        var delimSize;
        if (style2.size === Style$1.DISPLAY.size) {
          delimSize = options.fontMetrics().delim1;
        } else if (style2.size === Style$1.SCRIPTSCRIPT.size) {
          delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter(options, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter(options, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
      };
      mathmlBuilder$3 = (group, options) => {
        var node2 = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
        if (!group.hasBarLine) {
          node2.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize(group.barSize, options);
          node2.setAttribute("linethickness", makeEm(ruleWidth));
        }
        var style2 = adjustStyle(group.size, options.style);
        if (style2.size !== options.style.size) {
          node2 = new mathMLTree.MathNode("mstyle", [node2]);
          var isDisplay = style2.size === Style$1.DISPLAY.size ? "true" : "false";
          node2.setAttribute("displaystyle", isDisplay);
          node2.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          var withDelims = [];
          if (group.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node2);
          if (group.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node2;
      };
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          // canâ€™t be entered directly
          "\\\\bracefrac",
          "\\\\brackfrac"
          // ditto
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size,
            barSize: null
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref3;
          var replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith,
            token
          };
        }
      });
      stylArray = ["display", "text", "script", "scriptscript"];
      delimFromValue = function delimFromValue2(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler(_ref4, args) {
          var {
            parser: parser2
          } = _ref4;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          var rightNode = normalizeArgument(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          var barNode = assertNodeType(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType(styl.body[0], "textord");
              size = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler(_ref5, args) {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref5;
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: (_ref6, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref6;
          var numer = args[0];
          var barSize = assert(assertNodeType(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      htmlBuilder$3 = (grp, options) => {
        var style2 = options.style;
        var supSubGroup;
        var group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style2.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style2.sub()), options);
          group = assertNodeType(grp.base, "horizBrace");
        } else {
          group = assertNodeType(grp, "horizBrace");
        }
        var body3 = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
        var braceBody = stretchy.svgSpan(group, options);
        var vlist;
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body3
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body3.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body3
            }]
          }, options);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options);
          }
        }
        return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
      };
      mathmlBuilder$2 = (group, options) => {
        var accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
      };
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "horizBrace",
            mode: parser2.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: htmlBuilder$3,
        mathmlBuilder: mathmlBuilder$2
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          var body3 = args[1];
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body3)
          };
        },
        htmlBuilder: (group, options) => {
          var elements = buildExpression$1(group.body, options, false);
          return buildCommon.makeAnchor(group.href, [], elements, options);
        },
        mathmlBuilder: (group, options) => {
          var math3 = buildExpressionRow(group.body, options);
          if (!(math3 instanceof MathNode)) {
            math3 = new MathNode("mrow", [math3]);
          }
          math3.setAttribute("href", group.href);
          return math3;
        }
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i = 0; i < href.length; i++) {
            var c = href[i];
            if (c === "~") {
              c = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c
            });
          }
          var body3 = {
            type: "text",
            mode: parser2.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body3)
          };
        }
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "hbox",
            mode: parser2.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options) {
          var elements = buildExpression$1(group.body, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref;
          var value = assertNodeType(args[0], "raw").string;
          var body3 = args[1];
          if (parser2.settings.strict) {
            parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              var data = value.split(",");
              for (var i = 0; i < data.length; i++) {
                var keyVal = data[i].split("=");
                if (keyVal.length !== 2) {
                  throw new ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser2.settings.isTrusted(trustContext)) {
            return parser2.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser2.mode,
            attributes,
            body: ordargument(body3)
          };
        },
        htmlBuilder: (group, options) => {
          var elements = buildExpression$1(group.body, options, false);
          var classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push(...group.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon.makeSpan(classes, elements, options);
          for (var attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: (group, options) => {
          return buildExpressionRow(group.body, options);
        }
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "htmlmathml",
            mode: parser2.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        },
        htmlBuilder: (group, options) => {
          var elements = buildExpression$1(group.html, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          return buildExpressionRow(group.mathml, options);
        }
      });
      sizeData = function sizeData2(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {
            number: +str,
            unit: "bp"
          };
        } else {
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
          if (!match) {
            throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
          }
          var data = {
            number: +(match[1] + match[2]),
            // sign + magnitude, cast to number
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
          }
          return data;
        }
      };
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: (_ref, args, optArgs) => {
          var {
            parser: parser2
          } = _ref;
          var width = {
            number: 0,
            unit: "em"
          };
          var height = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i = 0; i < attributes.length; i++) {
              var keyVal = attributes[i].split("=");
              if (keyVal.length === 2) {
                var str = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str;
                    break;
                  case "width":
                    width = sizeData(str);
                    break;
                  case "height":
                    height = sizeData(str);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str);
                    break;
                  default:
                    throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser2.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser2.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser2.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: (group, options) => {
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
          }
          var width = 0;
          if (group.width.number > 0) {
            width = calculateSize(group.width, options);
          }
          var style2 = {
            height: makeEm(height + depth)
          };
          if (width > 0) {
            style2.width = makeEm(width);
          }
          if (depth > 0) {
            style2.verticalAlign = makeEm(-depth);
          }
          var node2 = new Img(group.src, group.alt, style2);
          node2.height = height;
          node2.depth = depth;
          return node2;
        },
        mathmlBuilder: (group, options) => {
          var node2 = new mathMLTree.MathNode("mglyph", []);
          node2.setAttribute("alt", group.alt);
          var height = calculateSize(group.height, options);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options) - height;
            node2.setAttribute("valign", makeEm(-depth));
          }
          node2.setAttribute("height", makeEm(height + depth));
          if (group.width.number > 0) {
            var width = calculateSize(group.width, options);
            node2.setAttribute("width", makeEm(width));
          }
          node2.setAttribute("src", group.src);
          return node2;
        }
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var size = assertNodeType(args[0], "size");
          if (parser2.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
              }
              if (parser2.mode !== "math") {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser2.mode,
            dimension: size.value
          };
        },
        htmlBuilder(group, options) {
          return buildCommon.makeGlue(group.dimension, options);
        },
        mathmlBuilder(group, options) {
          var dimension = calculateSize(group.dimension, options);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body3 = args[0];
          return {
            type: "lap",
            mode: parser2.mode,
            alignment: funcName.slice(5),
            body: body3
          };
        },
        htmlBuilder: (group, options) => {
          var inner2;
          if (group.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
          }
          var fix = buildCommon.makeSpan(["fix"], []);
          var node2 = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
          var strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = makeEm(node2.height + node2.depth);
          if (node2.depth) {
            strut.style.verticalAlign = makeEm(-node2.depth);
          }
          node2.children.unshift(strut);
          node2 = buildCommon.makeSpan(["thinbox"], [node2], options);
          return buildCommon.makeSpan(["mord", "vbox"], [node2], options);
        },
        mathmlBuilder: (group, options) => {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
          if (group.alignment !== "rlap") {
            var offset = group.alignment === "llap" ? "-1" : "-0.5";
            node2.setAttribute("lspace", offset + "width");
          }
          node2.setAttribute("width", "0px");
          return node2;
        }
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(_ref, args) {
          var {
            funcName,
            parser: parser2
          } = _ref;
          var outerMode = parser2.mode;
          parser2.switchMode("math");
          var close2 = funcName === "\\(" ? "\\)" : "$";
          var body3 = parser2.parseExpression(false, close2);
          parser2.expect(close2);
          parser2.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser2.mode,
            style: "text",
            body: body3
          };
        }
      });
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(context, args) {
          throw new ParseError("Mismatched " + context.funcName);
        }
      });
      chooseMathStyle = (group, options) => {
        switch (options.style.size) {
          case Style$1.DISPLAY.size:
            return group.display;
          case Style$1.TEXT.size:
            return group.text;
          case Style$1.SCRIPT.size:
            return group.script;
          case Style$1.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "mathchoice",
            mode: parser2.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        },
        htmlBuilder: (group, options) => {
          var body3 = chooseMathStyle(group, options);
          var elements = buildExpression$1(body3, options, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          var body3 = chooseMathStyle(group, options);
          return buildExpressionRow(body3, options);
        }
      });
      assembleSupSub = (base, supGroup, subGroup, options, style2, slant, baseShift) => {
        base = buildCommon.makeSpan([], [base]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        var sub2;
        var sup2;
        if (supGroup) {
          var elem = buildGroup$1(supGroup, options.havingStyle(style2.sup()), options);
          sup2 = {
            elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup$1(subGroup, options.havingStyle(style2.sub()), options);
          sub2 = {
            elem: _elem,
            kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup2 && sub2) {
          var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else if (sub2) {
          var top = base.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options);
        } else if (sup2) {
          var _bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options.fontMetrics().bigOpSpacing5
            }]
          }, options);
        } else {
          return base;
        }
        var parts = [finalGroup];
        if (sub2 && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon.makeSpan(["mspace"], [], options);
          spacer.style.marginRight = makeEm(slant);
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
      };
      noSuccessor = ["\\smallint"];
      htmlBuilder$2 = (grp, options) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "op");
        }
        var style2 = options.style;
        var large = false;
        if (style2.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
          large = true;
        }
        var base;
        if (group.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.slice(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base.italic;
            var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
            base = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options);
            group.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (group.body) {
          var inner2 = buildExpression$1(group.body, options, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base = inner2[0];
            base.classes[0] = "mop";
          } else {
            base = buildCommon.makeSpan(["mop"], inner2, options);
          }
        } else {
          var output = [];
          for (var i = 1; i < group.name.length; i++) {
            output.push(buildCommon.mathsym(group.name[i], group.mode, options));
          }
          base = buildCommon.makeSpan(["mop"], output, options);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
          slant = base.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, style2, slant, baseShift);
        } else {
          if (baseShift) {
            base.style.position = "relative";
            base.style.top = makeEm(baseShift);
          }
          return base;
        }
      };
      mathmlBuilder$1 = (group, options) => {
        var node2;
        if (group.symbol) {
          node2 = new MathNode("mo", [makeText(group.name, group.mode)]);
          if (utils.contains(noSuccessor, group.name)) {
            node2.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node2 = new MathNode("mo", buildExpression2(group.body, options));
        } else {
          node2 = new MathNode("mi", [new TextNode(group.name.slice(1))]);
          var operator = new MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            node2 = new MathNode("mrow", [node2, operator]);
          } else {
            node2 = newDocumentFragment([node2, operator]);
          }
        }
        return node2;
      };
      singleCharBigOps = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body3 = args[0];
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body3)
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      singleCharIntegrals = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler(_ref4) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler(_ref5) {
          var {
            parser: parser2,
            funcName
          } = _ref5;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      htmlBuilder$1 = (grp, options) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "operatorname");
        }
        var base;
        if (group.body.length > 0) {
          var body3 = group.body.map((child2) => {
            var childText = child2.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child2.mode,
                text: childText
              };
            } else {
              return child2;
            }
          });
          var expression = buildExpression$1(body3, options.withFont("mathrm"), true);
          for (var i = 0; i < expression.length; i++) {
            var child = expression[i];
            if (child instanceof SymbolNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base = buildCommon.makeSpan(["mop"], expression, options);
        } else {
          base = buildCommon.makeSpan(["mop"], [], options);
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
        } else {
          return base;
        }
      };
      mathmlBuilder2 = (group, options) => {
        var expression = buildExpression2(group.body, options.withFont("mathrm"));
        var isAllString = true;
        for (var i = 0; i < expression.length; i++) {
          var node2 = expression[i];
          if (node2 instanceof mathMLTree.SpaceNode) ;
          else if (node2 instanceof mathMLTree.MathNode) {
            switch (node2.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              // Do nothing yet.
              case "mo": {
                var child = node2.children[0];
                if (node2.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map((node3) => node3.toText()).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        var identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body3 = args[0];
          return {
            type: "operatorname",
            mode: parser2.mode,
            body: ordargument(body3),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: htmlBuilder$1,
        mathmlBuilder: mathmlBuilder2
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder(group, options) {
          if (group.semisimple) {
            return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
        },
        mathmlBuilder(group, options) {
          return buildExpressionRow(group.body, options, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var body3 = args[0];
          return {
            type: "overline",
            mode: parser2.mode,
            body: body3
          };
        },
        htmlBuilder(group, options) {
          var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
          var line = buildCommon.makeLineSpan("overline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
          node2.setAttribute("accent", "true");
          return node2;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          var body3 = args[0];
          return {
            type: "phantom",
            mode: parser2.mode,
            body: ordargument(body3)
          };
        },
        htmlBuilder: (group, options) => {
          var elements = buildExpression$1(group.body, options.withPhantom(), false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options) => {
          var inner2 = buildExpression2(group.body, options);
          return new mathMLTree.MathNode("mphantom", inner2);
        }
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body3 = args[0];
          return {
            type: "hphantom",
            mode: parser2.mode,
            body: body3
          };
        },
        htmlBuilder: (group, options) => {
          var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
          node2.height = 0;
          node2.depth = 0;
          if (node2.children) {
            for (var i = 0; i < node2.children.length; i++) {
              node2.children[i].height = 0;
              node2.children[i].depth = 0;
            }
          }
          node2 = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node2
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [node2], options);
        },
        mathmlBuilder: (group, options) => {
          var inner2 = buildExpression2(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
          node2.setAttribute("height", "0px");
          node2.setAttribute("depth", "0px");
          return node2;
        }
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          var {
            parser: parser2
          } = _ref3;
          var body3 = args[0];
          return {
            type: "vphantom",
            mode: parser2.mode,
            body: body3
          };
        },
        htmlBuilder: (group, options) => {
          var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
          var fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
        },
        mathmlBuilder: (group, options) => {
          var inner2 = buildExpression2(ordargument(group.body), options);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
          node2.setAttribute("width", "0px");
          return node2;
        }
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var amount = assertNodeType(args[0], "size").value;
          var body3 = args[1];
          return {
            type: "raisebox",
            mode: parser2.mode,
            dy: amount,
            body: body3
          };
        },
        htmlBuilder(group, options) {
          var body3 = buildGroup$1(group.body, options);
          var dy = calculateSize(group.dy, options);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body3
            }]
          }, options);
        },
        mathmlBuilder(group, options) {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
          var dy = group.dy.number + group.dy.unit;
          node2.setAttribute("voffset", dy);
          return node2;
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\relax"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInArgument: true
        },
        handler(_ref) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["size", "size", "size"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var shift = optArgs[0];
          var width = assertNodeType(args[0], "size");
          var height = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser2.mode,
            shift: shift && assertNodeType(shift, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder(group, options) {
          var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift = group.shift ? calculateSize(group.shift, options) : 0;
          rule.style.borderRightWidth = makeEm(width);
          rule.style.borderTopWidth = makeEm(height);
          rule.style.bottom = makeEm(shift);
          rule.width = width;
          rule.height = height + shift;
          rule.depth = -shift;
          rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
          return rule;
        },
        mathmlBuilder(group, options) {
          var width = calculateSize(group.width, options);
          var height = calculateSize(group.height, options);
          var shift = group.shift ? calculateSize(group.shift, options) : 0;
          var color2 = options.color && options.getColor() || "black";
          var rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color2);
          rule.setAttribute("width", makeEm(width));
          rule.setAttribute("height", makeEm(height));
          var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift >= 0) {
            wrapper.setAttribute("height", makeEm(shift));
          } else {
            wrapper.setAttribute("height", makeEm(shift));
            wrapper.setAttribute("depth", makeEm(-shift));
          }
          wrapper.setAttribute("voffset", makeEm(shift));
          return wrapper;
        }
      });
      sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      htmlBuilder2 = (group, options) => {
        var newOptions = options.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options);
      };
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            breakOnTokenText,
            funcName,
            parser: parser2
          } = _ref;
          var body3 = parser2.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser2.mode,
            // Figure out what size to use based on the list of functions above
            size: sizeFuncs.indexOf(funcName) + 1,
            body: body3
          };
        },
        htmlBuilder: htmlBuilder2,
        mathmlBuilder: (group, options) => {
          var newOptions = options.havingSize(group.size);
          var inner2 = buildExpression2(group.body, newOptions);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          node2.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
          return node2;
        }
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args, optArgs) => {
          var {
            parser: parser2
          } = _ref;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i = 0; i < tbArg.body.length; ++i) {
              var node2 = tbArg.body[i];
              letter = node2.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body3 = args[0];
          return {
            type: "smash",
            mode: parser2.mode,
            body: body3,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: (group, options) => {
          var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node2;
          }
          if (group.smashHeight) {
            node2.height = 0;
            if (node2.children) {
              for (var i = 0; i < node2.children.length; i++) {
                node2.children[i].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node2.depth = 0;
            if (node2.children) {
              for (var _i = 0; _i < node2.children.length; _i++) {
                node2.children[_i].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node2
            }]
          }, options);
          return buildCommon.makeSpan(["mord"], [smashedNode], options);
        },
        mathmlBuilder: (group, options) => {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
          if (group.smashHeight) {
            node2.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node2.setAttribute("depth", "0px");
          }
          return node2;
        }
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var index2 = optArgs[0];
          var body3 = args[0];
          return {
            type: "sqrt",
            mode: parser2.mode,
            body: body3,
            index: index2
          };
        },
        htmlBuilder(group, options) {
          var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options);
          var metrics = options.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options.style.id < Style$1.TEXT.id) {
            phi = options.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          var {
            span: img,
            ruleWidth,
            advanceWidth
          } = delimiter.sqrtImage(minDelimiterHeight, options);
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = makeEm(advanceWidth);
          var body3 = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options);
          if (!group.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body3], options);
          } else {
            var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
            var rootm = buildGroup$1(group.index, newOptions, options);
            var toShift = 0.6 * (body3.height - body3.depth);
            var rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options);
            var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body3], options);
          }
        },
        mathmlBuilder(group, options) {
          var {
            body: body3,
            index: index2
          } = group;
          return index2 ? new mathMLTree.MathNode("mroot", [buildGroup2(body3, options), buildGroup2(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body3, options)]);
        }
      });
      styleMap = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            breakOnTokenText,
            funcName,
            parser: parser2
          } = _ref;
          var body3 = parser2.parseExpression(true, breakOnTokenText);
          var style2 = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser2.mode,
            // Figure out what style to use by pulling out the style from
            // the function name
            style: style2,
            body: body3
          };
        },
        htmlBuilder(group, options) {
          var newStyle = styleMap[group.style];
          var newOptions = options.havingStyle(newStyle).withFont("");
          return sizingGroup(group.body, newOptions, options);
        },
        mathmlBuilder(group, options) {
          var newStyle = styleMap[group.style];
          var newOptions = options.havingStyle(newStyle);
          var inner2 = buildExpression2(group.body, newOptions);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group.style];
          node2.setAttribute("scriptlevel", attr[0]);
          node2.setAttribute("displaystyle", attr[1]);
          return node2;
        }
      });
      htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
        var base = group.base;
        if (!base) {
          return null;
        } else if (base.type === "op") {
          var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
          return delegate ? htmlBuilder$2 : null;
        } else if (base.type === "operatorname") {
          var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
          return _delegate ? htmlBuilder$1 : null;
        } else if (base.type === "accent") {
          return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
        } else if (base.type === "horizBrace") {
          var isSup = !group.sub;
          return isSup === base.isOver ? htmlBuilder$3 : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder(group, options) {
          var builderDelegate = htmlBuilderDelegate(group, options);
          if (builderDelegate) {
            return builderDelegate(group, options);
          }
          var {
            base: valueBase,
            sup: valueSup,
            sub: valueSub
          } = group;
          var base = buildGroup$1(valueBase, options);
          var supm;
          var subm;
          var metrics = options.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options.havingStyle(options.style.sup());
            supm = buildGroup$1(valueSup, newOptions, options);
            if (!isCharacterBox3) {
              supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options.havingStyle(options.style.sub());
            subm = buildGroup$1(valueSub, _newOptions, options);
            if (!isCharacterBox3) {
              subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options.style === Style$1.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options.sizeMultiplier;
          var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
          var marginLeft = null;
          if (subm) {
            var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base instanceof SymbolNode || isOiint) {
              marginLeft = makeEm(-base.italic);
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree(base, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
        },
        mathmlBuilder(group, options) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          var children2 = [buildGroup2(group.base, options)];
          if (group.sub) {
            children2.push(buildGroup2(group.sub, options));
          }
          if (group.sup) {
            children2.push(buildGroup2(group.sup, options));
          }
          var nodeType;
          if (isBrace) {
            nodeType = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            var base = group.base;
            if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType = "mover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
              nodeType = "mover";
            } else {
              nodeType = "msup";
            }
          } else if (!group.sup) {
            var _base = group.base;
            if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
              nodeType = "munder";
            } else {
              nodeType = "msub";
            }
          } else {
            var _base2 = group.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
              nodeType = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
              nodeType = "munderover";
            } else {
              nodeType = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType, children2);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder(group, options) {
          return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
        },
        mathmlBuilder(group, options) {
          var node2 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
          if (group.family === "bin") {
            var variant = getVariant(group, options);
            if (variant === "bold-italic") {
              node2.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node2.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node2.setAttribute("stretchy", "false");
          }
          return node2;
        }
      });
      defaultVariant = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder(group, options) {
          return buildCommon.makeOrd(group, options, "mathord");
        },
        mathmlBuilder(group, options) {
          var node2 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
          var variant = getVariant(group, options) || "italic";
          if (variant !== defaultVariant[node2.type]) {
            node2.setAttribute("mathvariant", variant);
          }
          return node2;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder(group, options) {
          return buildCommon.makeOrd(group, options, "textord");
        },
        mathmlBuilder(group, options) {
          var text10 = makeText(group.text, group.mode, options);
          var variant = getVariant(group, options) || "normal";
          var node2;
          if (group.mode === "text") {
            node2 = new mathMLTree.MathNode("mtext", [text10]);
          } else if (/[0-9]/.test(group.text)) {
            node2 = new mathMLTree.MathNode("mn", [text10]);
          } else if (group.text === "\\prime") {
            node2 = new mathMLTree.MathNode("mo", [text10]);
          } else {
            node2 = new mathMLTree.MathNode("mi", [text10]);
          }
          if (variant !== defaultVariant[node2.type]) {
            node2.setAttribute("mathvariant", variant);
          }
          return node2;
        }
      });
      cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder(group, options) {
          if (regularSpace.hasOwnProperty(group.text)) {
            var className = regularSpace[group.text].className || "";
            if (group.mode === "text") {
              var ord = buildCommon.makeOrd(group, options, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
            }
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
          } else {
            throw new ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder(group, options) {
          var node2;
          if (regularSpace.hasOwnProperty(group.text)) {
            node2 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new ParseError('Unknown type of space "' + group.text + '"');
          }
          return node2;
        }
      });
      pad = () => {
        var padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder(group, options) {
          var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
          table2.setAttribute("width", "100%");
          return table2;
        }
      });
      textFontFamilies = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      optionsWithFont = (group, options) => {
        var font = group.font;
        if (!font) {
          return options;
        } else if (textFontFamilies[font]) {
          return options.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options.withTextFontWeight(textFontWeights[font]);
        } else if (font === "\\emph") {
          return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
        }
        return options.withTextFontShape(textFontShapes[font]);
      };
      defineFunction({
        type: "text",
        names: [
          // Font families
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          // Font weights
          "\\textbf",
          "\\textmd",
          // Font Shapes
          "\\textit",
          "\\textup",
          "\\emph"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body3 = args[0];
          return {
            type: "text",
            mode: parser2.mode,
            body: ordargument(body3),
            font: funcName
          };
        },
        htmlBuilder(group, options) {
          var newOptions = optionsWithFont(group, options);
          var inner2 = buildExpression$1(group.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder(group, options) {
          var newOptions = optionsWithFont(group, options);
          return buildExpressionRow(group.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "underline",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options) {
          var innerGroup = buildGroup$1(group.body, options);
          var line = buildCommon.makeLineSpan("underline-line", options);
          var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
        },
        mathmlBuilder(group, options) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
          node2.setAttribute("accentunder", "true");
          return node2;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          // In LaTeX, \vcenter can act only on a box.
          allowedInText: false
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "vcenter",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options) {
          var body3 = buildGroup$1(group.body, options);
          var axisHeight = options.fontMetrics().axisHeight;
          var dy = 0.5 * (body3.height - axisHeight - (body3.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body3
            }]
          }, options);
        },
        mathmlBuilder(group, options) {
          return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(context, args, optArgs) {
          throw new ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder(group, options) {
          var text10 = makeVerb(group);
          var body3 = [];
          var newOptions = options.havingStyle(options.style.text());
          for (var i = 0; i < text10.length; i++) {
            var c = text10[i];
            if (c === "~") {
              c = "\\textasciitilde";
            }
            body3.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body3), newOptions);
        },
        mathmlBuilder(group, options) {
          var text10 = new mathMLTree.TextNode(makeVerb(group));
          var node2 = new mathMLTree.MathNode("mtext", [text10]);
          node2.setAttribute("mathvariant", "monospace");
          return node2;
        }
      });
      makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
      functions = _functions;
      spaceRegexString = "[ \r\n	]";
      controlWordRegexString = "\\\\[a-zA-Z@]+";
      controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      combiningDiacriticalMarkString = "[\u0300-\u036F]";
      combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
      (controlSpaceRegexString + "|") + // \whitespace
      "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
      ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
      ("|" + controlSymbolRegexString + ")");
      Lexer = class {
        // Category codes. The lexer only supports comment characters (14) for now.
        // MacroExpander additionally distinguishes active (13).
        constructor(input, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            // comment character
            "~": 13
            // active character
          };
        }
        setCatcode(char, code4) {
          this.catcodes[char] = code4;
        }
        /**
         * This function lexes a single token.
         */
        lex() {
          var input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          var match = this.tokenRegex.exec(input);
          if (match === null || match.index !== pos) {
            throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          var text10 = match[6] || match[3] || (match[2] ? "\\ " : " ");
          if (this.catcodes[text10] === 14) {
            var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token(text10, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        }
      };
      Namespace = class {
        /**
         * Both arguments are optional.  The first argument is an object of
         * built-in mappings which never change.  The second argument is an object
         * of initial (global-level) mappings, which will constantly change
         * according to any global/top-level `set`s done.
         */
        constructor(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        /**
         * Start a new nested group, affecting future local `set`s.
         */
        beginGroup() {
          this.undefStack.push({});
        }
        /**
         * End current nested group, restoring values before the group began.
         */
        endGroup() {
          if (this.undefStack.length === 0) {
            throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] == null) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        }
        /**
         * Detect whether `name` has a definition.  Equivalent to
         * `get(name) != null`.
         */
        has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        }
        /**
         * Get the current value of a name, or `undefined` if there is no value.
         *
         * Note: Do not use `if (namespace.get(...))` to detect whether a macro
         * is defined, as the definition may be the empty string which evaluates
         * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
         * `if (namespace.has(...))`.
         */
        get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        }
        /**
         * Set the current value of a name, and optionally set it globally too.
         * Local set() sets the current value and (when appropriate) adds an undo
         * operation to the undo stack.  Global set() may change the undo
         * operation at every level, so takes time linear in their number.
         * A value of undefined means to delete existing definitions.
         */
        set(name, value, global) {
          if (global === void 0) {
            global = false;
          }
          if (global) {
            for (var i = 0; i < this.undefStack.length; i++) {
              delete this.undefStack[i][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            var top = this.undefStack[this.undefStack.length - 1];
            if (top && !top.hasOwnProperty(name)) {
              top[name] = this.current[name];
            }
          }
          if (value == null) {
            delete this.current[name];
          } else {
            this.current[name] = value;
          }
        }
      };
      macros = _macros;
      defineMacro("\\noexpand", function(context) {
        var t = context.popToken();
        if (context.isExpandable(t.text)) {
          t.noexpand = true;
          t.treatAsRelax = true;
        }
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        var t = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        var args = context.consumeArgs(3);
        context.consumeSpaces();
        var nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        var args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro("\\char", function(context) {
        var token = context.popToken();
        var base;
        var number2 = "";
        if (token.text === "'") {
          base = 8;
          token = context.popToken();
        } else if (token.text === '"') {
          base = 16;
          token = context.popToken();
        } else if (token.text === "`") {
          token = context.popToken();
          if (token.text[0] === "\\") {
            number2 = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new ParseError("\\char` missing argument");
          } else {
            number2 = token.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number2 = digitToNumber[token.text];
          if (number2 == null || number2 >= base) {
            throw new ParseError("Invalid base-" + base + " digit " + token.text);
          }
          var digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
            number2 *= base;
            number2 += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number2 + "}";
      });
      newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
        var arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token = context.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        if (!(exists && skipIfExists)) {
          context.macros.set(name, {
            tokens: arg,
            numArgs
          });
        }
        return "";
      };
      defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
      defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
      defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
      defineMacro("\\message", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\errmessage", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\show", (context) => {
        var tok = context.popToken();
        var name = tok.text;
        console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro("\u212C", "\\mathscr{B}");
      defineMacro("\u2130", "\\mathscr{E}");
      defineMacro("\u2131", "\\mathscr{F}");
      defineMacro("\u210B", "\\mathscr{H}");
      defineMacro("\u2110", "\\mathscr{I}");
      defineMacro("\u2112", "\\mathscr{L}");
      defineMacro("\u2133", "\\mathscr{M}");
      defineMacro("\u211B", "\\mathscr{R}");
      defineMacro("\u212D", "\\mathfrak{C}");
      defineMacro("\u210C", "\\mathfrak{H}");
      defineMacro("\u2128", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("\xB7", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("\u2260", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro("\u2209", "\\notin");
      defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro("\u27C2", "\\perp");
      defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("\u220C", "\\notni");
      defineMacro("\u231C", "\\ulcorner");
      defineMacro("\u231D", "\\urcorner");
      defineMacro("\u231E", "\\llcorner");
      defineMacro("\u231F", "\\lrcorner");
      defineMacro("\xA9", "\\copyright");
      defineMacro("\xAE", "\\textregistered");
      defineMacro("\uFE0F", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("\u22EE", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
      defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
      dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        // \keybin@ checks for the following:
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        // Symbols whose definition starts with \DOTSB:
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        // Symbols whose definition starts with \mathbin:
        "\\mathbin": "\\dotsb",
        // Symbols whose definition starts with \mathrel:
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        // Symbols whose definition starts with \DOTSI:
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        // Symbols whose definition starts with \DOTSX:
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        var thedots = "\\dotso";
        var next = context.expandAfterFuture().text;
        if (next in dotsByToken) {
          thedots = dotsByToken[next];
        } else if (next.slice(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in symbols.math) {
          if (utils.contains(["bin", "rel"], symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      spaceAfterDots = {
        // \rightdelim@ checks for the following:
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        // \extra@ also tests for the following:
        "$": true,
        // \extrap@ checks for the following:
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", (context) => {
        if (context.macros.get("\\df@tag")) {
          throw new ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("\u2237", "\\dblcolon");
      defineMacro("\u2239", "\\eqcolon");
      defineMacro("\u2254", "\\coloneqq");
      defineMacro("\u2255", "\\eqqcolon");
      defineMacro("\u2A74", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro("\u27E6", "\\llbracket");
      defineMacro("\u27E7", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro("\u2983", "\\lBrace");
      defineMacro("\u2984", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro("\u29B5", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      braketHelper = (one4) => (context) => {
        var left = context.consumeArg().tokens;
        var middle = context.consumeArg().tokens;
        var middleDouble = context.consumeArg().tokens;
        var right = context.consumeArg().tokens;
        var oldMiddle = context.macros.get("|");
        var oldMiddleDouble = context.macros.get("\\|");
        context.macros.beginGroup();
        var midMacro = (double) => (context2) => {
          if (one4) {
            context2.macros.set("|", oldMiddle);
            if (middleDouble.length) {
              context2.macros.set("\\|", oldMiddleDouble);
            }
          }
          var doubled = double;
          if (!double && middleDouble.length) {
            var nextToken = context2.future();
            if (nextToken.text === "|") {
              context2.popToken();
              doubled = true;
            }
          }
          return {
            tokens: doubled ? middleDouble : middle,
            numArgs: 0
          };
        };
        context.macros.set("|", midMacro(false));
        if (middleDouble.length) {
          context.macros.set("\\|", midMacro(true));
        }
        var arg = context.consumeArg().tokens;
        var expanded = context.expandTokens([
          ...right,
          ...arg,
          ...left
          // reversed
        ]);
        context.macros.endGroup();
        return {
          tokens: expanded.reverse(),
          numArgs: 0
        };
      };
      defineMacro("\\bra@ket", braketHelper(false));
      defineMacro("\\bra@set", braketHelper(true));
      defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
      defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
      defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      implicitCommands = {
        "^": true,
        // Parser.js
        "_": true,
        // Parser.js
        "\\limits": true,
        // Parser.js
        "\\nolimits": true
        // Parser.js
      };
      MacroExpander = class {
        constructor(input, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        /**
         * Feed a new input string to the same MacroExpander
         * (with existing macros etc.).
         */
        feed(input) {
          this.lexer = new Lexer(input, this.settings);
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
        }
        /**
         * Start a new group nesting within all namespaces.
         */
        beginGroup() {
          this.macros.beginGroup();
        }
        /**
         * End current group nesting within all namespaces.
         */
        endGroup() {
          this.macros.endGroup();
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          this.macros.endGroups();
        }
        /**
         * Returns the topmost token on the stack, without expanding it.
         * Similar in behavior to TeX's `\futurelet`.
         */
        future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        }
        /**
         * Remove and return the next unexpanded token.
         */
        popToken() {
          this.future();
          return this.stack.pop();
        }
        /**
         * Add a given token to the token stack.  In particular, this get be used
         * to put back a token returned from one of the other methods.
         */
        pushToken(token) {
          this.stack.push(token);
        }
        /**
         * Append an array of tokens to the token stack.
         */
        pushTokens(tokens) {
          this.stack.push(...tokens);
        }
        /**
         * Find an macro argument without expanding tokens and append the array of
         * tokens to the token stack. Uses Token as a container for the result.
         */
        scanArgument(isOptional) {
          var start;
          var end;
          var tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start = this.popToken();
            ({
              tokens,
              end
            } = this.consumeArg(["]"]));
          } else {
            ({
              tokens,
              start,
              end
            } = this.consumeArg());
          }
          this.pushToken(new Token("EOF", end.loc));
          this.pushTokens(tokens);
          return start.range(end, "");
        }
        /**
         * Consume all following space tokens, without expansion.
         */
        consumeSpaces() {
          for (; ; ) {
            var token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        }
        /**
         * Consume an argument from the token stream, and return the resulting array
         * of tokens and start/end token.
         */
        consumeArg(delims) {
          var tokens = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start = this.future();
          var tok;
          var depth = 0;
          var match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                ++match;
                if (match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start,
            end: tok
          };
        }
        /**
         * Consume the specified number of (delimited) arguments from the token
         * stream and return the resulting array of arguments.
         */
        consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters2[0];
            for (var i = 0; i < delims.length; i++) {
              var tok = this.popToken();
              if (delims[i] !== tok.text) {
                throw new ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i = 0; _i < numArgs; _i++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
          }
          return args;
        }
        /**
         * Increment `expansionCount` by the specified amount.
         * Throw an error if it exceeds `maxExpand`.
         */
        countExpansion(amount) {
          this.expansionCount += amount;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
        }
        /**
         * Expand the next token only once if possible.
         *
         * If the token is expanded, the resulting tokens will be pushed onto
         * the stack in reverse order, and the number of such tokens will be
         * returned.  This number might be zero or positive.
         *
         * If not, the return value is `false`, and the next token remains at the
         * top of the stack.
         *
         * In either case, the next token will be on the top of the stack,
         * or the stack will be empty (in case of empty expansion
         * and no other tokens).
         *
         * Used to implement `expandAfterFuture` and `expandNextToken`.
         *
         * If expandableOnly, only expandable tokens are expanded and
         * an undefined control sequence results in an error.
         */
        expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return false;
          }
          this.countExpansion(1);
          var tokens = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (var i = tokens.length - 1; i >= 0; --i) {
              var tok = tokens[i];
              if (tok.text === "#") {
                if (i === 0) {
                  throw new ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i];
                if (tok.text === "#") {
                  tokens.splice(i + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  tokens.splice(i, 2, ...args[+tok.text - 1]);
                } else {
                  throw new ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens.length;
        }
        /**
         * Expand the next token only once (if possible), and return the resulting
         * top token on the stack (without removing anything from the stack).
         * Similar in behavior to TeX's `\expandafter\futurelet`.
         * Equivalent to expandOnce() followed by future().
         */
        expandAfterFuture() {
          this.expandOnce();
          return this.future();
        }
        /**
         * Recursively expand first token, then return first non-expandable token.
         */
        expandNextToken() {
          for (; ; ) {
            if (this.expandOnce() === false) {
              var token = this.stack.pop();
              if (token.treatAsRelax) {
                token.text = "\\relax";
              }
              return token;
            }
          }
          throw new Error();
        }
        /**
         * Fully expand the given macro name and return the resulting list of
         * tokens, or return `undefined` if no such macro is defined.
         */
        expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
        }
        /**
         * Fully expand the given token stream and return the resulting list of
         * tokens.  Note that the input tokens are in reverse order, but the
         * output tokens are in forward order.
         */
        expandTokens(tokens) {
          var output = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            if (this.expandOnce(true) === false) {
              var token = this.stack.pop();
              if (token.treatAsRelax) {
                token.noexpand = false;
                token.treatAsRelax = false;
              }
              output.push(token);
            }
          }
          this.countExpansion(output.length);
          return output;
        }
        /**
         * Fully expand the given macro name and return the result as a string,
         * or return `undefined` if no such macro is defined.
         */
        expandMacroAsText(name) {
          var tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map((token) => token.text).join("");
          } else {
            return tokens;
          }
        }
        /**
         * Returns the expanded macro as a reversed array of tokens and a macro
         * argument count.  Or returns `null` if no such macro.
         */
        _getExpansion(name) {
          var definition3 = this.macros.get(name);
          if (definition3 == null) {
            return definition3;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition3 === "function" ? definition3(this) : definition3;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer(expansion, this.settings);
            var tokens = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            var expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        }
        /**
         * Determine whether a command is currently "defined" (has some
         * functionality), meaning that it's a macro (in the current group),
         * a function, a symbol, or one of the special commands listed in
         * `implicitCommands`.
         */
        isDefined(name) {
          return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        }
        /**
         * Determine whether a command is expandable.
         */
        isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
        }
      };
      unicodeSubRegEx = /^[â‚Šâ‚‹â‚Œâ‚â‚Žâ‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/;
      uSubsAndSups = Object.freeze({
        "\u208A": "+",
        "\u208B": "-",
        "\u208C": "=",
        "\u208D": "(",
        "\u208E": ")",
        "\u2080": "0",
        "\u2081": "1",
        "\u2082": "2",
        "\u2083": "3",
        "\u2084": "4",
        "\u2085": "5",
        "\u2086": "6",
        "\u2087": "7",
        "\u2088": "8",
        "\u2089": "9",
        "\u2090": "a",
        "\u2091": "e",
        "\u2095": "h",
        "\u1D62": "i",
        "\u2C7C": "j",
        "\u2096": "k",
        "\u2097": "l",
        "\u2098": "m",
        "\u2099": "n",
        "\u2092": "o",
        "\u209A": "p",
        "\u1D63": "r",
        "\u209B": "s",
        "\u209C": "t",
        "\u1D64": "u",
        "\u1D65": "v",
        "\u2093": "x",
        "\u1D66": "\u03B2",
        "\u1D67": "\u03B3",
        "\u1D68": "\u03C1",
        "\u1D69": "\u03D5",
        "\u1D6A": "\u03C7",
        "\u207A": "+",
        "\u207B": "-",
        "\u207C": "=",
        "\u207D": "(",
        "\u207E": ")",
        "\u2070": "0",
        "\xB9": "1",
        "\xB2": "2",
        "\xB3": "3",
        "\u2074": "4",
        "\u2075": "5",
        "\u2076": "6",
        "\u2077": "7",
        "\u2078": "8",
        "\u2079": "9",
        "\u1D2C": "A",
        "\u1D2E": "B",
        "\u1D30": "D",
        "\u1D31": "E",
        "\u1D33": "G",
        "\u1D34": "H",
        "\u1D35": "I",
        "\u1D36": "J",
        "\u1D37": "K",
        "\u1D38": "L",
        "\u1D39": "M",
        "\u1D3A": "N",
        "\u1D3C": "O",
        "\u1D3E": "P",
        "\u1D3F": "R",
        "\u1D40": "T",
        "\u1D41": "U",
        "\u2C7D": "V",
        "\u1D42": "W",
        "\u1D43": "a",
        "\u1D47": "b",
        "\u1D9C": "c",
        "\u1D48": "d",
        "\u1D49": "e",
        "\u1DA0": "f",
        "\u1D4D": "g",
        "\u02B0": "h",
        "\u2071": "i",
        "\u02B2": "j",
        "\u1D4F": "k",
        "\u02E1": "l",
        "\u1D50": "m",
        "\u207F": "n",
        "\u1D52": "o",
        "\u1D56": "p",
        "\u02B3": "r",
        "\u02E2": "s",
        "\u1D57": "t",
        "\u1D58": "u",
        "\u1D5B": "v",
        "\u02B7": "w",
        "\u02E3": "x",
        "\u02B8": "y",
        "\u1DBB": "z",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03D5",
        "\u1D61": "\u03C7",
        "\u1DBF": "\u03B8"
      });
      unicodeAccents = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        },
        "\u0327": {
          "text": "\\c"
        }
      };
      unicodeSymbols = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u1E09": "c\u0327\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\xE7": "c\u0327",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\u1E11": "d\u0327",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u1E1D": "e\u0327\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u0229": "e\u0327",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u0123": "g\u0327",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\u1E29": "h\u0327",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u0137": "k\u0327",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u013C": "l\u0327",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\u0146": "n\u0327",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u0157": "r\u0327",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u015F": "s\u0327",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\u0163": "t\u0327",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u1E08": "C\u0327\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\xC7": "C\u0327",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\u1E10": "D\u0327",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u1E1C": "E\u0327\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u0228": "E\u0327",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u0122": "G\u0327",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\u1E28": "H\u0327",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0136": "K\u0327",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u013B": "L\u0327",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\u0145": "N\u0327",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u0156": "R\u0327",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u015E": "S\u0327",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\u0162": "T\u0327",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      Parser = class _Parser {
        constructor(input, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        /**
         * Checks a result to make sure it has the right type, and throws an
         * appropriate error otherwise.
         */
        expect(text10, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text10) {
            throw new ParseError("Expected '" + text10 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        }
        /**
         * Discards the current lookahead token, considering it consumed.
         */
        consume() {
          this.nextToken = null;
        }
        /**
         * Return the current lookahead token, or if there isn't one (at the
         * beginning, or if the previous lookahead token was consume()d),
         * fetch the next token as the new lookahead token and return it.
         */
        fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        }
        /**
         * Main parsing function, which parses an entire input.
         */
        parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            var parse4 = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse4;
          } finally {
            this.gullet.endGroups();
          }
        }
        /**
         * Fully parse a separate sequence of tokens as a separate job.
         * Tokens should be specified in reverse order, as in a MacroDefinition.
         */
        subparse(tokens) {
          var oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token("}"));
          this.gullet.pushTokens(tokens);
          var parse4 = this.parseExpression(false);
          this.expect("}");
          this.nextToken = oldToken;
          return parse4;
        }
        /**
         * Parses an "expression", which is a list of atoms.
         *
         * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
         *                 happens when functions have higher precedence han infix
         *                 nodes in implicit parses.
         *
         * `breakOnTokenText`: The text of the token that the expression should end
         *                     with, or `null` if something else should end the
         *                     expression.
         */
        parseExpression(breakOnInfix, breakOnTokenText) {
          var body3 = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex = this.fetch();
            if (_Parser.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
              break;
            }
            var atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body3.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body3);
          }
          return this.handleInfixNodes(body3);
        }
        /**
         * Rewrites infix operators such as \over with corresponding commands such
         * as \frac.
         *
         * There can only be one infix operator per group.  If there's more than one
         * then the expression is ambiguous.  This can be resolved by adding {}.
         */
        handleInfixNodes(body3) {
          var overIndex = -1;
          var funcName;
          for (var i = 0; i < body3.length; i++) {
            if (body3[i].type === "infix") {
              if (overIndex !== -1) {
                throw new ParseError("only one infix operator per group", body3[i].token);
              }
              overIndex = i;
              funcName = body3[i].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body3.slice(0, overIndex);
            var denomBody = body3.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node2;
            if (funcName === "\\\\abovefrac") {
              node2 = this.callFunction(funcName, [numerNode, body3[overIndex], denomNode], []);
            } else {
              node2 = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node2];
          } else {
            return body3;
          }
        }
        /**
         * Handle a subscript or superscript with nice errors.
         */
        handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group;
          do {
            var _group;
            group = this.parseGroup(name);
          } while (((_group = group) == null ? void 0 : _group.type) === "internal");
          if (!group) {
            throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        }
        /**
         * Converts the textual input of an unsupported command into a text node
         * contained within a color node whose color is determined by errorColor
         */
        formatUnsupportedCmd(text10) {
          var textordArray = [];
          for (var i = 0; i < text10.length; i++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text10[i]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        }
        /**
         * Parses a group with optional super/subscripts.
         */
        parseAtom(breakOnTokenText) {
          var base = this.parseGroup("atom", breakOnTokenText);
          if ((base == null ? void 0 : base.type) === "internal") {
            return base;
          }
          if (this.mode === "text") {
            return base;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base && base.type === "op") {
                var limits = lex.text === "\\limits";
                base.limits = limits;
                base.alwaysHandleSupSub = true;
              } else if (base && base.type === "operatorname") {
                if (base.alwaysHandleSupSub) {
                  base.limits = lex.text === "\\limits";
                }
              } else {
                throw new ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new ParseError("Double superscript", lex);
              }
              var prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else if (uSubsAndSups[lex.text]) {
              var isSub = unicodeSubRegEx.test(lex.text);
              var subsupTokens = [];
              subsupTokens.push(new Token(uSubsAndSups[lex.text]));
              this.consume();
              while (true) {
                var token = this.fetch().text;
                if (!uSubsAndSups[token]) {
                  break;
                }
                if (unicodeSubRegEx.test(token) !== isSub) {
                  break;
                }
                subsupTokens.unshift(new Token(uSubsAndSups[token]));
                this.consume();
              }
              var body3 = this.subparse(subsupTokens);
              if (isSub) {
                subscript = {
                  type: "ordgroup",
                  mode: "math",
                  body: body3
                };
              } else {
                superscript = {
                  type: "ordgroup",
                  mode: "math",
                  body: body3
                };
              }
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base;
          }
        }
        /**
         * Parses an entire function, including its base and all of its arguments.
         */
        parseFunction(breakOnTokenText, name) {
          var token = this.fetch();
          var func = token.text;
          var funcData = functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new ParseError("Can't use function '" + func + "' in math mode", token);
          }
          var {
            args,
            optArgs
          } = this.parseArguments(func, funcData);
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        }
        /**
         * Call a function handler with a suitable context and arguments.
         */
        callFunction(name, args, optArgs, token, breakOnTokenText) {
          var context = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          var func = functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new ParseError("No function handler for " + name);
          }
        }
        /**
         * Parses the arguments of a function or environment
         */
        parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i = 0; i < totalArgs; i++) {
            var argType = funcData.argTypes && funcData.argTypes[i];
            var isOptional = i < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
            funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        }
        /**
         * Parses a group when the mode is changing.
         */
        parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
                // simulate \textstyle
              } : null;
            }
            case "raw": {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new ParseError("A primitive argument cannot be optional");
              }
              var _group2 = this.parseGroup(name);
              if (_group2 == null) {
                throw new ParseError("Expected group as " + name, this.fetch());
              }
              return _group2;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new ParseError("Unknown group type as " + name, this.fetch());
          }
        }
        /**
         * Discard any space tokens, fetching the next non-space token.
         */
        consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        }
        /**
         * Parses a group, essentially returning the string formed by the
         * brace-enclosed tokens plus some position information.
         */
        parseStringGroup(modeName, optional) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str;
          return argToken;
        }
        /**
         * Parses a regex-delimited group: the largest sequence of tokens
         * whose concatenated strings match `regex`. Returns the string
         * formed by the tokens plus some position information.
         */
        parseRegexGroup(regex, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
            lastToken = nextToken;
            str += lastToken.text;
            this.consume();
          }
          if (str === "") {
            throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        }
        /**
         * Parses a color description.
         */
        parseColorGroup(optional) {
          var res = this.parseStringGroup("color", optional);
          if (res == null) {
            return null;
          }
          var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match) {
            throw new ParseError("Invalid color: '" + res.text + "'", res);
          }
          var color2 = match[0];
          if (/^[0-9a-f]{6}$/i.test(color2)) {
            color2 = "#" + color2;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color: color2
          };
        }
        /**
         * Parses a size specification, consisting of magnitude and unit.
         */
        parseSizeGroup(optional) {
          var res;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional);
          }
          if (!res) {
            return null;
          }
          if (!optional && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match) {
            throw new ParseError("Invalid size: '" + res.text + "'", res);
          }
          var data = {
            number: +(match[1] + match[2]),
            // sign + magnitude, cast to number
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new ParseError("Invalid unit: '" + data.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data,
            isBlank
          };
        }
        /**
         * Parses an URL, checking escaped letters and allowed protocols,
         * and setting the catcode of % as an active character (as in \hyperref).
         */
        parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        }
        /**
         * Parses an argument with the mode specified.
         */
        parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result;
        }
        /**
         * Parses an ordinary group, which is either a single nucleus (like "x")
         * or an expression in braces (like "{x+y}") or an implicit group, a group
         * that starts at the current position, and ends right before a higher explicit
         * group ends, or at EOF.
         */
        parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text10 = firstToken.text;
          var result;
          if (text10 === "{" || text10 === "\\begingroup") {
            this.consume();
            var groupEnd = text10 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              // A group formed by \begingroup...\endgroup is a semi-simple group
              // which doesn't affect spacing in math mode, i.e., is transparent.
              // https://tex.stackexchange.com/questions/1930/when-should-one-
              // use-begingroup-instead-of-bgroup
              semisimple: text10 === "\\begingroup" || void 0
            };
          } else {
            result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result == null && text10[0] === "\\" && !implicitCommands.hasOwnProperty(text10)) {
              if (this.settings.throwOnError) {
                throw new ParseError("Undefined control sequence: " + text10, firstToken);
              }
              result = this.formatUnsupportedCmd(text10);
              this.consume();
            }
          }
          return result;
        }
        /**
         * Form ligature-like combinations of characters for text mode.
         * This includes inputs like "--", "---", "``" and "''".
         * The result will simply replace multiple textord nodes with a single
         * character in each value by a single textord node having multiple
         * characters in its value.  The representation is still ASCII source.
         * The group will be modified in place.
         */
        formLigatures(group) {
          var n = group.length - 1;
          for (var i = 0; i < n; ++i) {
            var a = group[i];
            var v = a.text;
            if (v === "-" && group[i + 1].text === "-") {
              if (i + 1 < n && group[i + 2].text === "-") {
                group.splice(i, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 2]),
                  text: "---"
                });
                n -= 2;
              } else {
                group.splice(i, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 1]),
                  text: "--"
                });
                n -= 1;
              }
            }
            if ((v === "'" || v === "`") && group[i + 1].text === v) {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 1]),
                text: v + v
              });
              n -= 1;
            }
          }
        }
        /**
         * Parse a single symbol out of the string. Here, we handle single character
         * symbols and special functions like \verb.
         */
        parseSymbol() {
          var nucleus = this.fetch();
          var text10 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text10)) {
            this.consume();
            var arg = text10.slice(5);
            var star = arg.charAt(0) === "*";
            if (star) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star
            };
          }
          if (unicodeSymbols.hasOwnProperty(text10[0]) && !symbols[this.mode][text10[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text10[0] + '" used in math mode', nucleus);
            }
            text10 = unicodeSymbols[text10[0]] + text10.slice(1);
          }
          var match = combiningDiacriticalMarksEndRegex.exec(text10);
          if (match) {
            text10 = text10.substring(0, match.index);
            if (text10 === "i") {
              text10 = "\u0131";
            } else if (text10 === "j") {
              text10 = "\u0237";
            }
          }
          var symbol;
          if (symbols[this.mode][text10]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text10) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text10[0] + '" used in math mode', nucleus);
            }
            var group = symbols[this.mode][text10].group;
            var loc = SourceLocation.range(nucleus);
            var s2;
            if (ATOMS.hasOwnProperty(group)) {
              var family = group;
              s2 = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text: text10
              };
            } else {
              s2 = {
                type: group,
                mode: this.mode,
                loc,
                text: text10
              };
            }
            symbol = s2;
          } else if (text10.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text10.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text10[0] + '"' + (" (" + text10.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text10[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text: text10
            };
          } else {
            return null;
          }
          this.consume();
          if (match) {
            for (var i = 0; i < match[0].length; i++) {
              var accent2 = match[0][i];
              if (!unicodeAccents[accent2]) {
                throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
              if (!command) {
                throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                // $FlowFixMe
                base: symbol
              };
            }
          }
          return symbol;
        }
      };
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      parseTree = function parseTree2(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser2 = new Parser(toParse, settings);
        delete parser2.gullet.macros.current["\\df@tag"];
        var tree = parser2.parse();
        delete parser2.gullet.macros.current["\\current@color"];
        delete parser2.gullet.macros.current["\\color"];
        if (parser2.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new ParseError("\\tag works only in display equations");
          }
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser2.subparse([new Token("\\df@tag")])
          }];
        }
        return tree;
      };
      render = function render2(expression, baseNode, options) {
        baseNode.textContent = "";
        var node2 = renderToDomTree(expression, options).toNode();
        baseNode.appendChild(node2);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render = function render3() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      renderToString = function renderToString2(expression, options) {
        var markup = renderToDomTree(expression, options).toMarkup();
        return markup;
      };
      generateParseTree = function generateParseTree2(expression, options) {
        var settings = new Settings(options);
        return parseTree(expression, settings);
      };
      renderError = function renderError2(error, expression, options) {
        if (options.throwOnError || !(error instanceof ParseError)) {
          throw error;
        }
        var node2 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node2.setAttribute("title", error.toString());
        node2.setAttribute("style", "color:" + options.errorColor);
        return node2;
      };
      renderToDomTree = function renderToDomTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = parseTree(expression, settings);
          return buildTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      renderToHTMLTree = function renderToHTMLTree2(expression, options) {
        var settings = new Settings(options);
        try {
          var tree = parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      version = "0.16.22";
      __domTree = {
        Span,
        Anchor,
        SymbolNode,
        SvgNode,
        PathNode,
        LineNode
      };
      katex = {
        /**
         * Current KaTeX version
         */
        version,
        /**
         * Renders the given LaTeX into an HTML+MathML combination, and adds
         * it as a child to the specified DOM node.
         */
        render,
        /**
         * Renders the given LaTeX into an HTML+MathML combination string,
         * for sending to the client.
         */
        renderToString,
        /**
         * KaTeX error, usually during parsing.
         */
        ParseError,
        /**
         * The schema of Settings
         */
        SETTINGS_SCHEMA,
        /**
         * Parses the given LaTeX into KaTeX's internal parse tree structure,
         * without rendering to HTML or MathML.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __parse: generateParseTree,
        /**
         * Renders the given LaTeX into an HTML+MathML internal DOM tree
         * representation, without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToDomTree: renderToDomTree,
        /**
         * Renders the given LaTeX into an HTML internal DOM tree representation,
         * without MathML and without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToHTMLTree: renderToHTMLTree,
        /**
         * extends internal font metrics object with a new object
         * each key in the new object represents a font name
        */
        __setFontMetrics: setFontMetrics,
        /**
         * adds a new symbol to builtin symbols table
         */
        __defineSymbol: defineSymbol,
        /**
         * adds a new function to builtin function list,
         * which directly produce parse tree elements
         * and have their own html/mathml builders
         */
        __defineFunction: defineFunction,
        /**
         * adds a new macro to builtin macro list
         */
        __defineMacro: defineMacro,
        /**
         * Expose the dom tree node types, which can be useful for type checking nodes.
         *
         * NOTE: These methods are not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __domTree
      };
    }
  });

  // node_modules/micromark-extension-math/index.js
  var init_micromark_extension_math = __esm({
    "node_modules/micromark-extension-math/index.js"() {
      init_syntax6();
    }
  });

  // node_modules/remark-math/lib/index.js
  function remarkMath(options) {
    const self2 = (
      /** @type {Processor} */
      this
    );
    const settings = options || emptyOptions3;
    const data = self2.data();
    const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
    const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
    const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
    micromarkExtensions.push(math(settings));
    fromMarkdownExtensions.push(mathFromMarkdown());
    toMarkdownExtensions.push(mathToMarkdown(settings));
  }
  var emptyOptions3;
  var init_lib22 = __esm({
    "node_modules/remark-math/lib/index.js"() {
      init_mdast_util_math();
      init_micromark_extension_math();
      emptyOptions3 = {};
    }
  });

  // node_modules/remark-math/index.js
  var init_remark_math = __esm({
    "node_modules/remark-math/index.js"() {
      init_lib22();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
  function blockquote2(state, node2) {
    const result = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: state.wrap(state.all(node2), true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_blockquote2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/blockquote.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/break.js
  function hardBreak2(state, node2) {
    const result = { type: "element", tagName: "br", properties: {}, children: [] };
    state.patch(node2, result);
    return [state.applyData(node2, result), { type: "text", value: "\n" }];
  }
  var init_break2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/break.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/code.js
  function code3(state, node2) {
    const value = node2.value ? node2.value + "\n" : "";
    const properties2 = {};
    if (node2.lang) {
      properties2.className = ["language-" + node2.lang];
    }
    let result = {
      type: "element",
      tagName: "code",
      properties: properties2,
      children: [{ type: "text", value }]
    };
    if (node2.meta) {
      result.data = { meta: node2.meta };
    }
    state.patch(node2, result);
    result = state.applyData(node2, result);
    result = { type: "element", tagName: "pre", properties: {}, children: [result] };
    state.patch(node2, result);
    return result;
  }
  var init_code2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/code.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/delete.js
  function strikethrough(state, node2) {
    const result = {
      type: "element",
      tagName: "del",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_delete = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/delete.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
  function emphasis2(state, node2) {
    const result = {
      type: "element",
      tagName: "em",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_emphasis2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/emphasis.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
  function footnoteReference2(state, node2) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const id = String(node2.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    const index2 = state.footnoteOrder.indexOf(id);
    let counter;
    let reuseCounter = state.footnoteCounts.get(id);
    if (reuseCounter === void 0) {
      reuseCounter = 0;
      state.footnoteOrder.push(id);
      counter = state.footnoteOrder.length;
    } else {
      counter = index2 + 1;
    }
    reuseCounter += 1;
    state.footnoteCounts.set(id, reuseCounter);
    const link3 = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + clobberPrefix + "fn-" + safeId,
        id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(counter) }]
    };
    state.patch(node2, link3);
    const sup2 = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [link3]
    };
    state.patch(node2, sup2);
    return state.applyData(node2, sup2);
  }
  var init_footnote_reference = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/heading.js
  function heading2(state, node2) {
    const result = {
      type: "element",
      tagName: "h" + node2.depth,
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_heading2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/heading.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/html.js
  function html2(state, node2) {
    if (state.options.allowDangerousHtml) {
      const result = { type: "raw", value: node2.value };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    return void 0;
  }
  var init_html2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/html.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/revert.js
  function revert(state, node2) {
    const subtype = node2.referenceType;
    let suffix = "]";
    if (subtype === "collapsed") {
      suffix += "[]";
    } else if (subtype === "full") {
      suffix += "[" + (node2.label || node2.identifier) + "]";
    }
    if (node2.type === "imageReference") {
      return [{ type: "text", value: "![" + node2.alt + suffix }];
    }
    const contents = state.all(node2);
    const head2 = contents[0];
    if (head2 && head2.type === "text") {
      head2.value = "[" + head2.value;
    } else {
      contents.unshift({ type: "text", value: "[" });
    }
    const tail = contents[contents.length - 1];
    if (tail && tail.type === "text") {
      tail.value += suffix;
    } else {
      contents.push({ type: "text", value: suffix });
    }
    return contents;
  }
  var init_revert = __esm({
    "node_modules/mdast-util-to-hast/lib/revert.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
  function imageReference2(state, node2) {
    const id = String(node2.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id);
    if (!definition3) {
      return revert(state, node2);
    }
    const properties2 = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties2.title = definition3.title;
    }
    const result = { type: "element", tagName: "img", properties: properties2, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_image_reference2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/image-reference.js"() {
      init_micromark_util_sanitize_uri();
      init_revert();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/image.js
  function image2(state, node2) {
    const properties2 = { src: normalizeUri(node2.url) };
    if (node2.alt !== null && node2.alt !== void 0) {
      properties2.alt = node2.alt;
    }
    if (node2.title !== null && node2.title !== void 0) {
      properties2.title = node2.title;
    }
    const result = { type: "element", tagName: "img", properties: properties2, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_image2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/image.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
  function inlineCode2(state, node2) {
    const text10 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
    state.patch(node2, text10);
    const result = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [text10]
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_inline_code2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/inline-code.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
  function linkReference2(state, node2) {
    const id = String(node2.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id);
    if (!definition3) {
      return revert(state, node2);
    }
    const properties2 = { href: normalizeUri(definition3.url || "") };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties2.title = definition3.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties: properties2,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_link_reference2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/link-reference.js"() {
      init_micromark_util_sanitize_uri();
      init_revert();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/link.js
  function link2(state, node2) {
    const properties2 = { href: normalizeUri(node2.url) };
    if (node2.title !== null && node2.title !== void 0) {
      properties2.title = node2.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties: properties2,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_link2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/link.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/list-item.js
  function listItem2(state, node2, parent) {
    const results = state.all(node2);
    const loose = parent ? listLoose(parent) : listItemLoose(node2);
    const properties2 = {};
    const children2 = [];
    if (typeof node2.checked === "boolean") {
      const head2 = results[0];
      let paragraph3;
      if (head2 && head2.type === "element" && head2.tagName === "p") {
        paragraph3 = head2;
      } else {
        paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
        results.unshift(paragraph3);
      }
      if (paragraph3.children.length > 0) {
        paragraph3.children.unshift({ type: "text", value: " " });
      }
      paragraph3.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: node2.checked, disabled: true },
        children: []
      });
      properties2.className = ["task-list-item"];
    }
    let index2 = -1;
    while (++index2 < results.length) {
      const child = results[index2];
      if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
        children2.push({ type: "text", value: "\n" });
      }
      if (child.type === "element" && child.tagName === "p" && !loose) {
        children2.push(...child.children);
      } else {
        children2.push(child);
      }
    }
    const tail = results[results.length - 1];
    if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
      children2.push({ type: "text", value: "\n" });
    }
    const result = { type: "element", tagName: "li", properties: properties2, children: children2 };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listLoose(node2) {
    let loose = false;
    if (node2.type === "list") {
      loose = node2.spread || false;
      const children2 = node2.children;
      let index2 = -1;
      while (!loose && ++index2 < children2.length) {
        loose = listItemLoose(children2[index2]);
      }
    }
    return loose;
  }
  function listItemLoose(node2) {
    const spread = node2.spread;
    return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
  }
  var init_list_item2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/list-item.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/list.js
  function list3(state, node2) {
    const properties2 = {};
    const results = state.all(node2);
    let index2 = -1;
    if (typeof node2.start === "number" && node2.start !== 1) {
      properties2.start = node2.start;
    }
    while (++index2 < results.length) {
      const child = results[index2];
      if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
        properties2.className = ["contains-task-list"];
        break;
      }
    }
    const result = {
      type: "element",
      tagName: node2.ordered ? "ol" : "ul",
      properties: properties2,
      children: state.wrap(results, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_list3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/list.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
  function paragraph2(state, node2) {
    const result = {
      type: "element",
      tagName: "p",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_paragraph2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/paragraph.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/root.js
  function root2(state, node2) {
    const result = { type: "root", children: state.wrap(state.all(node2)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_root2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/root.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/strong.js
  function strong2(state, node2) {
    const result = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_strong2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/strong.js"() {
      "";
    }
  });

  // node_modules/unist-util-position/lib/index.js
  function point3(type) {
    return point4;
    function point4(node2) {
      const point5 = node2 && node2.position && node2.position[type] || {};
      if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
        return {
          line: point5.line,
          column: point5.column,
          offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
        };
      }
    }
  }
  function position2(node2) {
    const start = pointStart(node2);
    const end = pointEnd(node2);
    if (start && end) {
      return { start, end };
    }
  }
  var pointEnd, pointStart;
  var init_lib23 = __esm({
    "node_modules/unist-util-position/lib/index.js"() {
      pointEnd = point3("end");
      pointStart = point3("start");
    }
  });

  // node_modules/unist-util-position/index.js
  var init_unist_util_position = __esm({
    "node_modules/unist-util-position/index.js"() {
      init_lib23();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table.js
  function table(state, node2) {
    const rows = state.all(node2);
    const firstRow = rows.shift();
    const tableContent = [];
    if (firstRow) {
      const head2 = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: state.wrap([firstRow], true)
      };
      state.patch(node2.children[0], head2);
      tableContent.push(head2);
    }
    if (rows.length > 0) {
      const body3 = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: state.wrap(rows, true)
      };
      const start = pointStart(node2.children[1]);
      const end = pointEnd(node2.children[node2.children.length - 1]);
      if (start && end) body3.position = { start, end };
      tableContent.push(body3);
    }
    const result = {
      type: "element",
      tagName: "table",
      properties: {},
      children: state.wrap(tableContent, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table.js"() {
      init_unist_util_position();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table-row.js
  function tableRow(state, node2, parent) {
    const siblings2 = parent ? parent.children : void 0;
    const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
    const tagName = rowIndex === 0 ? "th" : "td";
    const align = parent && parent.type === "table" ? parent.align : void 0;
    const length = align ? align.length : node2.children.length;
    let cellIndex = -1;
    const cells2 = [];
    while (++cellIndex < length) {
      const cell2 = node2.children[cellIndex];
      const properties2 = {};
      const alignValue = align ? align[cellIndex] : void 0;
      if (alignValue) {
        properties2.align = alignValue;
      }
      let result2 = { type: "element", tagName, properties: properties2, children: [] };
      if (cell2) {
        result2.children = state.all(cell2);
        state.patch(cell2, result2);
        result2 = state.applyData(cell2, result2);
      }
      cells2.push(result2);
    }
    const result = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: state.wrap(cells2, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table_row = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table-row.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
  function tableCell(state, node2) {
    const result = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table_cell = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table-cell.js"() {
      "";
    }
  });

  // node_modules/trim-lines/index.js
  function trimLines(value) {
    const source = String(value);
    const search3 = /\r?\n|\r/g;
    let match = search3.exec(source);
    let last = 0;
    const lines = [];
    while (match) {
      lines.push(
        trimLine(source.slice(last, match.index), last > 0, true),
        match[0]
      );
      last = match.index + match[0].length;
      match = search3.exec(source);
    }
    lines.push(trimLine(source.slice(last), last > 0, false));
    return lines.join("");
  }
  function trimLine(value, start, end) {
    let startIndex = 0;
    let endIndex = value.length;
    if (start) {
      let code4 = value.codePointAt(startIndex);
      while (code4 === tab || code4 === space) {
        startIndex++;
        code4 = value.codePointAt(startIndex);
      }
    }
    if (end) {
      let code4 = value.codePointAt(endIndex - 1);
      while (code4 === tab || code4 === space) {
        endIndex--;
        code4 = value.codePointAt(endIndex - 1);
      }
    }
    return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
  }
  var tab, space;
  var init_trim_lines = __esm({
    "node_modules/trim-lines/index.js"() {
      tab = 9;
      space = 32;
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/text.js
  function text6(state, node2) {
    const result = { type: "text", value: trimLines(String(node2.value)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_text3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/text.js"() {
      init_trim_lines();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
  function thematicBreak3(state, node2) {
    const result = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_thematic_break3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/index.js
  function ignore() {
    return void 0;
  }
  var handlers;
  var init_handlers = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/index.js"() {
      init_blockquote2();
      init_break2();
      init_code2();
      init_delete();
      init_emphasis2();
      init_footnote_reference();
      init_heading2();
      init_html2();
      init_image_reference2();
      init_image2();
      init_inline_code2();
      init_link_reference2();
      init_link2();
      init_list_item2();
      init_list3();
      init_paragraph2();
      init_root2();
      init_strong2();
      init_table();
      init_table_row();
      init_table_cell();
      init_text3();
      init_thematic_break3();
      handlers = {
        blockquote: blockquote2,
        break: hardBreak2,
        code: code3,
        delete: strikethrough,
        emphasis: emphasis2,
        footnoteReference: footnoteReference2,
        heading: heading2,
        html: html2,
        imageReference: imageReference2,
        image: image2,
        inlineCode: inlineCode2,
        linkReference: linkReference2,
        link: link2,
        listItem: listItem2,
        list: list3,
        paragraph: paragraph2,
        // @ts-expect-error: root is different, but hard to type.
        root: root2,
        strong: strong2,
        table,
        tableCell,
        tableRow,
        text: text6,
        thematicBreak: thematicBreak3,
        toml: ignore,
        yaml: ignore,
        definition: ignore,
        footnoteDefinition: ignore
      };
    }
  });

  // node_modules/@ungap/structured-clone/esm/types.js
  var VOID, PRIMITIVE, ARRAY, OBJECT, DATE, REGEXP, MAP, SET, ERROR, BIGINT;
  var init_types = __esm({
    "node_modules/@ungap/structured-clone/esm/types.js"() {
      VOID = -1;
      PRIMITIVE = 0;
      ARRAY = 1;
      OBJECT = 2;
      DATE = 3;
      REGEXP = 4;
      MAP = 5;
      SET = 6;
      ERROR = 7;
      BIGINT = 8;
    }
  });

  // node_modules/@ungap/structured-clone/esm/deserialize.js
  var env, deserializer, deserialize;
  var init_deserialize = __esm({
    "node_modules/@ungap/structured-clone/esm/deserialize.js"() {
      init_types();
      env = typeof self === "object" ? self : globalThis;
      deserializer = ($, _) => {
        const as = (out, index2) => {
          $.set(index2, out);
          return out;
        };
        const unpair = (index2) => {
          if ($.has(index2))
            return $.get(index2);
          const [type, value] = _[index2];
          switch (type) {
            case PRIMITIVE:
            case VOID:
              return as(value, index2);
            case ARRAY: {
              const arr = as([], index2);
              for (const index3 of value)
                arr.push(unpair(index3));
              return arr;
            }
            case OBJECT: {
              const object = as({}, index2);
              for (const [key2, index3] of value)
                object[unpair(key2)] = unpair(index3);
              return object;
            }
            case DATE:
              return as(new Date(value), index2);
            case REGEXP: {
              const { source, flags } = value;
              return as(new RegExp(source, flags), index2);
            }
            case MAP: {
              const map3 = as(/* @__PURE__ */ new Map(), index2);
              for (const [key2, index3] of value)
                map3.set(unpair(key2), unpair(index3));
              return map3;
            }
            case SET: {
              const set = as(/* @__PURE__ */ new Set(), index2);
              for (const index3 of value)
                set.add(unpair(index3));
              return set;
            }
            case ERROR: {
              const { name, message } = value;
              return as(new env[name](message), index2);
            }
            case BIGINT:
              return as(BigInt(value), index2);
            case "BigInt":
              return as(Object(BigInt(value)), index2);
            case "ArrayBuffer":
              return as(new Uint8Array(value).buffer, value);
            case "DataView": {
              const { buffer } = new Uint8Array(value);
              return as(new DataView(buffer), value);
            }
          }
          return as(new env[type](value), index2);
        };
        return unpair;
      };
      deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
    }
  });

  // node_modules/@ungap/structured-clone/esm/serialize.js
  var EMPTY, toString2, keys, typeOf, shouldSkip, serializer, serialize2;
  var init_serialize = __esm({
    "node_modules/@ungap/structured-clone/esm/serialize.js"() {
      init_types();
      EMPTY = "";
      ({ toString: toString2 } = {});
      ({ keys } = Object);
      typeOf = (value) => {
        const type = typeof value;
        if (type !== "object" || !value)
          return [PRIMITIVE, type];
        const asString = toString2.call(value).slice(8, -1);
        switch (asString) {
          case "Array":
            return [ARRAY, EMPTY];
          case "Object":
            return [OBJECT, EMPTY];
          case "Date":
            return [DATE, EMPTY];
          case "RegExp":
            return [REGEXP, EMPTY];
          case "Map":
            return [MAP, EMPTY];
          case "Set":
            return [SET, EMPTY];
          case "DataView":
            return [ARRAY, asString];
        }
        if (asString.includes("Array"))
          return [ARRAY, asString];
        if (asString.includes("Error"))
          return [ERROR, asString];
        return [OBJECT, asString];
      };
      shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
      serializer = (strict, json, $, _) => {
        const as = (out, value) => {
          const index2 = _.push(out) - 1;
          $.set(value, index2);
          return index2;
        };
        const pair = (value) => {
          if ($.has(value))
            return $.get(value);
          let [TYPE, type] = typeOf(value);
          switch (TYPE) {
            case PRIMITIVE: {
              let entry = value;
              switch (type) {
                case "bigint":
                  TYPE = BIGINT;
                  entry = value.toString();
                  break;
                case "function":
                case "symbol":
                  if (strict)
                    throw new TypeError("unable to serialize " + type);
                  entry = null;
                  break;
                case "undefined":
                  return as([VOID], value);
              }
              return as([TYPE, entry], value);
            }
            case ARRAY: {
              if (type) {
                let spread = value;
                if (type === "DataView") {
                  spread = new Uint8Array(value.buffer);
                } else if (type === "ArrayBuffer") {
                  spread = new Uint8Array(value);
                }
                return as([type, [...spread]], value);
              }
              const arr = [];
              const index2 = as([TYPE, arr], value);
              for (const entry of value)
                arr.push(pair(entry));
              return index2;
            }
            case OBJECT: {
              if (type) {
                switch (type) {
                  case "BigInt":
                    return as([type, value.toString()], value);
                  case "Boolean":
                  case "Number":
                  case "String":
                    return as([type, value.valueOf()], value);
                }
              }
              if (json && "toJSON" in value)
                return pair(value.toJSON());
              const entries = [];
              const index2 = as([TYPE, entries], value);
              for (const key2 of keys(value)) {
                if (strict || !shouldSkip(typeOf(value[key2])))
                  entries.push([pair(key2), pair(value[key2])]);
              }
              return index2;
            }
            case DATE:
              return as([TYPE, value.toISOString()], value);
            case REGEXP: {
              const { source, flags } = value;
              return as([TYPE, { source, flags }], value);
            }
            case MAP: {
              const entries = [];
              const index2 = as([TYPE, entries], value);
              for (const [key2, entry] of value) {
                if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
                  entries.push([pair(key2), pair(entry)]);
              }
              return index2;
            }
            case SET: {
              const entries = [];
              const index2 = as([TYPE, entries], value);
              for (const entry of value) {
                if (strict || !shouldSkip(typeOf(entry)))
                  entries.push(pair(entry));
              }
              return index2;
            }
          }
          const { message } = value;
          return as([TYPE, { name: type, message }], value);
        };
        return pair;
      };
      serialize2 = (value, { json, lossy } = {}) => {
        const _ = [];
        return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
      };
    }
  });

  // node_modules/@ungap/structured-clone/esm/index.js
  var esm_default;
  var init_esm = __esm({
    "node_modules/@ungap/structured-clone/esm/index.js"() {
      init_deserialize();
      init_serialize();
      esm_default = typeof structuredClone === "function" ? (
        /* c8 ignore start */
        (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize2(any, options)) : structuredClone(any)
      ) : (any, options) => deserialize(serialize2(any, options));
    }
  });

  // node_modules/mdast-util-to-hast/lib/footer.js
  function defaultFootnoteBackContent(_, rereferenceIndex) {
    const result = [{ type: "text", value: "\u21A9" }];
    if (rereferenceIndex > 1) {
      result.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{ type: "text", value: String(rereferenceIndex) }]
      });
    }
    return result;
  }
  function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
    return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
  }
  function footer(state) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
    const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
    const footnoteLabel = state.options.footnoteLabel || "Footnotes";
    const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
    const footnoteLabelProperties = state.options.footnoteLabelProperties || {
      className: ["sr-only"]
    };
    const listItems = [];
    let referenceIndex = -1;
    while (++referenceIndex < state.footnoteOrder.length) {
      const definition3 = state.footnoteById.get(
        state.footnoteOrder[referenceIndex]
      );
      if (!definition3) {
        continue;
      }
      const content3 = state.all(definition3);
      const id = String(definition3.identifier).toUpperCase();
      const safeId = normalizeUri(id.toLowerCase());
      let rereferenceIndex = 0;
      const backReferences = [];
      const counts = state.footnoteCounts.get(id);
      while (counts !== void 0 && ++rereferenceIndex <= counts) {
        if (backReferences.length > 0) {
          backReferences.push({ type: "text", value: " " });
        }
        let children2 = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
        if (typeof children2 === "string") {
          children2 = { type: "text", value: children2 };
        }
        backReferences.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(children2) ? children2 : [children2]
        });
      }
      const tail = content3[content3.length - 1];
      if (tail && tail.type === "element" && tail.tagName === "p") {
        const tailTail = tail.children[tail.children.length - 1];
        if (tailTail && tailTail.type === "text") {
          tailTail.value += " ";
        } else {
          tail.children.push({ type: "text", value: " " });
        }
        tail.children.push(...backReferences);
      } else {
        content3.push(...backReferences);
      }
      const listItem3 = {
        type: "element",
        tagName: "li",
        properties: { id: clobberPrefix + "fn-" + safeId },
        children: state.wrap(content3, true)
      };
      state.patch(definition3, listItem3);
      listItems.push(listItem3);
    }
    if (listItems.length === 0) {
      return;
    }
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: footnoteLabelTagName,
          properties: {
            ...esm_default(footnoteLabelProperties),
            id: "footnote-label"
          },
          children: [{ type: "text", value: footnoteLabel }]
        },
        { type: "text", value: "\n" },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, true)
        },
        { type: "text", value: "\n" }
      ]
    };
  }
  var init_footer = __esm({
    "node_modules/mdast-util-to-hast/lib/footer.js"() {
      init_esm();
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/state.js
  function createState(tree, options) {
    const settings = options || emptyOptions4;
    const definitionById = /* @__PURE__ */ new Map();
    const footnoteById = /* @__PURE__ */ new Map();
    const footnoteCounts = /* @__PURE__ */ new Map();
    const handlers2 = { ...handlers, ...settings.handlers };
    const state = {
      all: all4,
      applyData,
      definitionById,
      footnoteById,
      footnoteCounts,
      footnoteOrder: [],
      handlers: handlers2,
      one: one4,
      options: settings,
      patch,
      wrap: wrap2
    };
    visit(tree, function(node2) {
      if (node2.type === "definition" || node2.type === "footnoteDefinition") {
        const map3 = node2.type === "definition" ? definitionById : footnoteById;
        const id = String(node2.identifier).toUpperCase();
        if (!map3.has(id)) {
          map3.set(id, node2);
        }
      }
    });
    return state;
    function one4(node2, parent) {
      const type = node2.type;
      const handle3 = state.handlers[type];
      if (own4.call(state.handlers, type) && handle3) {
        return handle3(state, node2, parent);
      }
      if (state.options.passThrough && state.options.passThrough.includes(type)) {
        if ("children" in node2) {
          const { children: children2, ...shallow } = node2;
          const result = esm_default(shallow);
          result.children = state.all(node2);
          return result;
        }
        return esm_default(node2);
      }
      const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
      return unknown2(state, node2, parent);
    }
    function all4(parent) {
      const values = [];
      if ("children" in parent) {
        const nodes = parent.children;
        let index2 = -1;
        while (++index2 < nodes.length) {
          const result = state.one(nodes[index2], parent);
          if (result) {
            if (index2 && nodes[index2 - 1].type === "break") {
              if (!Array.isArray(result) && result.type === "text") {
                result.value = trimMarkdownSpaceStart(result.value);
              }
              if (!Array.isArray(result) && result.type === "element") {
                const head2 = result.children[0];
                if (head2 && head2.type === "text") {
                  head2.value = trimMarkdownSpaceStart(head2.value);
                }
              }
            }
            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }
      return values;
    }
  }
  function patch(from, to) {
    if (from.position) to.position = position2(from);
  }
  function applyData(from, to) {
    let result = to;
    if (from && from.data) {
      const hName = from.data.hName;
      const hChildren = from.data.hChildren;
      const hProperties = from.data.hProperties;
      if (typeof hName === "string") {
        if (result.type === "element") {
          result.tagName = hName;
        } else {
          const children2 = "children" in result ? result.children : [result];
          result = { type: "element", tagName: hName, properties: {}, children: children2 };
        }
      }
      if (result.type === "element" && hProperties) {
        Object.assign(result.properties, esm_default(hProperties));
      }
      if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
        result.children = hChildren;
      }
    }
    return result;
  }
  function defaultUnknownHandler(state, node2) {
    const data = node2.data || {};
    const result = "value" in node2 && !(own4.call(data, "hProperties") || own4.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function wrap2(nodes, loose) {
    const result = [];
    let index2 = -1;
    if (loose) {
      result.push({ type: "text", value: "\n" });
    }
    while (++index2 < nodes.length) {
      if (index2) result.push({ type: "text", value: "\n" });
      result.push(nodes[index2]);
    }
    if (loose && nodes.length > 0) {
      result.push({ type: "text", value: "\n" });
    }
    return result;
  }
  function trimMarkdownSpaceStart(value) {
    let index2 = 0;
    let code4 = value.charCodeAt(index2);
    while (code4 === 9 || code4 === 32) {
      index2++;
      code4 = value.charCodeAt(index2);
    }
    return value.slice(index2);
  }
  var own4, emptyOptions4;
  var init_state = __esm({
    "node_modules/mdast-util-to-hast/lib/state.js"() {
      init_esm();
      init_unist_util_visit();
      init_unist_util_position();
      init_handlers();
      own4 = {}.hasOwnProperty;
      emptyOptions4 = {};
    }
  });

  // node_modules/mdast-util-to-hast/lib/index.js
  function toHast(tree, options) {
    const state = createState(tree, options);
    const node2 = state.one(tree, void 0);
    const foot = footer(state);
    const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
    if (foot) {
      ok("children" in result);
      result.children.push({ type: "text", value: "\n" }, foot);
    }
    return result;
  }
  var init_lib24 = __esm({
    "node_modules/mdast-util-to-hast/lib/index.js"() {
      init_default();
      init_footer();
      init_state();
    }
  });

  // node_modules/mdast-util-to-hast/index.js
  var init_mdast_util_to_hast = __esm({
    "node_modules/mdast-util-to-hast/index.js"() {
      init_lib24();
    }
  });

  // node_modules/remark-rehype/lib/index.js
  function remarkRehype(destination, options) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const hastTree = (
          /** @type {HastRoot} */
          toHast(tree, { file, ...options })
        );
        await destination.run(hastTree, file);
      };
    }
    return function(tree, file) {
      return (
        /** @type {HastRoot} */
        toHast(tree, { file, ...destination || options })
      );
    };
  }
  var init_lib25 = __esm({
    "node_modules/remark-rehype/lib/index.js"() {
      init_mdast_util_to_hast();
    }
  });

  // node_modules/remark-rehype/index.js
  var init_remark_rehype = __esm({
    "node_modules/remark-rehype/index.js"() {
      init_lib25();
    }
  });

  // node_modules/property-information/lib/util/schema.js
  var Schema;
  var init_schema = __esm({
    "node_modules/property-information/lib/util/schema.js"() {
      Schema = class {
        /**
         * @param {SchemaType['property']} property
         *   Property.
         * @param {SchemaType['normal']} normal
         *   Normal.
         * @param {Space | undefined} [space]
         *   Space.
         * @returns
         *   Schema.
         */
        constructor(property, normal, space2) {
          this.normal = normal;
          this.property = property;
          if (space2) {
            this.space = space2;
          }
        }
      };
      Schema.prototype.normal = {};
      Schema.prototype.property = {};
      Schema.prototype.space = void 0;
    }
  });

  // node_modules/property-information/lib/util/merge.js
  function merge(definitions, space2) {
    const property = {};
    const normal = {};
    for (const definition3 of definitions) {
      Object.assign(property, definition3.property);
      Object.assign(normal, definition3.normal);
    }
    return new Schema(property, normal, space2);
  }
  var init_merge = __esm({
    "node_modules/property-information/lib/util/merge.js"() {
      init_schema();
    }
  });

  // node_modules/property-information/lib/normalize.js
  function normalize2(value) {
    return value.toLowerCase();
  }
  var init_normalize = __esm({
    "node_modules/property-information/lib/normalize.js"() {
    }
  });

  // node_modules/property-information/lib/util/info.js
  var Info;
  var init_info = __esm({
    "node_modules/property-information/lib/util/info.js"() {
      Info = class {
        /**
         * @param {string} property
         *   Property.
         * @param {string} attribute
         *   Attribute.
         * @returns
         *   Info.
         */
        constructor(property, attribute) {
          this.attribute = attribute;
          this.property = property;
        }
      };
      Info.prototype.attribute = "";
      Info.prototype.booleanish = false;
      Info.prototype.boolean = false;
      Info.prototype.commaOrSpaceSeparated = false;
      Info.prototype.commaSeparated = false;
      Info.prototype.defined = false;
      Info.prototype.mustUseProperty = false;
      Info.prototype.number = false;
      Info.prototype.overloadedBoolean = false;
      Info.prototype.property = "";
      Info.prototype.spaceSeparated = false;
      Info.prototype.space = void 0;
    }
  });

  // node_modules/property-information/lib/util/types.js
  var types_exports = {};
  __export(types_exports, {
    boolean: () => boolean,
    booleanish: () => booleanish,
    commaOrSpaceSeparated: () => commaOrSpaceSeparated,
    commaSeparated: () => commaSeparated,
    number: () => number,
    overloadedBoolean: () => overloadedBoolean,
    spaceSeparated: () => spaceSeparated
  });
  function increment() {
    return 2 ** ++powers;
  }
  var powers, boolean, booleanish, overloadedBoolean, number, spaceSeparated, commaSeparated, commaOrSpaceSeparated;
  var init_types2 = __esm({
    "node_modules/property-information/lib/util/types.js"() {
      powers = 0;
      boolean = increment();
      booleanish = increment();
      overloadedBoolean = increment();
      number = increment();
      spaceSeparated = increment();
      commaSeparated = increment();
      commaOrSpaceSeparated = increment();
    }
  });

  // node_modules/property-information/lib/util/defined-info.js
  function mark(values, key2, value) {
    if (value) {
      values[key2] = value;
    }
  }
  var checks, DefinedInfo;
  var init_defined_info = __esm({
    "node_modules/property-information/lib/util/defined-info.js"() {
      init_info();
      init_types2();
      checks = /** @type {ReadonlyArray<keyof typeof types>} */
      Object.keys(types_exports);
      DefinedInfo = class extends Info {
        /**
         * @constructor
         * @param {string} property
         *   Property.
         * @param {string} attribute
         *   Attribute.
         * @param {number | null | undefined} [mask]
         *   Mask.
         * @param {Space | undefined} [space]
         *   Space.
         * @returns
         *   Info.
         */
        constructor(property, attribute, mask, space2) {
          let index2 = -1;
          super(property, attribute);
          mark(this, "space", space2);
          if (typeof mask === "number") {
            while (++index2 < checks.length) {
              const check = checks[index2];
              mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
            }
          }
        }
      };
      DefinedInfo.prototype.defined = true;
    }
  });

  // node_modules/property-information/lib/util/create.js
  function create(definition3) {
    const properties2 = {};
    const normals = {};
    for (const [property, value] of Object.entries(definition3.properties)) {
      const info = new DefinedInfo(
        property,
        definition3.transform(definition3.attributes || {}, property),
        value,
        definition3.space
      );
      if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
        info.mustUseProperty = true;
      }
      properties2[property] = info;
      normals[normalize2(property)] = property;
      normals[normalize2(info.attribute)] = property;
    }
    return new Schema(properties2, normals, definition3.space);
  }
  var init_create = __esm({
    "node_modules/property-information/lib/util/create.js"() {
      init_normalize();
      init_defined_info();
      init_schema();
    }
  });

  // node_modules/property-information/lib/aria.js
  var aria;
  var init_aria = __esm({
    "node_modules/property-information/lib/aria.js"() {
      init_create();
      init_types2();
      aria = create({
        properties: {
          ariaActiveDescendant: null,
          ariaAtomic: booleanish,
          ariaAutoComplete: null,
          ariaBusy: booleanish,
          ariaChecked: booleanish,
          ariaColCount: number,
          ariaColIndex: number,
          ariaColSpan: number,
          ariaControls: spaceSeparated,
          ariaCurrent: null,
          ariaDescribedBy: spaceSeparated,
          ariaDetails: null,
          ariaDisabled: booleanish,
          ariaDropEffect: spaceSeparated,
          ariaErrorMessage: null,
          ariaExpanded: booleanish,
          ariaFlowTo: spaceSeparated,
          ariaGrabbed: booleanish,
          ariaHasPopup: null,
          ariaHidden: booleanish,
          ariaInvalid: null,
          ariaKeyShortcuts: null,
          ariaLabel: null,
          ariaLabelledBy: spaceSeparated,
          ariaLevel: number,
          ariaLive: null,
          ariaModal: booleanish,
          ariaMultiLine: booleanish,
          ariaMultiSelectable: booleanish,
          ariaOrientation: null,
          ariaOwns: spaceSeparated,
          ariaPlaceholder: null,
          ariaPosInSet: number,
          ariaPressed: booleanish,
          ariaReadOnly: booleanish,
          ariaRelevant: null,
          ariaRequired: booleanish,
          ariaRoleDescription: spaceSeparated,
          ariaRowCount: number,
          ariaRowIndex: number,
          ariaRowSpan: number,
          ariaSelected: booleanish,
          ariaSetSize: number,
          ariaSort: null,
          ariaValueMax: number,
          ariaValueMin: number,
          ariaValueNow: number,
          ariaValueText: null,
          role: null
        },
        transform(_, property) {
          return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/util/case-sensitive-transform.js
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  var init_case_sensitive_transform = __esm({
    "node_modules/property-information/lib/util/case-sensitive-transform.js"() {
    }
  });

  // node_modules/property-information/lib/util/case-insensitive-transform.js
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  var init_case_insensitive_transform = __esm({
    "node_modules/property-information/lib/util/case-insensitive-transform.js"() {
      init_case_sensitive_transform();
    }
  });

  // node_modules/property-information/lib/html.js
  var html3;
  var init_html3 = __esm({
    "node_modules/property-information/lib/html.js"() {
      init_case_insensitive_transform();
      init_create();
      init_types2();
      html3 = create({
        attributes: {
          acceptcharset: "accept-charset",
          classname: "class",
          htmlfor: "for",
          httpequiv: "http-equiv"
        },
        mustUseProperty: ["checked", "multiple", "muted", "selected"],
        properties: {
          // Standard Properties.
          abbr: null,
          accept: commaSeparated,
          acceptCharset: spaceSeparated,
          accessKey: spaceSeparated,
          action: null,
          allow: null,
          allowFullScreen: boolean,
          allowPaymentRequest: boolean,
          allowUserMedia: boolean,
          alt: null,
          as: null,
          async: boolean,
          autoCapitalize: null,
          autoComplete: spaceSeparated,
          autoFocus: boolean,
          autoPlay: boolean,
          blocking: spaceSeparated,
          capture: null,
          charSet: null,
          checked: boolean,
          cite: null,
          className: spaceSeparated,
          cols: number,
          colSpan: null,
          content: null,
          contentEditable: booleanish,
          controls: boolean,
          controlsList: spaceSeparated,
          coords: number | commaSeparated,
          crossOrigin: null,
          data: null,
          dateTime: null,
          decoding: null,
          default: boolean,
          defer: boolean,
          dir: null,
          dirName: null,
          disabled: boolean,
          download: overloadedBoolean,
          draggable: booleanish,
          encType: null,
          enterKeyHint: null,
          fetchPriority: null,
          form: null,
          formAction: null,
          formEncType: null,
          formMethod: null,
          formNoValidate: boolean,
          formTarget: null,
          headers: spaceSeparated,
          height: number,
          hidden: boolean,
          high: number,
          href: null,
          hrefLang: null,
          htmlFor: spaceSeparated,
          httpEquiv: spaceSeparated,
          id: null,
          imageSizes: null,
          imageSrcSet: null,
          inert: boolean,
          inputMode: null,
          integrity: null,
          is: null,
          isMap: boolean,
          itemId: null,
          itemProp: spaceSeparated,
          itemRef: spaceSeparated,
          itemScope: boolean,
          itemType: spaceSeparated,
          kind: null,
          label: null,
          lang: null,
          language: null,
          list: null,
          loading: null,
          loop: boolean,
          low: number,
          manifest: null,
          max: null,
          maxLength: number,
          media: null,
          method: null,
          min: null,
          minLength: number,
          multiple: boolean,
          muted: boolean,
          name: null,
          nonce: null,
          noModule: boolean,
          noValidate: boolean,
          onAbort: null,
          onAfterPrint: null,
          onAuxClick: null,
          onBeforeMatch: null,
          onBeforePrint: null,
          onBeforeToggle: null,
          onBeforeUnload: null,
          onBlur: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onContextLost: null,
          onContextMenu: null,
          onContextRestored: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFormData: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLanguageChange: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadEnd: null,
          onLoadStart: null,
          onMessage: null,
          onMessageError: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRejectionHandled: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onScrollEnd: null,
          onSecurityPolicyViolation: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onSlotChange: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnhandledRejection: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onWheel: null,
          open: boolean,
          optimum: number,
          pattern: null,
          ping: spaceSeparated,
          placeholder: null,
          playsInline: boolean,
          popover: null,
          popoverTarget: null,
          popoverTargetAction: null,
          poster: null,
          preload: null,
          readOnly: boolean,
          referrerPolicy: null,
          rel: spaceSeparated,
          required: boolean,
          reversed: boolean,
          rows: number,
          rowSpan: number,
          sandbox: spaceSeparated,
          scope: null,
          scoped: boolean,
          seamless: boolean,
          selected: boolean,
          shadowRootClonable: boolean,
          shadowRootDelegatesFocus: boolean,
          shadowRootMode: null,
          shape: null,
          size: number,
          sizes: null,
          slot: null,
          span: number,
          spellCheck: booleanish,
          src: null,
          srcDoc: null,
          srcLang: null,
          srcSet: null,
          start: number,
          step: null,
          style: null,
          tabIndex: number,
          target: null,
          title: null,
          translate: null,
          type: null,
          typeMustMatch: boolean,
          useMap: null,
          value: booleanish,
          width: number,
          wrap: null,
          writingSuggestions: null,
          // Legacy.
          // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
          align: null,
          // Several. Use CSS `text-align` instead,
          aLink: null,
          // `<body>`. Use CSS `a:active {color}` instead
          archive: spaceSeparated,
          // `<object>`. List of URIs to archives
          axis: null,
          // `<td>` and `<th>`. Use `scope` on `<th>`
          background: null,
          // `<body>`. Use CSS `background-image` instead
          bgColor: null,
          // `<body>` and table elements. Use CSS `background-color` instead
          border: number,
          // `<table>`. Use CSS `border-width` instead,
          borderColor: null,
          // `<table>`. Use CSS `border-color` instead,
          bottomMargin: number,
          // `<body>`
          cellPadding: null,
          // `<table>`
          cellSpacing: null,
          // `<table>`
          char: null,
          // Several table elements. When `align=char`, sets the character to align on
          charOff: null,
          // Several table elements. When `char`, offsets the alignment
          classId: null,
          // `<object>`
          clear: null,
          // `<br>`. Use CSS `clear` instead
          code: null,
          // `<object>`
          codeBase: null,
          // `<object>`
          codeType: null,
          // `<object>`
          color: null,
          // `<font>` and `<hr>`. Use CSS instead
          compact: boolean,
          // Lists. Use CSS to reduce space between items instead
          declare: boolean,
          // `<object>`
          event: null,
          // `<script>`
          face: null,
          // `<font>`. Use CSS instead
          frame: null,
          // `<table>`
          frameBorder: null,
          // `<iframe>`. Use CSS `border` instead
          hSpace: number,
          // `<img>` and `<object>`
          leftMargin: number,
          // `<body>`
          link: null,
          // `<body>`. Use CSS `a:link {color: *}` instead
          longDesc: null,
          // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
          lowSrc: null,
          // `<img>`. Use a `<picture>`
          marginHeight: number,
          // `<body>`
          marginWidth: number,
          // `<body>`
          noResize: boolean,
          // `<frame>`
          noHref: boolean,
          // `<area>`. Use no href instead of an explicit `nohref`
          noShade: boolean,
          // `<hr>`. Use background-color and height instead of borders
          noWrap: boolean,
          // `<td>` and `<th>`
          object: null,
          // `<applet>`
          profile: null,
          // `<head>`
          prompt: null,
          // `<isindex>`
          rev: null,
          // `<link>`
          rightMargin: number,
          // `<body>`
          rules: null,
          // `<table>`
          scheme: null,
          // `<meta>`
          scrolling: booleanish,
          // `<frame>`. Use overflow in the child context
          standby: null,
          // `<object>`
          summary: null,
          // `<table>`
          text: null,
          // `<body>`. Use CSS `color` instead
          topMargin: number,
          // `<body>`
          valueType: null,
          // `<param>`
          version: null,
          // `<html>`. Use a doctype.
          vAlign: null,
          // Several. Use CSS `vertical-align` instead
          vLink: null,
          // `<body>`. Use CSS `a:visited {color}` instead
          vSpace: number,
          // `<img>` and `<object>`
          // Non-standard Properties.
          allowTransparency: null,
          autoCorrect: null,
          autoSave: null,
          disablePictureInPicture: boolean,
          disableRemotePlayback: boolean,
          prefix: null,
          property: null,
          results: number,
          security: null,
          unselectable: null
        },
        space: "html",
        transform: caseInsensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/svg.js
  var svg;
  var init_svg = __esm({
    "node_modules/property-information/lib/svg.js"() {
      init_case_sensitive_transform();
      init_create();
      init_types2();
      svg = create({
        attributes: {
          accentHeight: "accent-height",
          alignmentBaseline: "alignment-baseline",
          arabicForm: "arabic-form",
          baselineShift: "baseline-shift",
          capHeight: "cap-height",
          className: "class",
          clipPath: "clip-path",
          clipRule: "clip-rule",
          colorInterpolation: "color-interpolation",
          colorInterpolationFilters: "color-interpolation-filters",
          colorProfile: "color-profile",
          colorRendering: "color-rendering",
          crossOrigin: "crossorigin",
          dataType: "datatype",
          dominantBaseline: "dominant-baseline",
          enableBackground: "enable-background",
          fillOpacity: "fill-opacity",
          fillRule: "fill-rule",
          floodColor: "flood-color",
          floodOpacity: "flood-opacity",
          fontFamily: "font-family",
          fontSize: "font-size",
          fontSizeAdjust: "font-size-adjust",
          fontStretch: "font-stretch",
          fontStyle: "font-style",
          fontVariant: "font-variant",
          fontWeight: "font-weight",
          glyphName: "glyph-name",
          glyphOrientationHorizontal: "glyph-orientation-horizontal",
          glyphOrientationVertical: "glyph-orientation-vertical",
          hrefLang: "hreflang",
          horizAdvX: "horiz-adv-x",
          horizOriginX: "horiz-origin-x",
          horizOriginY: "horiz-origin-y",
          imageRendering: "image-rendering",
          letterSpacing: "letter-spacing",
          lightingColor: "lighting-color",
          markerEnd: "marker-end",
          markerMid: "marker-mid",
          markerStart: "marker-start",
          navDown: "nav-down",
          navDownLeft: "nav-down-left",
          navDownRight: "nav-down-right",
          navLeft: "nav-left",
          navNext: "nav-next",
          navPrev: "nav-prev",
          navRight: "nav-right",
          navUp: "nav-up",
          navUpLeft: "nav-up-left",
          navUpRight: "nav-up-right",
          onAbort: "onabort",
          onActivate: "onactivate",
          onAfterPrint: "onafterprint",
          onBeforePrint: "onbeforeprint",
          onBegin: "onbegin",
          onCancel: "oncancel",
          onCanPlay: "oncanplay",
          onCanPlayThrough: "oncanplaythrough",
          onChange: "onchange",
          onClick: "onclick",
          onClose: "onclose",
          onCopy: "oncopy",
          onCueChange: "oncuechange",
          onCut: "oncut",
          onDblClick: "ondblclick",
          onDrag: "ondrag",
          onDragEnd: "ondragend",
          onDragEnter: "ondragenter",
          onDragExit: "ondragexit",
          onDragLeave: "ondragleave",
          onDragOver: "ondragover",
          onDragStart: "ondragstart",
          onDrop: "ondrop",
          onDurationChange: "ondurationchange",
          onEmptied: "onemptied",
          onEnd: "onend",
          onEnded: "onended",
          onError: "onerror",
          onFocus: "onfocus",
          onFocusIn: "onfocusin",
          onFocusOut: "onfocusout",
          onHashChange: "onhashchange",
          onInput: "oninput",
          onInvalid: "oninvalid",
          onKeyDown: "onkeydown",
          onKeyPress: "onkeypress",
          onKeyUp: "onkeyup",
          onLoad: "onload",
          onLoadedData: "onloadeddata",
          onLoadedMetadata: "onloadedmetadata",
          onLoadStart: "onloadstart",
          onMessage: "onmessage",
          onMouseDown: "onmousedown",
          onMouseEnter: "onmouseenter",
          onMouseLeave: "onmouseleave",
          onMouseMove: "onmousemove",
          onMouseOut: "onmouseout",
          onMouseOver: "onmouseover",
          onMouseUp: "onmouseup",
          onMouseWheel: "onmousewheel",
          onOffline: "onoffline",
          onOnline: "ononline",
          onPageHide: "onpagehide",
          onPageShow: "onpageshow",
          onPaste: "onpaste",
          onPause: "onpause",
          onPlay: "onplay",
          onPlaying: "onplaying",
          onPopState: "onpopstate",
          onProgress: "onprogress",
          onRateChange: "onratechange",
          onRepeat: "onrepeat",
          onReset: "onreset",
          onResize: "onresize",
          onScroll: "onscroll",
          onSeeked: "onseeked",
          onSeeking: "onseeking",
          onSelect: "onselect",
          onShow: "onshow",
          onStalled: "onstalled",
          onStorage: "onstorage",
          onSubmit: "onsubmit",
          onSuspend: "onsuspend",
          onTimeUpdate: "ontimeupdate",
          onToggle: "ontoggle",
          onUnload: "onunload",
          onVolumeChange: "onvolumechange",
          onWaiting: "onwaiting",
          onZoom: "onzoom",
          overlinePosition: "overline-position",
          overlineThickness: "overline-thickness",
          paintOrder: "paint-order",
          panose1: "panose-1",
          pointerEvents: "pointer-events",
          referrerPolicy: "referrerpolicy",
          renderingIntent: "rendering-intent",
          shapeRendering: "shape-rendering",
          stopColor: "stop-color",
          stopOpacity: "stop-opacity",
          strikethroughPosition: "strikethrough-position",
          strikethroughThickness: "strikethrough-thickness",
          strokeDashArray: "stroke-dasharray",
          strokeDashOffset: "stroke-dashoffset",
          strokeLineCap: "stroke-linecap",
          strokeLineJoin: "stroke-linejoin",
          strokeMiterLimit: "stroke-miterlimit",
          strokeOpacity: "stroke-opacity",
          strokeWidth: "stroke-width",
          tabIndex: "tabindex",
          textAnchor: "text-anchor",
          textDecoration: "text-decoration",
          textRendering: "text-rendering",
          transformOrigin: "transform-origin",
          typeOf: "typeof",
          underlinePosition: "underline-position",
          underlineThickness: "underline-thickness",
          unicodeBidi: "unicode-bidi",
          unicodeRange: "unicode-range",
          unitsPerEm: "units-per-em",
          vAlphabetic: "v-alphabetic",
          vHanging: "v-hanging",
          vIdeographic: "v-ideographic",
          vMathematical: "v-mathematical",
          vectorEffect: "vector-effect",
          vertAdvY: "vert-adv-y",
          vertOriginX: "vert-origin-x",
          vertOriginY: "vert-origin-y",
          wordSpacing: "word-spacing",
          writingMode: "writing-mode",
          xHeight: "x-height",
          // These were camelcased in Tiny. Now lowercased in SVG 2
          playbackOrder: "playbackorder",
          timelineBegin: "timelinebegin"
        },
        properties: {
          about: commaOrSpaceSeparated,
          accentHeight: number,
          accumulate: null,
          additive: null,
          alignmentBaseline: null,
          alphabetic: number,
          amplitude: number,
          arabicForm: null,
          ascent: number,
          attributeName: null,
          attributeType: null,
          azimuth: number,
          bandwidth: null,
          baselineShift: null,
          baseFrequency: null,
          baseProfile: null,
          bbox: null,
          begin: null,
          bias: number,
          by: null,
          calcMode: null,
          capHeight: number,
          className: spaceSeparated,
          clip: null,
          clipPath: null,
          clipPathUnits: null,
          clipRule: null,
          color: null,
          colorInterpolation: null,
          colorInterpolationFilters: null,
          colorProfile: null,
          colorRendering: null,
          content: null,
          contentScriptType: null,
          contentStyleType: null,
          crossOrigin: null,
          cursor: null,
          cx: null,
          cy: null,
          d: null,
          dataType: null,
          defaultAction: null,
          descent: number,
          diffuseConstant: number,
          direction: null,
          display: null,
          dur: null,
          divisor: number,
          dominantBaseline: null,
          download: boolean,
          dx: null,
          dy: null,
          edgeMode: null,
          editable: null,
          elevation: number,
          enableBackground: null,
          end: null,
          event: null,
          exponent: number,
          externalResourcesRequired: null,
          fill: null,
          fillOpacity: number,
          fillRule: null,
          filter: null,
          filterRes: null,
          filterUnits: null,
          floodColor: null,
          floodOpacity: null,
          focusable: null,
          focusHighlight: null,
          fontFamily: null,
          fontSize: null,
          fontSizeAdjust: null,
          fontStretch: null,
          fontStyle: null,
          fontVariant: null,
          fontWeight: null,
          format: null,
          fr: null,
          from: null,
          fx: null,
          fy: null,
          g1: commaSeparated,
          g2: commaSeparated,
          glyphName: commaSeparated,
          glyphOrientationHorizontal: null,
          glyphOrientationVertical: null,
          glyphRef: null,
          gradientTransform: null,
          gradientUnits: null,
          handler: null,
          hanging: number,
          hatchContentUnits: null,
          hatchUnits: null,
          height: null,
          href: null,
          hrefLang: null,
          horizAdvX: number,
          horizOriginX: number,
          horizOriginY: number,
          id: null,
          ideographic: number,
          imageRendering: null,
          initialVisibility: null,
          in: null,
          in2: null,
          intercept: number,
          k: number,
          k1: number,
          k2: number,
          k3: number,
          k4: number,
          kernelMatrix: commaOrSpaceSeparated,
          kernelUnitLength: null,
          keyPoints: null,
          // SEMI_COLON_SEPARATED
          keySplines: null,
          // SEMI_COLON_SEPARATED
          keyTimes: null,
          // SEMI_COLON_SEPARATED
          kerning: null,
          lang: null,
          lengthAdjust: null,
          letterSpacing: null,
          lightingColor: null,
          limitingConeAngle: number,
          local: null,
          markerEnd: null,
          markerMid: null,
          markerStart: null,
          markerHeight: null,
          markerUnits: null,
          markerWidth: null,
          mask: null,
          maskContentUnits: null,
          maskUnits: null,
          mathematical: null,
          max: null,
          media: null,
          mediaCharacterEncoding: null,
          mediaContentEncodings: null,
          mediaSize: number,
          mediaTime: null,
          method: null,
          min: null,
          mode: null,
          name: null,
          navDown: null,
          navDownLeft: null,
          navDownRight: null,
          navLeft: null,
          navNext: null,
          navPrev: null,
          navRight: null,
          navUp: null,
          navUpLeft: null,
          navUpRight: null,
          numOctaves: null,
          observer: null,
          offset: null,
          onAbort: null,
          onActivate: null,
          onAfterPrint: null,
          onBeforePrint: null,
          onBegin: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnd: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFocusIn: null,
          onFocusOut: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadStart: null,
          onMessage: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onMouseWheel: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRepeat: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onShow: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onZoom: null,
          opacity: null,
          operator: null,
          order: null,
          orient: null,
          orientation: null,
          origin: null,
          overflow: null,
          overlay: null,
          overlinePosition: number,
          overlineThickness: number,
          paintOrder: null,
          panose1: null,
          path: null,
          pathLength: number,
          patternContentUnits: null,
          patternTransform: null,
          patternUnits: null,
          phase: null,
          ping: spaceSeparated,
          pitch: null,
          playbackOrder: null,
          pointerEvents: null,
          points: null,
          pointsAtX: number,
          pointsAtY: number,
          pointsAtZ: number,
          preserveAlpha: null,
          preserveAspectRatio: null,
          primitiveUnits: null,
          propagate: null,
          property: commaOrSpaceSeparated,
          r: null,
          radius: null,
          referrerPolicy: null,
          refX: null,
          refY: null,
          rel: commaOrSpaceSeparated,
          rev: commaOrSpaceSeparated,
          renderingIntent: null,
          repeatCount: null,
          repeatDur: null,
          requiredExtensions: commaOrSpaceSeparated,
          requiredFeatures: commaOrSpaceSeparated,
          requiredFonts: commaOrSpaceSeparated,
          requiredFormats: commaOrSpaceSeparated,
          resource: null,
          restart: null,
          result: null,
          rotate: null,
          rx: null,
          ry: null,
          scale: null,
          seed: null,
          shapeRendering: null,
          side: null,
          slope: null,
          snapshotTime: null,
          specularConstant: number,
          specularExponent: number,
          spreadMethod: null,
          spacing: null,
          startOffset: null,
          stdDeviation: null,
          stemh: null,
          stemv: null,
          stitchTiles: null,
          stopColor: null,
          stopOpacity: null,
          strikethroughPosition: number,
          strikethroughThickness: number,
          string: null,
          stroke: null,
          strokeDashArray: commaOrSpaceSeparated,
          strokeDashOffset: null,
          strokeLineCap: null,
          strokeLineJoin: null,
          strokeMiterLimit: number,
          strokeOpacity: number,
          strokeWidth: null,
          style: null,
          surfaceScale: number,
          syncBehavior: null,
          syncBehaviorDefault: null,
          syncMaster: null,
          syncTolerance: null,
          syncToleranceDefault: null,
          systemLanguage: commaOrSpaceSeparated,
          tabIndex: number,
          tableValues: null,
          target: null,
          targetX: number,
          targetY: number,
          textAnchor: null,
          textDecoration: null,
          textRendering: null,
          textLength: null,
          timelineBegin: null,
          title: null,
          transformBehavior: null,
          type: null,
          typeOf: commaOrSpaceSeparated,
          to: null,
          transform: null,
          transformOrigin: null,
          u1: null,
          u2: null,
          underlinePosition: number,
          underlineThickness: number,
          unicode: null,
          unicodeBidi: null,
          unicodeRange: null,
          unitsPerEm: number,
          values: null,
          vAlphabetic: number,
          vMathematical: number,
          vectorEffect: null,
          vHanging: number,
          vIdeographic: number,
          version: null,
          vertAdvY: number,
          vertOriginX: number,
          vertOriginY: number,
          viewBox: null,
          viewTarget: null,
          visibility: null,
          width: null,
          widths: null,
          wordSpacing: null,
          writingMode: null,
          x: null,
          x1: null,
          x2: null,
          xChannelSelector: null,
          xHeight: number,
          y: null,
          y1: null,
          y2: null,
          yChannelSelector: null,
          z: null,
          zoomAndPan: null
        },
        space: "svg",
        transform: caseSensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/xlink.js
  var xlink;
  var init_xlink = __esm({
    "node_modules/property-information/lib/xlink.js"() {
      init_create();
      xlink = create({
        properties: {
          xLinkActuate: null,
          xLinkArcRole: null,
          xLinkHref: null,
          xLinkRole: null,
          xLinkShow: null,
          xLinkTitle: null,
          xLinkType: null
        },
        space: "xlink",
        transform(_, property) {
          return "xlink:" + property.slice(5).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/xmlns.js
  var xmlns;
  var init_xmlns = __esm({
    "node_modules/property-information/lib/xmlns.js"() {
      init_create();
      init_case_insensitive_transform();
      xmlns = create({
        attributes: { xmlnsxlink: "xmlns:xlink" },
        properties: { xmlnsXLink: null, xmlns: null },
        space: "xmlns",
        transform: caseInsensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/xml.js
  var xml;
  var init_xml = __esm({
    "node_modules/property-information/lib/xml.js"() {
      init_create();
      xml = create({
        properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
        space: "xml",
        transform(_, property) {
          return "xml:" + property.slice(3).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/find.js
  function find(schema, value) {
    const normal = normalize2(value);
    let property = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase);
        property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(property, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  var cap, dash, valid;
  var init_find = __esm({
    "node_modules/property-information/lib/find.js"() {
      init_defined_info();
      init_info();
      init_normalize();
      cap = /[A-Z]/g;
      dash = /-[a-z]/g;
      valid = /^data[-\w.:]+$/i;
    }
  });

  // node_modules/property-information/index.js
  var html4, svg2;
  var init_property_information = __esm({
    "node_modules/property-information/index.js"() {
      init_merge();
      init_aria();
      init_html3();
      init_svg();
      init_xlink();
      init_xmlns();
      init_xml();
      init_find();
      init_normalize();
      html4 = merge([aria, html3, xlink, xmlns, xml], "html");
      svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");
    }
  });

  // node_modules/comma-separated-tokens/index.js
  function parse2(value) {
    const tokens = [];
    const input = String(value || "");
    let index2 = input.indexOf(",");
    let start = 0;
    let end = false;
    while (!end) {
      if (index2 === -1) {
        index2 = input.length;
        end = true;
      }
      const token = input.slice(start, index2).trim();
      if (token || !end) {
        tokens.push(token);
      }
      start = index2 + 1;
      index2 = input.indexOf(",", start);
    }
    return tokens;
  }
  function stringify(values, options) {
    const settings = options || {};
    const input = values[values.length - 1] === "" ? [...values, ""] : values;
    return input.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }
  var init_comma_separated_tokens = __esm({
    "node_modules/comma-separated-tokens/index.js"() {
    }
  });

  // node_modules/hast-util-parse-selector/lib/index.js
  function parseSelector(selector, defaultTagName) {
    const value = selector || "";
    const props = {};
    let start = 0;
    let previous4;
    let tagName;
    while (start < value.length) {
      search2.lastIndex = start;
      const match = search2.exec(value);
      const subvalue = value.slice(start, match ? match.index : value.length);
      if (subvalue) {
        if (!previous4) {
          tagName = subvalue;
        } else if (previous4 === "#") {
          props.id = subvalue;
        } else if (Array.isArray(props.className)) {
          props.className.push(subvalue);
        } else {
          props.className = [subvalue];
        }
        start += subvalue.length;
      }
      if (match) {
        previous4 = match[0];
        start++;
      }
    }
    return {
      type: "element",
      // @ts-expect-error: tag name is parsed.
      tagName: tagName || defaultTagName || "div",
      properties: props,
      children: []
    };
  }
  var search2;
  var init_lib26 = __esm({
    "node_modules/hast-util-parse-selector/lib/index.js"() {
      search2 = /[#.]/g;
    }
  });

  // node_modules/hast-util-parse-selector/index.js
  var init_hast_util_parse_selector = __esm({
    "node_modules/hast-util-parse-selector/index.js"() {
      init_lib26();
    }
  });

  // node_modules/space-separated-tokens/index.js
  function parse3(value) {
    const input = String(value || "").trim();
    return input ? input.split(/[ \t\n\r\f]+/g) : [];
  }
  function stringify2(values) {
    return values.join(" ").trim();
  }
  var init_space_separated_tokens = __esm({
    "node_modules/space-separated-tokens/index.js"() {
    }
  });

  // node_modules/hastscript/lib/create-h.js
  function createH(schema, defaultTagName, caseSensitive) {
    const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
    function h2(selector, properties2, ...children2) {
      let node2;
      if (selector === null || selector === void 0) {
        node2 = { type: "root", children: [] };
        const child = (
          /** @type {Child} */
          properties2
        );
        children2.unshift(child);
      } else {
        node2 = parseSelector(selector, defaultTagName);
        const lower = node2.tagName.toLowerCase();
        const adjusted = adjust ? adjust.get(lower) : void 0;
        node2.tagName = adjusted || lower;
        if (isChild(properties2)) {
          children2.unshift(properties2);
        } else {
          for (const [key2, value] of Object.entries(properties2)) {
            addProperty(schema, node2.properties, key2, value);
          }
        }
      }
      for (const child of children2) {
        addChild(node2.children, child);
      }
      if (node2.type === "element" && node2.tagName === "template") {
        node2.content = { type: "root", children: node2.children };
        node2.children = [];
      }
      return node2;
    }
    return h2;
  }
  function isChild(value) {
    if (value === null || typeof value !== "object" || Array.isArray(value)) {
      return true;
    }
    if (typeof value.type !== "string") return false;
    const record = (
      /** @type {Record<string, unknown>} */
      value
    );
    const keys2 = Object.keys(value);
    for (const key2 of keys2) {
      const value2 = record[key2];
      if (value2 && typeof value2 === "object") {
        if (!Array.isArray(value2)) return true;
        const list4 = (
          /** @type {ReadonlyArray<unknown>} */
          value2
        );
        for (const item of list4) {
          if (typeof item !== "number" && typeof item !== "string") {
            return true;
          }
        }
      }
    }
    if ("children" in value && Array.isArray(value.children)) {
      return true;
    }
    return false;
  }
  function addProperty(schema, properties2, key2, value) {
    const info = find(schema, key2);
    let result;
    if (value === null || value === void 0) return;
    if (typeof value === "number") {
      if (Number.isNaN(value)) return;
      result = value;
    } else if (typeof value === "boolean") {
      result = value;
    } else if (typeof value === "string") {
      if (info.spaceSeparated) {
        result = parse3(value);
      } else if (info.commaSeparated) {
        result = parse2(value);
      } else if (info.commaOrSpaceSeparated) {
        result = parse3(parse2(value).join(" "));
      } else {
        result = parsePrimitive(info, info.property, value);
      }
    } else if (Array.isArray(value)) {
      result = [...value];
    } else {
      result = info.property === "style" ? style(value) : String(value);
    }
    if (Array.isArray(result)) {
      const finalResult = [];
      for (const item of result) {
        finalResult.push(
          /** @type {number | string} */
          parsePrimitive(info, info.property, item)
        );
      }
      result = finalResult;
    }
    if (info.property === "className" && Array.isArray(properties2.className)) {
      result = properties2.className.concat(
        /** @type {Array<number | string> | number | string} */
        result
      );
    }
    properties2[info.property] = result;
  }
  function addChild(nodes, value) {
    if (value === null || value === void 0) {
    } else if (typeof value === "number" || typeof value === "string") {
      nodes.push({ type: "text", value: String(value) });
    } else if (Array.isArray(value)) {
      for (const child of value) {
        addChild(nodes, child);
      }
    } else if (typeof value === "object" && "type" in value) {
      if (value.type === "root") {
        addChild(nodes, value.children);
      } else {
        nodes.push(value);
      }
    } else {
      throw new Error("Expected node, nodes, or string, got `" + value + "`");
    }
  }
  function parsePrimitive(info, name, value) {
    if (typeof value === "string") {
      if (info.number && value && !Number.isNaN(Number(value))) {
        return Number(value);
      }
      if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize2(value) === normalize2(name))) {
        return true;
      }
    }
    return value;
  }
  function style(styles2) {
    const result = [];
    for (const [key2, value] of Object.entries(styles2)) {
      result.push([key2, value].join(": "));
    }
    return result.join("; ");
  }
  function createAdjustMap(values) {
    const result = /* @__PURE__ */ new Map();
    for (const value of values) {
      result.set(value.toLowerCase(), value);
    }
    return result;
  }
  var init_create_h = __esm({
    "node_modules/hastscript/lib/create-h.js"() {
      init_comma_separated_tokens();
      init_hast_util_parse_selector();
      init_property_information();
      init_space_separated_tokens();
    }
  });

  // node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
  var svgCaseSensitiveTagNames;
  var init_svg_case_sensitive_tag_names = __esm({
    "node_modules/hastscript/lib/svg-case-sensitive-tag-names.js"() {
      svgCaseSensitiveTagNames = [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "solidColor",
        "textArea",
        "textPath"
      ];
    }
  });

  // node_modules/hastscript/lib/index.js
  var h, s;
  var init_lib27 = __esm({
    "node_modules/hastscript/lib/index.js"() {
      init_property_information();
      init_create_h();
      init_svg_case_sensitive_tag_names();
      h = createH(html4, "div");
      s = createH(svg2, "g", svgCaseSensitiveTagNames);
    }
  });

  // node_modules/hastscript/index.js
  var init_hastscript = __esm({
    "node_modules/hastscript/index.js"() {
      init_lib27();
    }
  });

  // node_modules/web-namespaces/index.js
  var webNamespaces;
  var init_web_namespaces = __esm({
    "node_modules/web-namespaces/index.js"() {
      webNamespaces = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
    }
  });

  // node_modules/hast-util-from-dom/lib/index.js
  function fromDom(tree, options) {
    return transform(tree, options || {}) || { type: "root", children: [] };
  }
  function transform(node2, options) {
    const transformed = one2(node2, options);
    if (transformed && options.afterTransform)
      options.afterTransform(node2, transformed);
    return transformed;
  }
  function one2(node2, options) {
    switch (node2.nodeType) {
      case 1: {
        const domNode = (
          /** @type {Element} */
          node2
        );
        return element2(domNode, options);
      }
      // Ignore: Attr (2).
      case 3: {
        const domNode = (
          /** @type {Text} */
          node2
        );
        return text7(domNode);
      }
      // Ignore: CDATA (4).
      // Removed: Entity reference (5)
      // Removed: Entity (6)
      // Ignore: Processing instruction (7).
      case 8: {
        const domNode = (
          /** @type {Comment} */
          node2
        );
        return comment(domNode);
      }
      case 9: {
        const domNode = (
          /** @type {Document} */
          node2
        );
        return root3(domNode, options);
      }
      case 10: {
        return doctype();
      }
      case 11: {
        const domNode = (
          /** @type {DocumentFragment} */
          node2
        );
        return root3(domNode, options);
      }
      default: {
        return void 0;
      }
    }
  }
  function root3(node2, options) {
    return { type: "root", children: all2(node2, options) };
  }
  function doctype() {
    return { type: "doctype" };
  }
  function text7(node2) {
    return { type: "text", value: node2.nodeValue || "" };
  }
  function comment(node2) {
    return { type: "comment", value: node2.nodeValue || "" };
  }
  function element2(node2, options) {
    const space2 = node2.namespaceURI;
    const x = space2 === webNamespaces.svg ? s : h;
    const tagName = space2 === webNamespaces.html ? node2.tagName.toLowerCase() : node2.tagName;
    const content3 = (
      // @ts-expect-error: DOM types are wrong, content can exist.
      space2 === webNamespaces.html && tagName === "template" ? node2.content : node2
    );
    const attributes = node2.getAttributeNames();
    const properties2 = {};
    let index2 = -1;
    while (++index2 < attributes.length) {
      properties2[attributes[index2]] = node2.getAttribute(attributes[index2]) || "";
    }
    return x(tagName, properties2, all2(content3, options));
  }
  function all2(node2, options) {
    const nodes = node2.childNodes;
    const children2 = [];
    let index2 = -1;
    while (++index2 < nodes.length) {
      const child = transform(nodes[index2], options);
      if (child !== void 0) {
        children2.push(child);
      }
    }
    return children2;
  }
  var init_lib28 = __esm({
    "node_modules/hast-util-from-dom/lib/index.js"() {
      init_hastscript();
      init_web_namespaces();
    }
  });

  // node_modules/hast-util-from-dom/index.js
  var init_hast_util_from_dom = __esm({
    "node_modules/hast-util-from-dom/index.js"() {
      init_lib28();
    }
  });

  // node_modules/hast-util-from-html-isomorphic/lib/browser.js
  function fromHtmlIsomorphic(value, options) {
    const node2 = options?.fragment ? parseFragment(value) : parser.parseFromString(value, "text/html");
    return (
      /** @type {Root} */
      fromDom(node2)
    );
  }
  function parseFragment(value) {
    const template = document.createElement("template");
    template.innerHTML = value;
    return template.content;
  }
  var parser;
  var init_browser = __esm({
    "node_modules/hast-util-from-html-isomorphic/lib/browser.js"() {
      init_hast_util_from_dom();
      parser = new DOMParser();
    }
  });

  // node_modules/unist-util-find-after/lib/index.js
  var findAfter;
  var init_lib29 = __esm({
    "node_modules/unist-util-find-after/lib/index.js"() {
      init_unist_util_is();
      findAfter = // Note: overloads like this are needed to support optional generics.
      /**
       * @type {(
       *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
       *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
       * )}
       */
      /**
       * @param {UnistParent} parent
       * @param {UnistNode | number} index
       * @param {Test} [test]
       * @returns {UnistNode | undefined}
       */
      function(parent, index2, test) {
        const is2 = convert(test);
        if (!parent || !parent.type || !parent.children) {
          throw new Error("Expected parent node");
        }
        if (typeof index2 === "number") {
          if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
            throw new Error("Expected positive finite number as index");
          }
        } else {
          index2 = parent.children.indexOf(index2);
          if (index2 < 0) {
            throw new Error("Expected child node or index");
          }
        }
        while (++index2 < parent.children.length) {
          if (is2(parent.children[index2], index2, parent)) {
            return parent.children[index2];
          }
        }
        return void 0;
      };
    }
  });

  // node_modules/unist-util-find-after/index.js
  var init_unist_util_find_after = __esm({
    "node_modules/unist-util-find-after/index.js"() {
      init_lib29();
    }
  });

  // node_modules/hast-util-is-element/lib/index.js
  function anyFactory2(tests) {
    const checks2 = [];
    let index2 = -1;
    while (++index2 < tests.length) {
      checks2[index2] = convertElement(tests[index2]);
    }
    return castFactory2(any);
    function any(...parameters) {
      let index3 = -1;
      while (++index3 < checks2.length) {
        if (checks2[index3].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function tagNameFactory(check) {
    return castFactory2(tagName);
    function tagName(element6) {
      return element6.tagName === check;
    }
  }
  function castFactory2(testFunction) {
    return check;
    function check(value, index2, parent) {
      return Boolean(
        looksLikeAnElement(value) && testFunction.call(
          this,
          value,
          typeof index2 === "number" ? index2 : void 0,
          parent || void 0
        )
      );
    }
  }
  function element3(element6) {
    return Boolean(
      element6 && typeof element6 === "object" && "type" in element6 && element6.type === "element" && "tagName" in element6 && typeof element6.tagName === "string"
    );
  }
  function looksLikeAnElement(value) {
    return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
  }
  var convertElement;
  var init_lib30 = __esm({
    "node_modules/hast-util-is-element/lib/index.js"() {
      convertElement = // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
       *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
       *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
       *   ((test?: Test) => Check)
       * )}
       */
      /**
       * @param {Test | null | undefined} [test]
       * @returns {Check}
       */
      function(test) {
        if (test === null || test === void 0) {
          return element3;
        }
        if (typeof test === "string") {
          return tagNameFactory(test);
        }
        if (typeof test === "object") {
          return anyFactory2(test);
        }
        if (typeof test === "function") {
          return castFactory2(test);
        }
        throw new Error("Expected function, string, or array as `test`");
      };
    }
  });

  // node_modules/hast-util-is-element/index.js
  var init_hast_util_is_element = __esm({
    "node_modules/hast-util-is-element/index.js"() {
      init_lib30();
    }
  });

  // node_modules/hast-util-to-text/lib/index.js
  function toText(tree, options) {
    const options_ = options || {};
    const children2 = "children" in tree ? tree.children : [];
    const block = blockOrCaption(tree);
    const whitespace2 = inferWhitespace(tree, {
      whitespace: options_.whitespace || "normal",
      breakBefore: false,
      breakAfter: false
    });
    const results = [];
    if (tree.type === "text" || tree.type === "comment") {
      results.push(
        ...collectText(tree, {
          whitespace: whitespace2,
          breakBefore: true,
          breakAfter: true
        })
      );
    }
    let index2 = -1;
    while (++index2 < children2.length) {
      results.push(
        ...renderedTextCollection(
          children2[index2],
          // @ts-expect-error: `tree` is a parent if weâ€™re here.
          tree,
          {
            whitespace: whitespace2,
            breakBefore: index2 ? void 0 : block,
            breakAfter: index2 < children2.length - 1 ? br(children2[index2 + 1]) : block
          }
        )
      );
    }
    const result = [];
    let count;
    index2 = -1;
    while (++index2 < results.length) {
      const value = results[index2];
      if (typeof value === "number") {
        if (count !== void 0 && value > count) count = value;
      } else if (value) {
        if (count !== void 0 && count > -1) {
          result.push("\n".repeat(count) || " ");
        }
        count = -1;
        result.push(value);
      }
    }
    return result.join("");
  }
  function renderedTextCollection(node2, parent, info) {
    if (node2.type === "element") {
      return collectElement(node2, parent, info);
    }
    if (node2.type === "text") {
      return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
    }
    return [];
  }
  function collectElement(node2, parent, info) {
    const whitespace2 = inferWhitespace(node2, info);
    const children2 = node2.children || [];
    let index2 = -1;
    let items = [];
    if (notRendered(node2)) {
      return items;
    }
    let prefix;
    let suffix;
    if (br(node2)) {
      suffix = "\n";
    } else if (row(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, row)) {
      suffix = "\n";
    } else if (p(node2)) {
      prefix = 2;
      suffix = 2;
    } else if (blockOrCaption(node2)) {
      prefix = 1;
      suffix = 1;
    }
    while (++index2 < children2.length) {
      items = items.concat(
        renderedTextCollection(children2[index2], node2, {
          whitespace: whitespace2,
          breakBefore: index2 ? void 0 : prefix,
          breakAfter: index2 < children2.length - 1 ? br(children2[index2 + 1]) : suffix
        })
      );
    }
    if (cell(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, cell)) {
      items.push("	");
    }
    if (prefix) items.unshift(prefix);
    if (suffix) items.push(suffix);
    return items;
  }
  function collectText(node2, info) {
    const value = String(node2.value);
    const lines = [];
    const result = [];
    let start = 0;
    while (start <= value.length) {
      searchLineFeeds.lastIndex = start;
      const match = searchLineFeeds.exec(value);
      const end = match && "index" in match ? match.index : value.length;
      lines.push(
        // Any sequence of collapsible spaces and tabs immediately preceding or
        // following a segment break is removed.
        trimAndCollapseSpacesAndTabs(
          // [â€¦] ignoring bidi formatting characters (characters with the
          // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
          // they were not there.
          value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
          start === 0 ? info.breakBefore : true,
          end === value.length ? info.breakAfter : true
        )
      );
      start = end + 1;
    }
    let index2 = -1;
    let join2;
    while (++index2 < lines.length) {
      if (lines[index2].charCodeAt(lines[index2].length - 1) === 8203 || index2 < lines.length - 1 && lines[index2 + 1].charCodeAt(0) === 8203) {
        result.push(lines[index2]);
        join2 = void 0;
      } else if (lines[index2]) {
        if (typeof join2 === "number") result.push(join2);
        result.push(lines[index2]);
        join2 = 0;
      } else if (index2 === 0 || index2 === lines.length - 1) {
        result.push(0);
      }
    }
    return result;
  }
  function collectPreText(node2) {
    return [String(node2.value)];
  }
  function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
    const result = [];
    let start = 0;
    let end;
    while (start < value.length) {
      searchTabOrSpaces.lastIndex = start;
      const match = searchTabOrSpaces.exec(value);
      end = match ? match.index : value.length;
      if (!start && !end && match && !breakBefore) {
        result.push("");
      }
      if (start !== end) {
        result.push(value.slice(start, end));
      }
      start = match ? end + match[0].length : end;
    }
    if (start !== end && !breakAfter) {
      result.push("");
    }
    return result.join(" ");
  }
  function inferWhitespace(node2, info) {
    if (node2.type === "element") {
      const properties2 = node2.properties || {};
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return properties2.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return properties2.noWrap ? "nowrap" : info.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
        default:
      }
    }
    return info.whitespace;
  }
  function hidden(node2) {
    return Boolean((node2.properties || {}).hidden);
  }
  function isCell(node2) {
    return node2.tagName === "td" || node2.tagName === "th";
  }
  function closedDialog(node2) {
    return node2.tagName === "dialog" && !(node2.properties || {}).open;
  }
  var searchLineFeeds, searchTabOrSpaces, br, cell, p, row, notRendered, blockOrCaption;
  var init_lib31 = __esm({
    "node_modules/hast-util-to-text/lib/index.js"() {
      init_unist_util_find_after();
      init_hast_util_is_element();
      searchLineFeeds = /\n/g;
      searchTabOrSpaces = /[\t ]+/g;
      br = convertElement("br");
      cell = convertElement(isCell);
      p = convertElement("p");
      row = convertElement("tr");
      notRendered = convertElement([
        // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
        "datalist",
        "head",
        "noembed",
        "noframes",
        "noscript",
        // Act as if we support scripting.
        "rp",
        "script",
        "style",
        "template",
        "title",
        // Hidden attribute.
        hidden,
        // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
        closedDialog
      ]);
      blockOrCaption = convertElement([
        "address",
        // Flow content
        "article",
        // Sections and headings
        "aside",
        // Sections and headings
        "blockquote",
        // Flow content
        "body",
        // Page
        "caption",
        // `table-caption`
        "center",
        // Flow content (legacy)
        "dd",
        // Lists
        "dialog",
        // Flow content
        "dir",
        // Lists (legacy)
        "dl",
        // Lists
        "dt",
        // Lists
        "div",
        // Flow content
        "figure",
        // Flow content
        "figcaption",
        // Flow content
        "footer",
        // Flow content
        "form,",
        // Flow content
        "h1",
        // Sections and headings
        "h2",
        // Sections and headings
        "h3",
        // Sections and headings
        "h4",
        // Sections and headings
        "h5",
        // Sections and headings
        "h6",
        // Sections and headings
        "header",
        // Flow content
        "hgroup",
        // Sections and headings
        "hr",
        // Flow content
        "html",
        // Page
        "legend",
        // Flow content
        "li",
        // Lists (as `display: list-item`)
        "listing",
        // Flow content (legacy)
        "main",
        // Flow content
        "menu",
        // Lists
        "nav",
        // Sections and headings
        "ol",
        // Lists
        "p",
        // Flow content
        "plaintext",
        // Flow content (legacy)
        "pre",
        // Flow content
        "section",
        // Sections and headings
        "ul",
        // Lists
        "xmp"
        // Flow content (legacy)
      ]);
    }
  });

  // node_modules/hast-util-to-text/index.js
  var init_hast_util_to_text = __esm({
    "node_modules/hast-util-to-text/index.js"() {
      init_lib31();
    }
  });

  // node_modules/rehype-katex/lib/index.js
  function rehypeKatex(options) {
    const settings = options || emptyOptions5;
    return function(tree, file) {
      visitParents(tree, "element", function(element6, parents) {
        const classes = Array.isArray(element6.properties.className) ? element6.properties.className : emptyClasses;
        const languageMath = classes.includes("language-math");
        const mathDisplay = classes.includes("math-display");
        const mathInline = classes.includes("math-inline");
        let displayMode = mathDisplay;
        if (!languageMath && !mathDisplay && !mathInline) {
          return;
        }
        let parent = parents[parents.length - 1];
        let scope = element6;
        if (element6.tagName === "code" && languageMath && parent && parent.type === "element" && parent.tagName === "pre") {
          scope = parent;
          parent = parents[parents.length - 2];
          displayMode = true;
        }
        if (!parent) return;
        const value = toText(scope, { whitespace: "pre" });
        let result;
        try {
          result = katex.renderToString(value, {
            ...settings,
            displayMode,
            throwOnError: true
          });
        } catch (error) {
          const cause = (
            /** @type {Error} */
            error
          );
          const ruleId = cause.name.toLowerCase();
          file.message("Could not render math with KaTeX", {
            ancestors: [...parents, element6],
            cause,
            place: element6.position,
            ruleId,
            source: "rehype-katex"
          });
          try {
            result = katex.renderToString(value, {
              ...settings,
              displayMode,
              strict: "ignore",
              throwOnError: false
            });
          } catch {
            result = [
              {
                type: "element",
                tagName: "span",
                properties: {
                  className: ["katex-error"],
                  style: "color:" + (settings.errorColor || "#cc0000"),
                  title: String(error)
                },
                children: [{ type: "text", value }]
              }
            ];
          }
        }
        if (typeof result === "string") {
          const root6 = fromHtmlIsomorphic(result, { fragment: true });
          result = /** @type {Array<ElementContent>} */
          root6.children;
        }
        const index2 = parent.children.indexOf(scope);
        parent.children.splice(index2, 1, ...result);
        return SKIP;
      });
    };
  }
  var emptyOptions5, emptyClasses;
  var init_lib32 = __esm({
    "node_modules/rehype-katex/lib/index.js"() {
      init_browser();
      init_hast_util_to_text();
      init_katex();
      init_unist_util_visit_parents();
      emptyOptions5 = {};
      emptyClasses = [];
    }
  });

  // node_modules/rehype-katex/index.js
  var init_rehype_katex = __esm({
    "node_modules/rehype-katex/index.js"() {
      init_lib32();
    }
  });

  // node_modules/hast-util-sanitize/lib/schema.js
  var aria2, defaultSchema;
  var init_schema2 = __esm({
    "node_modules/hast-util-sanitize/lib/schema.js"() {
      aria2 = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"];
      defaultSchema = {
        ancestors: {
          tbody: ["table"],
          td: ["table"],
          th: ["table"],
          thead: ["table"],
          tfoot: ["table"],
          tr: ["table"]
        },
        attributes: {
          a: [
            ...aria2,
            // Note: these 3 are used by GFM footnotes, they do work on all links.
            "dataFootnoteBackref",
            "dataFootnoteRef",
            ["className", "data-footnote-backref"],
            "href"
          ],
          blockquote: ["cite"],
          // Note: this class is not normally allowed by GH, when manually writing
          // `code` as HTML in markdown, they adds it some other way.
          // We canâ€™t do that, so we have to allow it.
          code: [["className", /^language-./]],
          del: ["cite"],
          div: ["itemScope", "itemType"],
          dl: [...aria2],
          // Note: this is used by GFM footnotes.
          h2: [["className", "sr-only"]],
          img: [...aria2, "longDesc", "src"],
          // Note: `input` is not normally allowed by GH, when manually writing
          // it in markdown, they add it from tasklists some other way.
          // We canâ€™t do that, so we have to allow it.
          input: [
            ["disabled", true],
            ["type", "checkbox"]
          ],
          ins: ["cite"],
          // Note: this class is not normally allowed by GH, when manually writing
          // `li` as HTML in markdown, they adds it some other way.
          // We canâ€™t do that, so we have to allow it.
          li: [["className", "task-list-item"]],
          // Note: this class is not normally allowed by GH, when manually writing
          // `ol` as HTML in markdown, they adds it some other way.
          // We canâ€™t do that, so we have to allow it.
          ol: [...aria2, ["className", "contains-task-list"]],
          q: ["cite"],
          section: ["dataFootnotes", ["className", "footnotes"]],
          source: ["srcSet"],
          summary: [...aria2],
          table: [...aria2],
          // Note: this class is not normally allowed by GH, when manually writing
          // `ol` as HTML in markdown, they adds it some other way.
          // We canâ€™t do that, so we have to allow it.
          ul: [...aria2, ["className", "contains-task-list"]],
          "*": [
            "abbr",
            "accept",
            "acceptCharset",
            "accessKey",
            "action",
            "align",
            "alt",
            "axis",
            "border",
            "cellPadding",
            "cellSpacing",
            "char",
            "charOff",
            "charSet",
            "checked",
            "clear",
            "colSpan",
            "color",
            "cols",
            "compact",
            "coords",
            "dateTime",
            "dir",
            // Note: `disabled` is technically allowed on all elements by GH.
            // But it is useless on everything except `input`.
            // Because `input`s are normally not allowed, but we allow them for
            // checkboxes due to tasklists, we allow `disabled` only there.
            "encType",
            "frame",
            "hSpace",
            "headers",
            "height",
            "hrefLang",
            "htmlFor",
            "id",
            "isMap",
            "itemProp",
            "label",
            "lang",
            "maxLength",
            "media",
            "method",
            "multiple",
            "name",
            "noHref",
            "noShade",
            "noWrap",
            "open",
            "prompt",
            "readOnly",
            "rev",
            "rowSpan",
            "rows",
            "rules",
            "scope",
            "selected",
            "shape",
            "size",
            "span",
            "start",
            "summary",
            "tabIndex",
            "title",
            "useMap",
            "vAlign",
            "value",
            "width"
          ]
        },
        clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
        clobberPrefix: "user-content-",
        protocols: {
          cite: ["http", "https"],
          href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
          longDesc: ["http", "https"],
          src: ["http", "https"]
        },
        required: {
          input: { disabled: true, type: "checkbox" }
        },
        strip: ["script"],
        tagNames: [
          "a",
          "b",
          "blockquote",
          "br",
          "code",
          "dd",
          "del",
          "details",
          "div",
          "dl",
          "dt",
          "em",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hr",
          "i",
          "img",
          // Note: `input` is not normally allowed by GH, when manually writing
          // it in markdown, they add it from tasklists some other way.
          // We canâ€™t do that, so we have to allow it.
          "input",
          "ins",
          "kbd",
          "li",
          "ol",
          "p",
          "picture",
          "pre",
          "q",
          "rp",
          "rt",
          "ruby",
          "s",
          "samp",
          "section",
          "source",
          "span",
          "strike",
          "strong",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr",
          "tt",
          "ul",
          "var"
        ]
      };
    }
  });

  // node_modules/hast-util-sanitize/lib/index.js
  function sanitize(node2, options) {
    let result = { type: "root", children: [] };
    const state = {
      schema: options ? { ...defaultSchema, ...options } : defaultSchema,
      stack: []
    };
    const replace2 = transform2(state, node2);
    if (replace2) {
      if (Array.isArray(replace2)) {
        if (replace2.length === 1) {
          result = replace2[0];
        } else {
          result.children = replace2;
        }
      } else {
        result = replace2;
      }
    }
    return result;
  }
  function transform2(state, node2) {
    if (node2 && typeof node2 === "object") {
      const unsafe = (
        /** @type {Record<string, Readonly<unknown>>} */
        node2
      );
      const type = typeof unsafe.type === "string" ? unsafe.type : "";
      switch (type) {
        case "comment": {
          return comment2(state, unsafe);
        }
        case "doctype": {
          return doctype2(state, unsafe);
        }
        case "element": {
          return element4(state, unsafe);
        }
        case "root": {
          return root4(state, unsafe);
        }
        case "text": {
          return text8(state, unsafe);
        }
        default:
      }
    }
  }
  function comment2(state, unsafe) {
    if (state.schema.allowComments) {
      const result = typeof unsafe.value === "string" ? unsafe.value : "";
      const index2 = result.indexOf("-->");
      const value = index2 < 0 ? result : result.slice(0, index2);
      const node2 = { type: "comment", value };
      patch2(node2, unsafe);
      return node2;
    }
  }
  function doctype2(state, unsafe) {
    if (state.schema.allowDoctypes) {
      const node2 = { type: "doctype" };
      patch2(node2, unsafe);
      return node2;
    }
  }
  function element4(state, unsafe) {
    const name = typeof unsafe.tagName === "string" ? unsafe.tagName : "";
    state.stack.push(name);
    const content3 = (
      /** @type {Array<ElementContent>} */
      children(state, unsafe.children)
    );
    const properties_ = properties(state, unsafe.properties);
    state.stack.pop();
    let safeElement = false;
    if (name && name !== "*" && (!state.schema.tagNames || state.schema.tagNames.includes(name))) {
      safeElement = true;
      if (state.schema.ancestors && own5.call(state.schema.ancestors, name)) {
        const ancestors = state.schema.ancestors[name];
        let index2 = -1;
        safeElement = false;
        while (++index2 < ancestors.length) {
          if (state.stack.includes(ancestors[index2])) {
            safeElement = true;
          }
        }
      }
    }
    if (!safeElement) {
      return state.schema.strip && !state.schema.strip.includes(name) ? content3 : void 0;
    }
    const node2 = {
      type: "element",
      tagName: name,
      properties: properties_,
      children: content3
    };
    patch2(node2, unsafe);
    return node2;
  }
  function root4(state, unsafe) {
    const content3 = (
      /** @type {Array<RootContent>} */
      children(state, unsafe.children)
    );
    const node2 = { type: "root", children: content3 };
    patch2(node2, unsafe);
    return node2;
  }
  function text8(_, unsafe) {
    const value = typeof unsafe.value === "string" ? unsafe.value : "";
    const node2 = { type: "text", value };
    patch2(node2, unsafe);
    return node2;
  }
  function children(state, children2) {
    const results = [];
    if (Array.isArray(children2)) {
      const childrenUnknown = (
        /** @type {Array<Readonly<unknown>>} */
        children2
      );
      let index2 = -1;
      while (++index2 < childrenUnknown.length) {
        const value = transform2(state, childrenUnknown[index2]);
        if (value) {
          if (Array.isArray(value)) {
            results.push(...value);
          } else {
            results.push(value);
          }
        }
      }
    }
    return results;
  }
  function properties(state, properties2) {
    const tagName = state.stack[state.stack.length - 1];
    const attributes = state.schema.attributes;
    const required = state.schema.required;
    const specific = attributes && own5.call(attributes, tagName) ? attributes[tagName] : void 0;
    const defaults = attributes && own5.call(attributes, "*") ? attributes["*"] : void 0;
    const properties_ = (
      /** @type {Readonly<Record<string, Readonly<unknown>>>} */
      properties2 && typeof properties2 === "object" ? properties2 : {}
    );
    const result = {};
    let key2;
    for (key2 in properties_) {
      if (own5.call(properties_, key2)) {
        const unsafe = properties_[key2];
        let safe = propertyValue(
          state,
          findDefinition(specific, key2),
          key2,
          unsafe
        );
        if (safe === null || safe === void 0) {
          safe = propertyValue(state, findDefinition(defaults, key2), key2, unsafe);
        }
        if (safe !== null && safe !== void 0) {
          result[key2] = safe;
        }
      }
    }
    if (required && own5.call(required, tagName)) {
      const properties3 = required[tagName];
      for (key2 in properties3) {
        if (own5.call(properties3, key2) && !own5.call(result, key2)) {
          result[key2] = properties3[key2];
        }
      }
    }
    return result;
  }
  function propertyValue(state, definition3, key2, value) {
    return definition3 ? Array.isArray(value) ? propertyValueMany(state, definition3, key2, value) : propertyValuePrimitive(state, definition3, key2, value) : void 0;
  }
  function propertyValueMany(state, definition3, key2, values) {
    let index2 = -1;
    const result = [];
    while (++index2 < values.length) {
      const value = propertyValuePrimitive(state, definition3, key2, values[index2]);
      if (typeof value === "number" || typeof value === "string") {
        result.push(value);
      }
    }
    return result;
  }
  function propertyValuePrimitive(state, definition3, key2, value) {
    if (typeof value !== "boolean" && typeof value !== "number" && typeof value !== "string") {
      return;
    }
    if (!safeProtocol(state, key2, value)) {
      return;
    }
    if (typeof definition3 === "object" && definition3.length > 1) {
      let ok3 = false;
      let index2 = 0;
      while (++index2 < definition3.length) {
        const allowed = definition3[index2];
        if (allowed && typeof allowed === "object" && "flags" in allowed) {
          if (allowed.test(String(value))) {
            ok3 = true;
            break;
          }
        } else if (allowed === value) {
          ok3 = true;
          break;
        }
      }
      if (!ok3) return;
    }
    return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key2) ? state.schema.clobberPrefix + value : value;
  }
  function safeProtocol(state, key2, value) {
    const protocols = state.schema.protocols && own5.call(state.schema.protocols, key2) ? state.schema.protocols[key2] : void 0;
    if (!protocols || protocols.length === 0) {
      return true;
    }
    const url = String(value);
    const colon = url.indexOf(":");
    const questionMark = url.indexOf("?");
    const numberSign = url.indexOf("#");
    const slash = url.indexOf("/");
    if (colon < 0 || // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {
      return true;
    }
    let index2 = -1;
    while (++index2 < protocols.length) {
      const protocol = protocols[index2];
      if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {
        return true;
      }
    }
    return false;
  }
  function patch2(node2, unsafe) {
    const cleanPosition = position2(
      // @ts-expect-error: looks like a node.
      unsafe
    );
    if (unsafe.data) {
      node2.data = esm_default(unsafe.data);
    }
    if (cleanPosition) node2.position = cleanPosition;
  }
  function findDefinition(definitions, key2) {
    let dataDefault;
    let index2 = -1;
    if (definitions) {
      while (++index2 < definitions.length) {
        const entry = definitions[index2];
        const name = typeof entry === "string" ? entry : entry[0];
        if (name === key2) {
          return entry;
        }
        if (name === "data*") dataDefault = entry;
      }
    }
    if (key2.length > 4 && key2.slice(0, 4).toLowerCase() === "data") {
      return dataDefault;
    }
  }
  var own5;
  var init_lib33 = __esm({
    "node_modules/hast-util-sanitize/lib/index.js"() {
      init_esm();
      init_unist_util_position();
      init_schema2();
      own5 = {}.hasOwnProperty;
    }
  });

  // node_modules/hast-util-sanitize/index.js
  var init_hast_util_sanitize = __esm({
    "node_modules/hast-util-sanitize/index.js"() {
      init_lib33();
      init_schema2();
    }
  });

  // node_modules/rehype-sanitize/lib/index.js
  function rehypeSanitize(options) {
    return function(tree) {
      const result = (
        /** @type {Root} */
        sanitize(tree, options)
      );
      return result;
    };
  }
  var init_lib34 = __esm({
    "node_modules/rehype-sanitize/lib/index.js"() {
      init_hast_util_sanitize();
    }
  });

  // node_modules/rehype-sanitize/index.js
  var init_rehype_sanitize = __esm({
    "node_modules/rehype-sanitize/index.js"() {
      init_hast_util_sanitize();
      init_lib34();
    }
  });

  // node_modules/html-void-elements/index.js
  var htmlVoidElements;
  var init_html_void_elements = __esm({
    "node_modules/html-void-elements/index.js"() {
      htmlVoidElements = [
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "image",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
    }
  });

  // node_modules/stringify-entities/lib/core.js
  function core(value, options) {
    value = value.replace(
      options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
      basic
    );
    if (options.subset || options.escapeOnly) {
      return value;
    }
    return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
    function surrogate(pair, index2, all4) {
      return options.format(
        (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
        all4.charCodeAt(index2 + 2),
        options
      );
    }
    function basic(character, index2, all4) {
      return options.format(
        character.charCodeAt(0),
        all4.charCodeAt(index2 + 1),
        options
      );
    }
  }
  function charactersToExpressionCached(subset) {
    let cached = subsetToRegexCache.get(subset);
    if (!cached) {
      cached = charactersToExpression(subset);
      subsetToRegexCache.set(subset, cached);
    }
    return cached;
  }
  function charactersToExpression(subset) {
    const groups = [];
    let index2 = -1;
    while (++index2 < subset.length) {
      groups.push(subset[index2].replace(regexEscapeRegex, "\\$&"));
    }
    return new RegExp("(?:" + groups.join("|") + ")", "g");
  }
  var defaultSubsetRegex, surrogatePairsRegex, controlCharactersRegex, regexEscapeRegex, subsetToRegexCache;
  var init_core = __esm({
    "node_modules/stringify-entities/lib/core.js"() {
      defaultSubsetRegex = /["&'<>`]/g;
      surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      controlCharactersRegex = // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
      /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
      subsetToRegexCache = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/stringify-entities/lib/util/to-hexadecimal.js
  function toHexadecimal(code4, next, omit) {
    const value = "&#x" + code4.toString(16).toUpperCase();
    return omit && next && !hexadecimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
  }
  var hexadecimalRegex;
  var init_to_hexadecimal = __esm({
    "node_modules/stringify-entities/lib/util/to-hexadecimal.js"() {
      hexadecimalRegex = /[\dA-Fa-f]/;
    }
  });

  // node_modules/stringify-entities/lib/util/to-decimal.js
  function toDecimal(code4, next, omit) {
    const value = "&#" + String(code4);
    return omit && next && !decimalRegex.test(String.fromCharCode(next)) ? value : value + ";";
  }
  var decimalRegex;
  var init_to_decimal = __esm({
    "node_modules/stringify-entities/lib/util/to-decimal.js"() {
      decimalRegex = /\d/;
    }
  });

  // node_modules/character-entities-legacy/index.js
  var characterEntitiesLegacy;
  var init_character_entities_legacy = __esm({
    "node_modules/character-entities-legacy/index.js"() {
      characterEntitiesLegacy = [
        "AElig",
        "AMP",
        "Aacute",
        "Acirc",
        "Agrave",
        "Aring",
        "Atilde",
        "Auml",
        "COPY",
        "Ccedil",
        "ETH",
        "Eacute",
        "Ecirc",
        "Egrave",
        "Euml",
        "GT",
        "Iacute",
        "Icirc",
        "Igrave",
        "Iuml",
        "LT",
        "Ntilde",
        "Oacute",
        "Ocirc",
        "Ograve",
        "Oslash",
        "Otilde",
        "Ouml",
        "QUOT",
        "REG",
        "THORN",
        "Uacute",
        "Ucirc",
        "Ugrave",
        "Uuml",
        "Yacute",
        "aacute",
        "acirc",
        "acute",
        "aelig",
        "agrave",
        "amp",
        "aring",
        "atilde",
        "auml",
        "brvbar",
        "ccedil",
        "cedil",
        "cent",
        "copy",
        "curren",
        "deg",
        "divide",
        "eacute",
        "ecirc",
        "egrave",
        "eth",
        "euml",
        "frac12",
        "frac14",
        "frac34",
        "gt",
        "iacute",
        "icirc",
        "iexcl",
        "igrave",
        "iquest",
        "iuml",
        "laquo",
        "lt",
        "macr",
        "micro",
        "middot",
        "nbsp",
        "not",
        "ntilde",
        "oacute",
        "ocirc",
        "ograve",
        "ordf",
        "ordm",
        "oslash",
        "otilde",
        "ouml",
        "para",
        "plusmn",
        "pound",
        "quot",
        "raquo",
        "reg",
        "sect",
        "shy",
        "sup1",
        "sup2",
        "sup3",
        "szlig",
        "thorn",
        "times",
        "uacute",
        "ucirc",
        "ugrave",
        "uml",
        "uuml",
        "yacute",
        "yen",
        "yuml"
      ];
    }
  });

  // node_modules/character-entities-html4/index.js
  var characterEntitiesHtml4;
  var init_character_entities_html4 = __esm({
    "node_modules/character-entities-html4/index.js"() {
      characterEntitiesHtml4 = {
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        fnof: "\u0192",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        bull: "\u2022",
        hellip: "\u2026",
        prime: "\u2032",
        Prime: "\u2033",
        oline: "\u203E",
        frasl: "\u2044",
        weierp: "\u2118",
        image: "\u2111",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666",
        quot: '"',
        amp: "&",
        lt: "<",
        gt: ">",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        circ: "\u02C6",
        tilde: "\u02DC",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        permil: "\u2030",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        euro: "\u20AC"
      };
    }
  });

  // node_modules/stringify-entities/lib/constant/dangerous.js
  var dangerous;
  var init_dangerous = __esm({
    "node_modules/stringify-entities/lib/constant/dangerous.js"() {
      dangerous = [
        "cent",
        "copy",
        "divide",
        "gt",
        "lt",
        "not",
        "para",
        "times"
      ];
    }
  });

  // node_modules/stringify-entities/lib/util/to-named.js
  function toNamed(code4, next, omit, attribute) {
    const character = String.fromCharCode(code4);
    if (own6.call(characters, character)) {
      const name = characters[character];
      const value = "&" + name;
      if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && notAlphanumericRegex.test(String.fromCharCode(next)))) {
        return value;
      }
      return value + ";";
    }
    return "";
  }
  var own6, characters, key, notAlphanumericRegex;
  var init_to_named = __esm({
    "node_modules/stringify-entities/lib/util/to-named.js"() {
      init_character_entities_legacy();
      init_character_entities_html4();
      init_dangerous();
      own6 = {}.hasOwnProperty;
      characters = {};
      for (key in characterEntitiesHtml4) {
        if (own6.call(characterEntitiesHtml4, key)) {
          characters[characterEntitiesHtml4[key]] = key;
        }
      }
      notAlphanumericRegex = /[^\dA-Za-z]/;
    }
  });

  // node_modules/stringify-entities/lib/util/format-smart.js
  function formatSmart(code4, next, options) {
    let numeric = toHexadecimal(code4, next, options.omitOptionalSemicolons);
    let named;
    if (options.useNamedReferences || options.useShortestReferences) {
      named = toNamed(
        code4,
        next,
        options.omitOptionalSemicolons,
        options.attribute
      );
    }
    if ((options.useShortestReferences || !named) && options.useShortestReferences) {
      const decimal = toDecimal(code4, next, options.omitOptionalSemicolons);
      if (decimal.length < numeric.length) {
        numeric = decimal;
      }
    }
    return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
  }
  var init_format_smart = __esm({
    "node_modules/stringify-entities/lib/util/format-smart.js"() {
      init_to_hexadecimal();
      init_to_decimal();
      init_to_named();
    }
  });

  // node_modules/stringify-entities/lib/index.js
  function stringifyEntities(value, options) {
    return core(value, Object.assign({ format: formatSmart }, options));
  }
  var init_lib35 = __esm({
    "node_modules/stringify-entities/lib/index.js"() {
      init_core();
      init_format_smart();
    }
  });

  // node_modules/stringify-entities/index.js
  var init_stringify_entities = __esm({
    "node_modules/stringify-entities/index.js"() {
      init_lib35();
    }
  });

  // node_modules/hast-util-to-html/lib/handle/comment.js
  function comment3(node2, _1, _2, state) {
    return state.settings.bogusComments ? "<?" + stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: bogusCommentEntitySubset
      })
    ) + ">" : "<!--" + node2.value.replace(htmlCommentRegex, encode) + "-->";
    function encode($0) {
      return stringifyEntities(
        $0,
        Object.assign({}, state.settings.characterReferences, {
          subset: commentEntitySubset
        })
      );
    }
  }
  var htmlCommentRegex, bogusCommentEntitySubset, commentEntitySubset;
  var init_comment = __esm({
    "node_modules/hast-util-to-html/lib/handle/comment.js"() {
      init_stringify_entities();
      htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
      bogusCommentEntitySubset = [">"];
      commentEntitySubset = ["<", ">"];
    }
  });

  // node_modules/hast-util-to-html/lib/handle/doctype.js
  function doctype3(_1, _2, _3, state) {
    return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
  }
  var init_doctype = __esm({
    "node_modules/hast-util-to-html/lib/handle/doctype.js"() {
    }
  });

  // node_modules/hast-util-whitespace/lib/index.js
  function whitespace(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty2(thing.value) : false : empty2(thing);
  }
  function empty2(value) {
    return value.replace(re, "") === "";
  }
  var re;
  var init_lib36 = __esm({
    "node_modules/hast-util-whitespace/lib/index.js"() {
      re = /[ \t\n\f\r]/g;
    }
  });

  // node_modules/hast-util-whitespace/index.js
  var init_hast_util_whitespace = __esm({
    "node_modules/hast-util-whitespace/index.js"() {
      init_lib36();
    }
  });

  // node_modules/hast-util-to-html/lib/omission/util/siblings.js
  function siblings(increment2) {
    return sibling;
    function sibling(parent, index2, includeWhitespace) {
      const siblings2 = parent ? parent.children : emptyChildren;
      let offset = (index2 || 0) + increment2;
      let next = siblings2[offset];
      if (!includeWhitespace) {
        while (next && whitespace(next)) {
          offset += increment2;
          next = siblings2[offset];
        }
      }
      return next;
    }
  }
  var siblingAfter, siblingBefore, emptyChildren;
  var init_siblings = __esm({
    "node_modules/hast-util-to-html/lib/omission/util/siblings.js"() {
      init_hast_util_whitespace();
      siblingAfter = siblings(1);
      siblingBefore = siblings(-1);
      emptyChildren = [];
    }
  });

  // node_modules/hast-util-to-html/lib/omission/omission.js
  function omission(handlers2) {
    return omit;
    function omit(node2, index2, parent) {
      return own7.call(handlers2, node2.tagName) && handlers2[node2.tagName](node2, index2, parent);
    }
  }
  var own7;
  var init_omission = __esm({
    "node_modules/hast-util-to-html/lib/omission/omission.js"() {
      own7 = {}.hasOwnProperty;
    }
  });

  // node_modules/hast-util-to-html/lib/omission/closing.js
  function headOrColgroupOrCaption(_, index2, parent) {
    const next = siblingAfter(parent, index2, true);
    return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
  }
  function html5(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function body(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type !== "comment";
  }
  function p2(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || // Confusing parent.
    !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
  }
  function li(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "li";
  }
  function dt(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return Boolean(
      next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd")
    );
  }
  function dd(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
  }
  function rubyElement(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
  }
  function optgroup(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "optgroup";
  }
  function option(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
  }
  function thead(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return Boolean(
      next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot")
    );
  }
  function tbody(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
  }
  function tfoot(_, index2, parent) {
    return !siblingAfter(parent, index2);
  }
  function tr(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && next.tagName === "tr";
  }
  function cells(_, index2, parent) {
    const next = siblingAfter(parent, index2);
    return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
  }
  var closing;
  var init_closing = __esm({
    "node_modules/hast-util-to-html/lib/omission/closing.js"() {
      init_hast_util_whitespace();
      init_siblings();
      init_omission();
      closing = omission({
        body,
        caption: headOrColgroupOrCaption,
        colgroup: headOrColgroupOrCaption,
        dd,
        dt,
        head: headOrColgroupOrCaption,
        html: html5,
        li,
        optgroup,
        option,
        p: p2,
        rp: rubyElement,
        rt: rubyElement,
        tbody,
        td: cells,
        tfoot,
        th: cells,
        thead,
        tr
      });
    }
  });

  // node_modules/hast-util-to-html/lib/omission/opening.js
  function html6(node2) {
    const head2 = siblingAfter(node2, -1);
    return !head2 || head2.type !== "comment";
  }
  function head(node2) {
    const seen = /* @__PURE__ */ new Set();
    for (const child2 of node2.children) {
      if (child2.type === "element" && (child2.tagName === "base" || child2.tagName === "title")) {
        if (seen.has(child2.tagName)) return false;
        seen.add(child2.tagName);
      }
    }
    const child = node2.children[0];
    return !child || child.type === "element";
  }
  function body2(node2) {
    const head2 = siblingAfter(node2, -1, true);
    return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
  }
  function colgroup(node2, index2, parent) {
    const previous4 = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1, true);
    if (parent && previous4 && previous4.type === "element" && previous4.tagName === "colgroup" && closing(previous4, parent.children.indexOf(previous4), parent)) {
      return false;
    }
    return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
  }
  function tbody2(node2, index2, parent) {
    const previous4 = siblingBefore(parent, index2);
    const head2 = siblingAfter(node2, -1);
    if (parent && previous4 && previous4.type === "element" && (previous4.tagName === "thead" || previous4.tagName === "tbody") && closing(previous4, parent.children.indexOf(previous4), parent)) {
      return false;
    }
    return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
  }
  var opening;
  var init_opening = __esm({
    "node_modules/hast-util-to-html/lib/omission/opening.js"() {
      init_hast_util_whitespace();
      init_siblings();
      init_closing();
      init_omission();
      opening = omission({
        body: body2,
        colgroup,
        head,
        html: html6,
        tbody: tbody2
      });
    }
  });

  // node_modules/hast-util-to-html/lib/handle/element.js
  function element5(node2, index2, parent, state) {
    const schema = state.schema;
    const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
    let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
    const parts = [];
    let last;
    if (schema.space === "html" && node2.tagName === "svg") {
      state.schema = svg2;
    }
    const attributes = serializeAttributes(state, node2.properties);
    const content3 = state.all(
      schema.space === "html" && node2.tagName === "template" ? node2.content : node2
    );
    state.schema = schema;
    if (content3) selfClosing = false;
    if (attributes || !omit || !opening(node2, index2, parent)) {
      parts.push("<", node2.tagName, attributes ? " " + attributes : "");
      if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
        last = attributes.charAt(attributes.length - 1);
        if (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") {
          parts.push(" ");
        }
        parts.push("/");
      }
      parts.push(">");
    }
    parts.push(content3);
    if (!selfClosing && (!omit || !closing(node2, index2, parent))) {
      parts.push("</" + node2.tagName + ">");
    }
    return parts.join("");
  }
  function serializeAttributes(state, properties2) {
    const values = [];
    let index2 = -1;
    let key2;
    if (properties2) {
      for (key2 in properties2) {
        if (properties2[key2] !== null && properties2[key2] !== void 0) {
          const value = serializeAttribute(state, key2, properties2[key2]);
          if (value) values.push(value);
        }
      }
    }
    while (++index2 < values.length) {
      const last = state.settings.tightAttributes ? values[index2].charAt(values[index2].length - 1) : void 0;
      if (index2 !== values.length - 1 && last !== '"' && last !== "'") {
        values[index2] += " ";
      }
    }
    return values.join("");
  }
  function serializeAttribute(state, key2, value) {
    const info = find(state.schema, key2);
    const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
    const y = state.settings.allowDangerousCharacters ? 0 : 1;
    let quote = state.quote;
    let result;
    if (info.overloadedBoolean && (value === info.attribute || value === "")) {
      value = true;
    } else if ((info.boolean || info.overloadedBoolean) && (typeof value !== "string" || value === info.attribute || value === "")) {
      value = Boolean(value);
    }
    if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
      return "";
    }
    const name = stringifyEntities(
      info.attribute,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: constants.name[x][y]
      })
    );
    if (value === true) return name;
    value = Array.isArray(value) ? (info.commaSeparated ? stringify : stringify2)(value, {
      padLeft: !state.settings.tightCommaSeparatedLists
    }) : String(value);
    if (state.settings.collapseEmptyAttributes && !value) return name;
    if (state.settings.preferUnquoted) {
      result = stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          attribute: true,
          subset: constants.unquoted[x][y]
        })
      );
    }
    if (result !== value) {
      if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
        quote = state.alternative;
      }
      result = quote + stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          // Always encode without parse errors in non-HTML.
          subset: (quote === "'" ? constants.single : constants.double)[x][y],
          attribute: true
        })
      ) + quote;
    }
    return name + (result ? "=" + result : result);
  }
  var constants;
  var init_element = __esm({
    "node_modules/hast-util-to-html/lib/handle/element.js"() {
      init_ccount();
      init_comma_separated_tokens();
      init_property_information();
      init_space_separated_tokens();
      init_stringify_entities();
      init_closing();
      init_opening();
      constants = {
        // See: <https://html.spec.whatwg.org/#attribute-name-state>.
        name: [
          ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
          [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
        unquoted: [
          ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
          ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
        single: [
          ["&'".split(""), "\"&'`".split("")],
          ["\0&'".split(""), "\0\"&'`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
        double: [
          ['"&'.split(""), "\"&'`".split("")],
          ['\0"&'.split(""), "\0\"&'`".split("")]
        ]
      };
    }
  });

  // node_modules/hast-util-to-html/lib/handle/text.js
  function text9(node2, _, parent, state) {
    return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: textEntitySubset
      })
    );
  }
  var textEntitySubset;
  var init_text4 = __esm({
    "node_modules/hast-util-to-html/lib/handle/text.js"() {
      init_stringify_entities();
      textEntitySubset = ["<", "&"];
    }
  });

  // node_modules/hast-util-to-html/lib/handle/raw.js
  function raw(node2, index2, parent, state) {
    return state.settings.allowDangerousHtml ? node2.value : text9(node2, index2, parent, state);
  }
  var init_raw = __esm({
    "node_modules/hast-util-to-html/lib/handle/raw.js"() {
      init_text4();
    }
  });

  // node_modules/hast-util-to-html/lib/handle/root.js
  function root5(node2, _1, _2, state) {
    return state.all(node2);
  }
  var init_root3 = __esm({
    "node_modules/hast-util-to-html/lib/handle/root.js"() {
    }
  });

  // node_modules/hast-util-to-html/lib/handle/index.js
  function invalid(node2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  function unknown(node_) {
    const node2 = (
      /** @type {Nodes} */
      node_
    );
    throw new Error("Cannot compile unknown node `" + node2.type + "`");
  }
  var handle2;
  var init_handle2 = __esm({
    "node_modules/hast-util-to-html/lib/handle/index.js"() {
      init_zwitch();
      init_comment();
      init_doctype();
      init_element();
      init_raw();
      init_root3();
      init_text4();
      handle2 = zwitch("type", {
        invalid,
        unknown,
        handlers: { comment: comment3, doctype: doctype3, element: element5, raw, root: root5, text: text9 }
      });
    }
  });

  // node_modules/hast-util-to-html/lib/index.js
  function toHtml(tree, options) {
    const options_ = options || emptyOptions6;
    const quote = options_.quote || '"';
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
      throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
    }
    const state = {
      one: one3,
      all: all3,
      settings: {
        omitOptionalTags: options_.omitOptionalTags || false,
        allowParseErrors: options_.allowParseErrors || false,
        allowDangerousCharacters: options_.allowDangerousCharacters || false,
        quoteSmart: options_.quoteSmart || false,
        preferUnquoted: options_.preferUnquoted || false,
        tightAttributes: options_.tightAttributes || false,
        upperDoctype: options_.upperDoctype || false,
        tightDoctype: options_.tightDoctype || false,
        bogusComments: options_.bogusComments || false,
        tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
        tightSelfClosing: options_.tightSelfClosing || false,
        collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
        allowDangerousHtml: options_.allowDangerousHtml || false,
        voids: options_.voids || htmlVoidElements,
        characterReferences: options_.characterReferences || emptyCharacterReferences,
        closeSelfClosing: options_.closeSelfClosing || false,
        closeEmptyElements: options_.closeEmptyElements || false
      },
      schema: options_.space === "svg" ? svg2 : html4,
      quote,
      alternative
    };
    return state.one(
      Array.isArray(tree) ? { type: "root", children: tree } : tree,
      void 0,
      void 0
    );
  }
  function one3(node2, index2, parent) {
    return handle2(node2, index2, parent, this);
  }
  function all3(parent) {
    const results = [];
    const children2 = parent && parent.children || emptyChildren2;
    let index2 = -1;
    while (++index2 < children2.length) {
      results[index2] = this.one(children2[index2], index2, parent);
    }
    return results.join("");
  }
  var emptyOptions6, emptyCharacterReferences, emptyChildren2;
  var init_lib37 = __esm({
    "node_modules/hast-util-to-html/lib/index.js"() {
      init_html_void_elements();
      init_property_information();
      init_handle2();
      emptyOptions6 = {};
      emptyCharacterReferences = {};
      emptyChildren2 = [];
    }
  });

  // node_modules/hast-util-to-html/index.js
  var init_hast_util_to_html = __esm({
    "node_modules/hast-util-to-html/index.js"() {
      init_lib37();
    }
  });

  // node_modules/rehype-stringify/lib/index.js
  function rehypeStringify(options) {
    const self2 = this;
    const settings = { ...self2.data("settings"), ...options };
    self2.compiler = compiler2;
    function compiler2(tree) {
      return toHtml(tree, settings);
    }
  }
  var init_lib38 = __esm({
    "node_modules/rehype-stringify/lib/index.js"() {
      init_hast_util_to_html();
    }
  });

  // node_modules/rehype-stringify/index.js
  var init_rehype_stringify = __esm({
    "node_modules/rehype-stringify/index.js"() {
      init_lib38();
    }
  });

  // sidepanel.js
  var require_sidepanel = __commonJS({
    "sidepanel.js"() {
      init_unified();
      init_remark_parse();
      init_remark_gfm();
      init_remark_math();
      init_remark_rehype();
      init_rehype_katex();
      init_rehype_sanitize();
      init_rehype_stringify();
      var apiKeyInput = document.getElementById("apiKey");
      var saveApiKeyButton = document.getElementById("saveApiKey");
      var apiKeyStatus = document.getElementById("apiKeyStatus");
      var apiKeyDetails = document.getElementById("apiKeyDetails");
      var toggleApiKeyVisibilityButton = document.getElementById("toggleApiKeyVisibility");
      var apiKeyToggleIndicator = document.getElementById("apiKeyToggleIndicator");
      var chatbox = document.getElementById("chatbox");
      var messageInput = document.getElementById("messageInput");
      var sendMessageButton = document.getElementById("sendMessage");
      var stopGeneratingButton = document.getElementById("stopGenerating");
      var loadingIndicator = document.getElementById("loadingIndicator");
      var errorDisplay = document.getElementById("errorDisplay");
      var isStreaming = false;
      var currentGeminiMessageDiv = null;
      var currentOutputText = "";
      var sidePanelInstanceId = crypto.randomUUID();
      console.log("Side Panel Instance ID:", sidePanelInstanceId);
      var processor = unified().use(remarkParse).use(remarkGfm).use(remarkMath).use(remarkRehype).use(rehypeKatex).use(rehypeSanitize, {
        // Sanitize the resulting HTML
        ...defaultSchema,
        // Start with the default safe schema
        // Allow classes needed by KaTeX
        clobberPrefix: "",
        // Don't prefix IDs/names
        attributes: {
          ...defaultSchema.attributes,
          // Allow KaTeX classes on spans, divs, etc.
          span: [...defaultSchema.attributes?.span || [], ["className", /^katex/]],
          div: [...defaultSchema.attributes?.div || [], ["className", "math"]],
          // Allow math display divs
          "*": [...defaultSchema.attributes?.["*"] || [], "aria-hidden"]
          // Allow aria-hidden used by KaTeX
        }
      }).use(rehypeStringify);
      function toggleApiKeySection(show) {
        if (show) {
          apiKeyDetails.classList.remove("hidden");
          apiKeyToggleIndicator.classList.add("rotate-180");
        } else {
          apiKeyDetails.classList.add("hidden");
          apiKeyToggleIndicator.classList.remove("rotate-180");
        }
      }
      document.addEventListener("DOMContentLoaded", () => {
        messageInput.disabled = false;
        sendMessageButton.disabled = false;
        messageInput.focus();
        loadingIndicator.style.display = "block";
        chrome.runtime.sendMessage({ action: "getApiKey" }, (response) => {
          loadingIndicator.style.display = "none";
          if (response && response.apiKey) {
            apiKeyInput.value = response.apiKey;
            apiKeyStatus.textContent = "API Key loaded.";
            apiKeyStatus.style.color = "green";
            toggleApiKeySection(false);
          } else {
            apiKeyStatus.textContent = "API Key not set.";
            apiKeyStatus.style.color = "orange";
            toggleApiKeySection(true);
            if (response?.error) {
              console.error("Error loading API key:", response.error);
              displayError(`Error loading API key: ${response.error}`);
            }
          }
        });
        updateStreamingUI(false);
        messageInput.addEventListener("input", () => {
          messageInput.style.height = "auto";
          messageInput.style.height = messageInput.scrollHeight + "px";
        });
      });
      async function addMessage(text10, sender, isComplete = true) {
        const isGemini = sender === "gemini";
        let contentHtml = "";
        if (isGemini) {
          currentOutputText = !isComplete && currentGeminiMessageDiv ? currentOutputText + text10 : text10;
          try {
            const file = await processor.process(currentOutputText);
            contentHtml = String(file);
          } catch (error) {
            console.error("Markdown processing error:", error);
            contentHtml = `<p>Error rendering content.</p><pre><code>${currentOutputText.replace(/</g, "<").replace(/>/g, ">")}</code></pre>`;
          }
        } else {
          contentHtml = text10;
        }
        if (isGemini && !isComplete && currentGeminiMessageDiv) {
          currentGeminiMessageDiv.querySelector(".message-content").innerHTML = contentHtml;
        } else {
          const messageDiv = document.createElement("div");
          const contentSpan = document.createElement("span");
          contentSpan.classList.add("message-content");
          if (isGemini) {
            contentSpan.innerHTML = contentHtml;
          } else {
            contentSpan.textContent = contentHtml;
          }
          if (sender === "user") {
            messageDiv.classList.add("bg-gray-100", "p-3", "rounded-xl", "max-w-[85%]", "self-end", "break-words", "text-foreground");
            messageDiv.appendChild(contentSpan);
          } else {
            messageDiv.classList.add("bg-transparent", "p-3", "rounded-xl", "max-w-[85%]", "self-start", "relative", "group", "break-words", "text-foreground");
            messageDiv.appendChild(contentSpan);
            if (isComplete) {
              addCopyButton(messageDiv, text10);
              currentGeminiMessageDiv = null;
              currentOutputText = "";
            } else {
              currentGeminiMessageDiv = messageDiv;
            }
          }
          chatbox.appendChild(messageDiv);
        }
        chatbox.scrollTop = chatbox.scrollHeight;
        return currentGeminiMessageDiv;
      }
      function addCopyButton(messageDiv, textToCopy) {
        if (!messageDiv || messageDiv.querySelector(".copy-button")) return;
        const copyButton = document.createElement("button");
        copyButton.textContent = "Copy";
        copyButton.classList.add(
          "copy-button",
          "absolute",
          "bottom-1",
          "right-1",
          "bg-muted",
          "text-muted-foreground",
          "text-xs",
          "px-1.5",
          "py-0.5",
          "rounded-md",
          "opacity-0",
          "group-hover:opacity-100",
          "transition-opacity",
          "focus:outline-none",
          "focus:ring-1",
          "focus:ring-ring"
        );
        copyButton.onclick = () => {
          navigator.clipboard.writeText(textToCopy).then(() => {
            copyButton.textContent = "Copied!";
            setTimeout(() => {
              copyButton.textContent = "Copy";
            }, 2e3);
          }).catch((err) => {
            console.error("Failed to copy text: ", err);
            copyButton.textContent = "Error";
            setTimeout(() => {
              copyButton.textContent = "Copy";
            }, 2e3);
          });
        };
        messageDiv.appendChild(copyButton);
      }
      function displayError(message) {
        errorDisplay.textContent = message;
        console.error("Error displayed to user:", message);
      }
      function clearError() {
        errorDisplay.textContent = "";
      }
      function updateStreamingUI(streaming) {
        isStreaming = streaming;
        if (streaming) {
          sendMessageButton.classList.add("hidden");
          stopGeneratingButton.classList.remove("hidden");
          messageInput.disabled = true;
        } else {
          sendMessageButton.classList.remove("hidden");
          stopGeneratingButton.classList.add("hidden");
          messageInput.disabled = false;
          messageInput.focus();
          if (currentGeminiMessageDiv && currentOutputText) {
            addCopyButton(currentGeminiMessageDiv, currentOutputText);
          }
          currentGeminiMessageDiv = null;
          currentOutputText = "";
        }
      }
      async function handleSendMessage() {
        const messageText = messageInput.value.trim();
        if (!messageText || isStreaming) return;
        clearError();
        await addMessage(messageText, "user");
        messageInput.value = "";
        messageInput.style.height = "auto";
        updateStreamingUI(true);
        chrome.runtime.sendMessage(
          {
            action: "processChat",
            message: messageText,
            instanceId: sidePanelInstanceId
          },
          (response) => {
            if (chrome.runtime.lastError) {
              console.error("Error sending 'processChat' message:", chrome.runtime.lastError);
              displayError(`Extension communication error: ${chrome.runtime.lastError.message}`);
              updateStreamingUI(false);
            } else if (response && !response.success && response.error) {
              console.error("Immediate error response from service worker:", response.error);
              displayError(response.error);
              updateStreamingUI(false);
            }
          }
        );
      }
      toggleApiKeyVisibilityButton.addEventListener("click", () => {
        const isHidden = apiKeyDetails.classList.contains("hidden");
        toggleApiKeySection(isHidden);
      });
      saveApiKeyButton.addEventListener("click", () => {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          apiKeyStatus.textContent = "Please enter an API key.";
          apiKeyStatus.style.color = "red";
          return;
        }
        chrome.runtime.sendMessage({ action: "saveApiKey", apiKey }, (response) => {
          if (response && response.success) {
            apiKeyStatus.textContent = "API Key saved successfully!";
            apiKeyStatus.style.color = "green";
            clearError();
            toggleApiKeySection(false);
          } else {
            const errorMsg = response?.error || "Failed to save API Key.";
            apiKeyStatus.textContent = `Error: ${errorMsg}`;
            apiKeyStatus.style.color = "red";
            console.error("Failed to save API Key:", response);
            displayError(`Failed to save API Key: ${errorMsg}`);
            toggleApiKeySection(true);
          }
        });
      });
      sendMessageButton.addEventListener("click", () => {
        handleSendMessage().catch(console.error);
      });
      messageInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleSendMessage().catch(console.error);
        }
      });
      stopGeneratingButton.addEventListener("click", () => {
        if (!isStreaming) return;
        console.log("Stop Generating button clicked.");
        stopGeneratingButton.disabled = true;
        stopGeneratingButton.textContent = "Stopping...";
        chrome.runtime.sendMessage(
          { action: "stopGeneration", instanceId: sidePanelInstanceId },
          (response) => {
            stopGeneratingButton.disabled = false;
            stopGeneratingButton.innerHTML = `
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 mr-1.5">
                <path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM8 7a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1H8Z" clip-rule="evenodd" />
             </svg>
            Stop Generating`;
            if (chrome.runtime.lastError) {
              console.error("Error sending 'stopGeneration' message:", chrome.runtime.lastError);
              displayError(`Error stopping generation: ${chrome.runtime.lastError.message}`);
            } else if (response && !response.success) {
              console.warn("Stop generation request failed:", response.message);
            } else {
              console.log("Stop request acknowledged by service worker.");
            }
          }
        );
      });
      chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        if (request.instanceId && request.instanceId !== sidePanelInstanceId) {
          return;
        }
        console.log("Sidepanel received message for this instance:", request.action);
        (async () => {
          switch (request.action) {
            case "streamStart":
              await addMessage("", "gemini", false);
              clearError();
              updateStreamingUI(true);
              break;
            case "streamChunk":
              if (currentGeminiMessageDiv) {
                await addMessage(request.chunk, "gemini", false);
              } else {
                console.warn("Received stream chunk but no active message div.");
                await addMessage(request.chunk, "gemini", true);
              }
              break;
            case "streamEnd":
              console.log("Stream ended.");
              updateStreamingUI(false);
              break;
            case "streamError":
              console.error("Streaming Error:", request.error);
              displayError(`Error: ${request.error}`);
              if (!currentGeminiMessageDiv) {
                await addMessage(`[Error: ${request.error}]`, "gemini", true);
              } else {
                currentOutputText += `
[Error: ${request.error}]`;
                const renderedHtml = await processor.process(currentOutputText);
                currentGeminiMessageDiv.querySelector(".message-content").innerHTML = String(renderedHtml);
                addCopyButton(currentGeminiMessageDiv, currentOutputText);
                currentGeminiMessageDiv = null;
                currentOutputText = "";
              }
              updateStreamingUI(false);
              break;
            case "streamAbort":
              console.log("Stream aborted by user.");
              if (currentGeminiMessageDiv) {
                currentOutputText += "\n[Generation stopped by user]";
                const renderedHtml = await processor.process(currentOutputText);
                currentGeminiMessageDiv.querySelector(".message-content").innerHTML = String(renderedHtml);
                addCopyButton(currentGeminiMessageDiv, currentOutputText);
              } else {
                await addMessage("[Generation stopped by user]", "gemini", true);
              }
              updateStreamingUI(false);
              break;
          }
        })().catch(console.error);
        return false;
      });
    }
  });
  require_sidepanel();
})();
